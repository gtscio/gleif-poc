import * as ed from "@noble/ed25519";
import { decodeB64, encodeB64, Jwk, JwkGenOutput } from "./identity_wasm.js";
export class JwkMemStore {
    /** The map from key identifiers to Jwks. */
    _keys;
    /** Creates a new, empty `MemStore` instance. */
    constructor() {
        this._keys = new Map();
    }
    static ed25519KeyType() {
        return "Ed25519";
    }
    async generate(keyType, algorithm) {
        if (keyType !== JwkMemStore.ed25519KeyType()) {
            throw new Error(`unsupported key type ${keyType}`);
        }
        if (algorithm !== "EdDSA" /* JwsAlgorithm.EdDSA */) {
            throw new Error(`unsupported algorithm`);
        }
        const keyId = randomKeyId();
        const privKey = ed.utils.randomPrivateKey();
        const jwk = await encodeJwk(privKey, algorithm);
        this._keys.set(keyId, jwk);
        const publicJWK = jwk.toPublic();
        if (!publicJWK) {
            throw new Error(`JWK is not a public key`);
        }
        return new JwkGenOutput(keyId, publicJWK);
    }
    async sign(keyId, data, publicKey) {
        if (publicKey.alg() !== "EdDSA" /* JwsAlgorithm.EdDSA */) {
            throw new Error("unsupported JWS algorithm");
        }
        else {
            if (publicKey.paramsOkp()?.crv !== "Ed25519" /* EdCurve.Ed25519 */) {
                throw new Error("unsupported Okp parameter");
            }
        }
        const jwk = this._keys.get(keyId);
        if (jwk) {
            const [privateKey, _] = decodeJwk(jwk);
            return ed.sign(data, privateKey);
        }
        else {
            throw new Error(`key with id ${keyId} not found`);
        }
    }
    async insert(jwk) {
        const keyId = randomKeyId();
        if (!jwk.isPrivate) {
            throw new Error("expected a JWK with all private key components set");
        }
        if (!jwk.alg()) {
            throw new Error("expected a Jwk with an `alg` parameter");
        }
        this._keys.set(keyId, jwk);
        return keyId;
    }
    async delete(keyId) {
        this._keys.delete(keyId);
    }
    async exists(keyId) {
        return this._keys.has(keyId);
    }
    count() {
        return this._keys.size;
    }
    _get_key(keyId) {
        return this._keys.get(keyId);
    }
}
// Encodes a Ed25519 keypair into a Jwk.
async function encodeJwk(privateKey, alg) {
    const publicKey = await ed.getPublicKey(privateKey);
    let x = encodeB64(publicKey);
    let d = encodeB64(privateKey);
    const jwk = new Jwk({
        "kty": "OKP" /* JwkType.Okp */,
        "crv": "Ed25519",
        d,
        x,
        alg,
    });
    jwk.setKid(jwk.thumbprintSha256B64());
    return jwk;
}
function decodeJwk(jwk) {
    if (jwk.alg() !== "EdDSA" /* JwsAlgorithm.EdDSA */) {
        throw new Error("unsupported `alg`");
    }
    const paramsOkp = jwk.paramsOkp();
    if (paramsOkp) {
        const d = paramsOkp.d;
        if (d) {
            let textEncoder = new TextEncoder();
            const privateKey = decodeB64(textEncoder.encode(d));
            const publicKey = decodeB64(textEncoder.encode(paramsOkp.x));
            return [privateKey, publicKey];
        }
        else {
            throw new Error("missing private key component");
        }
    }
    else {
        throw new Error("expected Okp params");
    }
}
// Returns a random number between `min` and `max` (inclusive).
// SAFETY NOTE: This is not cryptographically secure randomness and thus not suitable for production use.
// It suffices for our testing implementation however and avoids an external dependency.
function getRandomNumber(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
// Returns a random key id.
function randomKeyId() {
    const randomness = new Uint8Array(20);
    for (let index = 0; index < randomness.length; index++) {
        randomness[index] = getRandomNumber(0, 255);
    }
    return encodeB64(randomness);
}
//# sourceMappingURL=jwk_storage.js.map