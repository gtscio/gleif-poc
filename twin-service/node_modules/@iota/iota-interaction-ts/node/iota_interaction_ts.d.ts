/* tslint:disable */
/* eslint-disable */

import { PublicKey } from "@iota/iota-sdk/cryptography";

interface TransactionSigner {
  sign: (tx_data_bcs: Uint8Array) => Promise<string>;
  publicKey: () => Promise<PublicKey>;
  iotaPublicKeyBytes: () => Promise<Uint8Array>;
  keyId: () => string;
}



  import {
    Balance,
    ExecuteTransactionBlockParams,
    GetCoinsParams,
    GetDynamicFieldObjectParams,
    GetObjectParams,
    GetOwnedObjectsParams,
    GetTransactionBlockParams,
    IotaClient,
    IotaObjectData,
    IotaObjectResponse,
    IotaTransactionBlockResponse,
    IotaTransactionBlockResponseOptions,
    ObjectRead,
    PaginatedCoins,
    PaginatedEvents,
    PaginatedObjectsResponse,
    QueryEventsParams,
    TryGetPastObjectParams,
    DevInspectTransactionBlockParams,
    DevInspectResults
  } from "@iota/iota-sdk/client";
  import { bcs } from "@iota/iota-sdk/bcs";
  import {
    executeTransaction,
    WasmIotaTransactionBlockResponseWrapper,
  } from "./iota_client_helpers"


/**
 * A wrapper over an {@link @iota/iota-sdk/cryptography/KeyPair | IOTA KeyPair}
 * that implements {@link TransactionSigner}.
 */
export class KeyPairSigner {
  free(): void;
  /**
   * Returns a new {@link KeyPairSigner} from the given
   * {@link @iota/iota-sdk/cryptography/KeyPair | IOTA KeyPair}.
   */
  constructor(wasm_keypair: KeyPair);
  sign(tx_data_bcs: Uint8Array): Promise<string>;
  publicKey(): Promise<PublicKey>;
  keyId(): string;
  iotaPublicKeyBytes(): Uint8Array;
}
/**
 * An implementation of the Signer interface that relies on
 * IOTA Keytool.
 */
export class KeytoolSigner {
  free(): void;
  /**
   * Returns a new {@link KeytoolSigner}. The optional parameters respectively
   * allow to set the signing address and the `iota` binary to use. Defaults
   * to use the current active address and the binary found in $PATH.
   */
  constructor(address?: string | null, iota_bin_location?: string | null);
  /**
   * Returns the signing address.
   */
  address(): string;
  keyId(): string;
  publicKey(): Promise<PublicKey>;
  sign(tx_data_bcs: Uint8Array): Promise<string>;
  iotaPublicKeyBytes(): Promise<Uint8Array>;
}
/**
 * IOTA Keytool CLI wrapper.
 */
export class KeytoolStorage {
  free(): void;
  /**
   * Creates a new {@link KeytoolStorage} that wraps the given iota binary.
   * Attempts to use the one in PATH if none is provided.
   */
  constructor(iota_bin?: string | null);
  /**
   * Returns a {@link KeytoolSigner} that will use the provided `address`
   * to sign transactions. If no address is provided the current active
   * one will be used.
   */
  signer(address?: string | null): KeytoolSigner;
  /**
   * Creates a new key of type `key_scheme`.
   * Returns the tuple ([`PublicKey`](https://docs.iota.org/ts-sdk/api/cryptography/classes/PublicKey), alias).
   */
  generateKey(key_scheme: 'ed25519' | 'secp256r1' | 'secp256k1'): [PublicKey, string];
  /**
   * Inserts a Bech32-encoded private key in the keystore.
   * The key must use the prefix `iotaprivkey`.
   *
   * Returns the key's alias.
   */
  insertKey(bech32_secret_key: string): string;
  /**
   * Signs `data` with `address`'s secret key.
   */
  signRaw(address: string, data: Uint8Array): Uint8Array;
  /**
   * Updates an alias from `old_alias` to `new_alias`
   * If no value for `new_alias` is provided, a randomly generated one will be used.
   */
  updateAlias(old_alias: string, new_alias?: string | null): void;
  /**
   * Returns the [`PublicKey`](https://docs.iota.org/ts-sdk/api/cryptography/classes/PublicKey) for the given address together with its alias.
   */
  getKey(address: string): [PublicKey, string];
  /**
   * Returns the [`PublicKey`](https://docs.iota.org/ts-sdk/api/cryptography/classes/PublicKey) that has the given alias.
   */
  getKeyByAlias(alias: string): PublicKey;
}
