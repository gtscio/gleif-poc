import type { IJwtHeader } from "../models/IJwtHeader";
import type { IJwtPayload } from "../models/IJwtPayload";
import type { JwkCryptoKey } from "../models/jwkCryptoKey";
/**
 * Class to handle JSON Web Tokens.
 */
export declare class Jwt {
    /**
     * Encode a token.
     * @param header The header to encode.
     * @param payload The payload to encode.
     * @param key The key for signing the token, can be omitted if a signer is provided.
     * @returns The encoded token.
     */
    static encode<T extends IJwtHeader, U extends IJwtPayload>(header: T, payload: U, key: JwkCryptoKey): Promise<string>;
    /**
     * Encode a token.
     * @param header The header to encode.
     * @param payload The payload to encode.
     * @param signer Custom signer method.
     * @returns The encoded token.
     */
    static encodeWithSigner<T extends IJwtHeader, U extends IJwtPayload>(header: T, payload: U, signer: (header: IJwtHeader, payload: IJwtPayload, key: JwkCryptoKey | undefined) => Promise<string>): Promise<string>;
    /**
     * Decode a token.
     * @param token The token to decode.
     * @returns The decoded payload.
     */
    static decode<T extends IJwtHeader, U extends IJwtPayload>(token: string): Promise<{
        header?: T;
        payload?: U;
        signature?: Uint8Array;
    }>;
    /**
     * Verify a token.
     * @param token The token to verify.
     * @param key The key for verifying the token
     * @returns The decoded payload.
     */
    static verify<T extends IJwtHeader, U extends IJwtPayload>(token: string, key: JwkCryptoKey): Promise<{
        header: T;
        payload: U;
    }>;
    /**
     * Verify a token.
     * @param token The token to verify.
     * @param verifier Custom verification method.
     * @returns The decoded payload.
     */
    static verifyWithVerifier<T extends IJwtHeader, U extends IJwtPayload>(token: string, verifier: (token: string, key: JwkCryptoKey | undefined) => Promise<{
        header: T;
        payload: U;
    }>): Promise<{
        header: T;
        payload: U;
    }>;
    /**
     * Verify a token by parts.
     * @param token The token to verify.
     * @param key The key for verifying the token, if not provided no verification occurs.
     * @param verifier Custom verification method.
     * @returns True if the parts are verified.
     */
    static verifySignature<T extends IJwtHeader, U extends IJwtPayload>(token: string, key?: JwkCryptoKey, verifier?: (token: string, key: JwkCryptoKey | undefined) => Promise<{
        header: T;
        payload: U;
    }>): Promise<{
        header: T;
        payload: U;
    }>;
    /**
     * The default signer for the JWT.
     * @param header The header to sign.
     * @param payload The payload to sign.
     * @param key The optional key to sign with.
     * @returns The signature.
     */
    static defaultSigner(header: IJwtHeader, payload: IJwtPayload, key: JwkCryptoKey | undefined): Promise<string>;
    /**
     * The default verifier for the JWT.
     * @param token The token to verify.
     * @param key The key to verify with.
     * @returns The header and payload if verification successful.
     */
    static defaultVerifier<T extends IJwtHeader, U extends IJwtPayload>(token: string, key: JwkCryptoKey | undefined): Promise<{
        header: T;
        payload: U;
    }>;
    /**
     * Create bytes for signing from header and payload.
     * @param header The header.
     * @param payload The payload.
     * @returns The bytes to sign.
     */
    static toSigningBytes<T extends IJwtHeader, U extends IJwtPayload>(header: T, payload: U): Uint8Array;
    /**
     * Create header and payload from signing bytes.
     * @param signingBytes The signing bytes from a token.
     * @returns The header and payload.
     * @throws If the signing bytes are invalid
     */
    static fromSigningBytes<T extends IJwtHeader, U extends IJwtPayload>(signingBytes: Uint8Array): {
        header: T;
        payload: U;
    };
    /**
     * Convert signed bytes and signature bytes to token.
     * @param signingBytes The signed bytes.
     * @param signature The signature.
     * @returns The token.
     */
    static tokenFromBytes(signingBytes: Uint8Array, signature: Uint8Array): string;
    /**
     * Convert the token to signing bytes and signature bytes.
     * @param token The token to convert to bytes.
     * @returns The decoded bytes.
     * @throws If the token is invalid.
     */
    static tokenToBytes(token: string): {
        signingBytes: Uint8Array;
        signature: Uint8Array;
    };
}
