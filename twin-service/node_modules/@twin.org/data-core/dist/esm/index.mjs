import { Factory, Urn, Is, StringHelper } from '@twin.org/core';
import { FetchHelper, HttpMethod } from '@twin.org/web';
import Ajv from 'ajv/dist/2020.js';
import addFormats from 'ajv-formats';

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Factory for creating handlers for data types.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const DataTypeHandlerFactory = Factory.createFactory("data-type");

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Factory for creating handlers for identifiers.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const IdentifierHandlerFactory = Factory.createFactory("namespace", false, (names, uri) => {
    Urn.guard("IdentifierHandlerFactory", "uri", uri);
    const urn = Urn.fromValidString(uri);
    const urnParts = urn.parts();
    for (let i = urnParts.length - 1; i >= 0; i--) {
        const wholeNamespace = urnParts.slice(i).join(":");
        if (names.includes(wholeNamespace)) {
            return wholeNamespace;
        }
    }
});

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Validation modes for validating data types.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const ValidationMode = {
    /**
     * Use the validation method of the data type.
     */
    Validate: "validate",
    /**
     * Use the JSON Schema methods of the data type.
     */
    JsonSchema: "json-schema",
    /**
     * Use either validation mode.
     */
    Either: "either",
    /**
     * Use both validation modes.
     */
    Both: "both"
};

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * A helper for JSON schemas.
 */
class JsonSchemaHelper {
    /**
     * The schema version.
     */
    static SCHEMA_VERSION = "https://json-schema.org/draft/2020-12/schema";
    /**
     * The class name.
     * @internal
     */
    static _CLASS_NAME = "JsonSchemaHelper";
    /**
     * Validates data against the schema.
     * @param schema The schema to validate the data with.
     * @param data The data to be validated.
     * @param additionalTypes Additional types to add for reference, not already in DataTypeHandlerFactory.
     * @returns Result containing errors if there are any.
     */
    static async validate(schema, data, additionalTypes) {
        const ajv = new Ajv({
            allowUnionTypes: true,
            // Disable strict tuples as it causes issues with the schema validation when
            // you have an array with fixed elements e.g. myType: [string, ...string[]]
            // https://github.com/ajv-validator/ajv/issues/1417
            strictTuples: false,
            loadSchema: async (uri) => {
                const subTypeHandler = DataTypeHandlerFactory.getIfExists(uri);
                if (Is.function(subTypeHandler?.jsonSchema)) {
                    const subSchema = await subTypeHandler.jsonSchema();
                    if (Is.object(subSchema)) {
                        return subSchema;
                    }
                }
                try {
                    // We don't have the type in our local data types, so we try to fetch it from the web
                    return FetchHelper.fetchJson(JsonSchemaHelper._CLASS_NAME, uri, HttpMethod.GET, undefined, {
                        // Cache for an hour
                        cacheTtlMs: 3600000
                    });
                }
                catch {
                    // Failed to load remotely so return an empty object
                    // so the schema validation doesn't completely fail
                    return {};
                }
            }
        });
        addFormats(ajv);
        // Add the additional types provided by the user
        if (Is.objectValue(additionalTypes)) {
            for (const key in additionalTypes) {
                ajv.addSchema(additionalTypes[key], key);
            }
        }
        const compiled = await ajv.compileAsync(schema);
        const result = await compiled(data);
        const output = {
            result
        };
        if (!output.result) {
            output.error = compiled.errors;
        }
        return output;
    }
    /**
     * Get the property type from a schema.
     * @param schema The schema to extract the types from.
     * @param propertyName The name of the property to get the type for.
     * @returns The types of the property.
     */
    static getPropertyType(schema, propertyName) {
        if (schema.type === "object" && Is.objectValue(schema.properties)) {
            const propertySchema = schema.properties[propertyName];
            if (Is.object(propertySchema)) {
                if (Is.stringValue(propertySchema.$ref)) {
                    return propertySchema.$ref;
                }
                return propertySchema.type;
            }
        }
    }
    /**
     * Convert an entity schema to JSON schema e.g https://example.com/schemas/.
     * @param entitySchema The entity schema to convert.
     * @param baseDomain The base domain for local schemas e.g. https://example.com/
     * @returns The JSON schema for the entity.
     */
    static entitySchemaToJsonSchema(entitySchema, baseDomain) {
        let domain = StringHelper.trimTrailingSlashes(baseDomain ?? "");
        if (domain.length > 0) {
            domain += "/";
        }
        const properties = {};
        const required = [];
        if (Is.arrayValue(entitySchema?.properties)) {
            for (const propertySchema of entitySchema.properties) {
                const jsonPropertySchema = {
                    type: propertySchema.type,
                    description: propertySchema.description,
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    examples: propertySchema.examples
                };
                if (Is.stringValue(propertySchema.itemType) && propertySchema.type === "array") {
                    if (propertySchema.itemType === "object") {
                        jsonPropertySchema.items = {
                            $ref: propertySchema.itemTypeRef?.startsWith("http")
                                ? propertySchema.itemTypeRef
                                : `${domain}${propertySchema.itemTypeRef}`
                        };
                    }
                    else {
                        jsonPropertySchema.items = {
                            type: propertySchema.itemType
                        };
                    }
                }
                else if (propertySchema.type === "object") {
                    delete jsonPropertySchema.type;
                    jsonPropertySchema.$ref = propertySchema.itemTypeRef?.startsWith("http")
                        ? propertySchema.itemTypeRef
                        : `${domain}${propertySchema.itemTypeRef}`;
                }
                properties[propertySchema.property] = jsonPropertySchema;
                if (!propertySchema.optional) {
                    required.push(propertySchema.property);
                }
            }
        }
        return {
            $schema: JsonSchemaHelper.SCHEMA_VERSION,
            $id: `${domain}${entitySchema?.type}`,
            title: entitySchema?.type,
            type: entitySchema ? "object" : "null",
            description: entitySchema?.options?.description,
            required,
            properties,
            additionalProperties: false
        };
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to help with data types.
 */
class DataTypeHelper {
    /**
     * Validate a data type.
     * @param propertyName The name of the property being validated to use in error messages.
     * @param dataType The data type to validate.
     * @param data The data to validate.
     * @param validationFailures The list of validation failures to add to.
     * @param options Optional options for validation.
     * @param options.failOnMissingType If true, will fail validation if the data type is missing, defaults to false.
     * @param options.validationMode The validation mode to use, defaults to either.
     * @returns True if the data was valid.
     */
    static async validate(propertyName, dataType, data, validationFailures, options) {
        let isValid = true;
        if (Is.stringValue(dataType)) {
            const handler = DataTypeHandlerFactory.getIfExists(dataType);
            if (handler) {
                const validationMode = options?.validationMode ?? ValidationMode.Either;
                // If we have a validate function use that as it is more specific
                // and will produce better error messages
                let hasValidated = false;
                if ((validationMode === ValidationMode.Validate ||
                    validationMode === ValidationMode.Both ||
                    validationMode === ValidationMode.Either) &&
                    Is.function(handler.validate)) {
                    isValid = await handler.validate(propertyName, data, validationFailures);
                    hasValidated = true;
                }
                if ((validationMode === ValidationMode.JsonSchema ||
                    (validationMode === ValidationMode.Either && !hasValidated) ||
                    validationMode === ValidationMode.Both) &&
                    Is.function(handler.jsonSchema)) {
                    // Otherwise use the JSON schema if there is one
                    const schema = await handler.jsonSchema();
                    if (Is.object(schema)) {
                        const validationResult = await JsonSchemaHelper.validate(schema, data);
                        if (Is.arrayValue(validationResult.error)) {
                            validationFailures.push({
                                property: propertyName,
                                reason: "validation.schema.failedValidation",
                                properties: {
                                    value: data,
                                    schemaErrors: validationResult.error,
                                    message: validationResult.error.map(e => e.message).join("\n")
                                }
                            });
                        }
                        if (!validationResult.result) {
                            isValid = false;
                        }
                    }
                }
            }
            else if (options?.failOnMissingType ?? false) {
                // If we don't have a handler for a specific type and we are failing on missing type
                validationFailures.push({
                    property: propertyName,
                    reason: "validation.schema.missingType",
                    properties: {
                        dataType
                    }
                });
                isValid = false;
            }
        }
        return isValid;
    }
}

export { DataTypeHandlerFactory, DataTypeHelper, IdentifierHandlerFactory, JsonSchemaHelper, ValidationMode };
