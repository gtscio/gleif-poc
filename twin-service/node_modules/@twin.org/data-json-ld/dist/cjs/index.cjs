'use strict';

var dataCore = require('@twin.org/data-core');
var core = require('@twin.org/core');
var web = require('@twin.org/web');
var jsonLd = require('jsonld');

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * The contexts of JSON-LD data.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const JsonLdContexts = {
    /**
     * Context Root.
     */
    ContextRoot: "https://schema.twindev.org/json-ld/"
};

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * The types of JSON-LD data.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const JsonLdTypes = {
    /**
     * Represents JSON-LD Document.
     */
    Document: "JsonLdDocument",
    /**
     * Represents JSON-LD Object.
     */
    Object: "JsonLdObject",
    /**
     * Represents JSON-LD Node Object.
     */
    NodeObject: "JsonLdNodeObject",
    /**
     * Represents JSON-LD Node Primitive.
     */
    NodePrimitive: "JsonLdNodePrimitive",
    /**
     * Represents JSON-LD Graph Object.
     */
    GraphObject: "JsonLdGraphObject",
    /**
     * Represents JSON-LD Value Object.
     */
    ValueObject: "JsonLdValueObject",
    /**
     * Represents JSON-LD List Object.
     */
    ListObject: "JsonLdListObject",
    /**
     * Represents JSON-LD Set Object.
     */
    SetObject: "JsonLdSetObject",
    /**
     * Represents JSON-LD Language Map.
     */
    LanguageMap: "JsonLdLanguageMap",
    /**
     * Represents JSON-LD Index Map.
     */
    IndexMap: "JsonLdIndexMap",
    /**
     * Represents JSON-LD Index Map Item.
     */
    IndexMapItem: "JsonLdIndexMapItem",
    /**
     * Represents JSON-LD Id Map.
     */
    IdMap: "JsonLdIdMap",
    /**
     * Represents JSON-LD Type Map.
     */
    TypeMap: "JsonLdTypeMap",
    /**
     * Represents JSON-LD Included block.
     */
    IncludedBlock: "JsonLdIncludedBlock",
    /**
     * Represents JSON-LD Context Definition.
     */
    ContextDefinition: "JsonLdContextDefinition",
    /**
     * Represents JSON-LD Context Definition Element.
     */
    ContextDefinitionElement: "JsonLdContextDefinitionElement",
    /**
     * Represents JSON-LD Context Definition Root.
     */
    ContextDefinitionRoot: "JsonLdContextDefinitionRoot",
    /**
     * Represents JSON-LD Expanded Term Definition.
     */
    ExpandedTermDefinition: "JsonLdExpandedTermDefinition",
    /**
     * Represents JSON-LD Keyword.
     */
    Keyword: "JsonLdKeyword",
    /**
     * Represents JSON-LD List or Set Item.
     */
    ListOrSetItem: "JsonLdListOrSetItem",
    /**
     * Represents JSON-LD Container Type.
     */
    ContainerType: "JsonLdContainerType",
    /**
     * Represents JSON-LD Container Type Array.
     */
    ContainerTypeArray: "JsonLdContainerTypeArray",
    /**
     * Represents JSON-LD JSON Primitive.
     */
    JsonPrimitive: "JsonLdJsonPrimitive",
    /**
     * Represents JSON-LD JSON Array.
     */
    JsonArray: "JsonLdJsonArray",
    /**
     * Represents JSON-LD JSON Object.
     */
    JsonObject: "JsonLdJsonObject",
    /**
     * Represents JSON-LD JSON Value.
     */
    JsonValue: "JsonLdJsonValue"
};

var $schema$o = "https://json-schema.org/draft/2020-12/schema";
var $id$o = "https://schema.twindev.org/json-ld/JsonLdContainerType";
var description$o = "JSON-LD container types.";
var type$d = "string";
var JsonLdContainerTypeSchema = {
	$schema: $schema$o,
	$id: $id$o,
	description: description$o,
	type: type$d,
	"enum": [
	"@language",
	"@index",
	"@id",
	"@graph",
	"@type"
]
};

var $schema$n = "https://json-schema.org/draft/2020-12/schema";
var $id$n = "https://schema.twindev.org/json-ld/JsonLdContainerTypeArray";
var description$n = "JSON-LD container type array.";
var anyOf$a = [
	{
		type: "array",
		minItems: 2,
		items: false,
		maxItems: 2,
		prefixItems: [
			{
				type: "string",
				"const": "@graph"
			},
			{
				type: "string",
				"const": "@id"
			}
		]
	},
	{
		type: "array",
		minItems: 2,
		items: false,
		maxItems: 2,
		prefixItems: [
			{
				type: "string",
				"const": "@id"
			},
			{
				type: "string",
				"const": "@graph"
			}
		]
	},
	{
		type: "array",
		minItems: 3,
		items: false,
		maxItems: 3,
		prefixItems: [
			{
				type: "string",
				"const": "@set"
			},
			{
				type: "string",
				"const": "@graph"
			},
			{
				type: "string",
				"const": "@id"
			}
		]
	},
	{
		type: "array",
		minItems: 3,
		items: false,
		maxItems: 3,
		prefixItems: [
			{
				type: "string",
				"const": "@set"
			},
			{
				type: "string",
				"const": "@id"
			},
			{
				type: "string",
				"const": "@graph"
			}
		]
	},
	{
		type: "array",
		minItems: 3,
		items: false,
		maxItems: 3,
		prefixItems: [
			{
				type: "string",
				"const": "@graph"
			},
			{
				type: "string",
				"const": "@set"
			},
			{
				type: "string",
				"const": "@id"
			}
		]
	},
	{
		type: "array",
		minItems: 3,
		items: false,
		maxItems: 3,
		prefixItems: [
			{
				type: "string",
				"const": "@id"
			},
			{
				type: "string",
				"const": "@set"
			},
			{
				type: "string",
				"const": "@graph"
			}
		]
	},
	{
		type: "array",
		minItems: 3,
		items: false,
		maxItems: 3,
		prefixItems: [
			{
				type: "string",
				"const": "@graph"
			},
			{
				type: "string",
				"const": "@id"
			},
			{
				type: "string",
				"const": "@set"
			}
		]
	},
	{
		type: "array",
		minItems: 3,
		items: false,
		maxItems: 3,
		prefixItems: [
			{
				type: "string",
				"const": "@id"
			},
			{
				type: "string",
				"const": "@graph"
			},
			{
				type: "string",
				"const": "@set"
			}
		]
	},
	{
		type: "array",
		minItems: 2,
		items: false,
		maxItems: 2,
		prefixItems: [
			{
				type: "string",
				"const": "@set"
			},
			{
				$ref: "https://schema.twindev.org/json-ld/JsonLdContainerType"
			}
		]
	},
	{
		type: "array",
		minItems: 2,
		items: false,
		maxItems: 2,
		prefixItems: [
			{
				$ref: "https://schema.twindev.org/json-ld/JsonLdContainerType"
			},
			{
				type: "string",
				"const": "@set"
			}
		]
	}
];
var JsonLdContainerTypeArraySchema = {
	$schema: $schema$n,
	$id: $id$n,
	description: description$n,
	anyOf: anyOf$a
};

var $schema$m = "https://json-schema.org/draft/2020-12/schema";
var $id$m = "https://schema.twindev.org/json-ld/JsonLdContextDefinition";
var description$m = "A context definition defines a local context in a node object.";
var type$c = "object";
var properties$5 = {
	"@base": {
		type: [
			"string",
			"null"
		]
	},
	"@direction": {
		type: [
			"string",
			"null"
		],
		"enum": [
			"ltr",
			"rtl",
			null
		]
	},
	"@import": {
		type: "string"
	},
	"@language": {
		type: "string"
	},
	"@propagate": {
		type: "boolean"
	},
	"@protected": {
		type: "boolean"
	},
	"@type": {
		type: "object",
		properties: {
			"@container": {
				type: "string",
				"const": "@set"
			},
			"@protected": {
				type: "boolean"
			}
		},
		required: [
			"@container"
		],
		additionalProperties: false
	},
	"@version": {
		type: "string",
		"const": "1.1"
	},
	"@vocab": {
		type: [
			"string",
			"null"
		]
	}
};
var additionalProperties$a = {
	anyOf: [
		{
			type: "null"
		},
		{
			type: "string"
		},
		{
			$ref: "https://schema.twindev.org/json-ld/JsonLdExpandedTermDefinition"
		}
	]
};
var JsonLdContextDefinitionSchema = {
	$schema: $schema$m,
	$id: $id$m,
	description: description$m,
	type: type$c,
	properties: properties$5,
	additionalProperties: additionalProperties$a
};

var $schema$l = "https://json-schema.org/draft/2020-12/schema";
var $id$l = "https://schema.twindev.org/json-ld/JsonLdContextDefinitionElement";
var description$l = "A context definition element is used to define the types of a context definition.";
var anyOf$9 = [
	{
		type: "null"
	},
	{
		type: "string"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdContextDefinition"
	}
];
var JsonLdContextDefinitionElementSchema = {
	$schema: $schema$l,
	$id: $id$l,
	description: description$l,
	anyOf: anyOf$9
};

var $schema$k = "https://json-schema.org/draft/2020-12/schema";
var $id$k = "https://schema.twindev.org/json-ld/JsonLdContextDefinitionRoot";
var description$k = "A context definition root is used to define the root of a context definition.";
var anyOf$8 = [
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdContextDefinitionElement"
	},
	{
		type: "array",
		items: false,
		prefixItems: [
			{
				$ref: "https://schema.twindev.org/json-ld/JsonLdContextDefinitionElement"
			}
		]
	}
];
var JsonLdContextDefinitionRootSchema = {
	$schema: $schema$k,
	$id: $id$k,
	description: description$k,
	anyOf: anyOf$8
};

var $schema$j = "https://json-schema.org/draft/2020-12/schema";
var $id$j = "https://schema.twindev.org/json-ld/JsonLdDocument";
var description$j = "A JSON-LD document MUST be valid JSON text as described in [RFC8259], or some format that can be represented in the JSON-LD internal representation that is equivalent to valid JSON text.";
var anyOf$7 = [
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
	},
	{
		type: "array",
		items: false,
		prefixItems: [
			{
				$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
			}
		]
	},
	{
		type: "object",
		properties: {
			"@context": {
				$ref: "https://schema.twindev.org/json-ld/JsonLdContextDefinitionRoot"
			},
			"@graph": {
				anyOf: [
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdValueObject"
					},
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
					},
					{
						type: "array",
						items: false,
						prefixItems: [
							{
								anyOf: [
									{
										$ref: "https://schema.twindev.org/json-ld/JsonLdValueObject"
									},
									{
										$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
									}
								]
							}
						]
					}
				]
			}
		},
		additionalProperties: false
	}
];
var JsonLdDocumentSchema = {
	$schema: $schema$j,
	$id: $id$j,
	description: description$j,
	anyOf: anyOf$7
};

var $schema$i = "https://json-schema.org/draft/2020-12/schema";
var $id$i = "https://schema.twindev.org/json-ld/JsonLdExpandedTermDefinition";
var description$i = "An expanded term definition is used to describe the mapping between a term and its expanded identifier, as well as other properties of the value associated with the term when it is used as key in a node object.";
var anyOf$6 = [
	{
		type: "object",
		additionalProperties: false,
		properties: {
			"@id": {
				anyOf: [
					{
						type: "string"
					},
					{
						type: "array",
						items: false,
						prefixItems: [
							{
								type: "string"
							}
						]
					},
					{
						type: "null"
					}
				]
			},
			"@nest": {
				type: "string"
			},
			"@container": {
				anyOf: [
					{
						type: "string",
						"const": "@list"
					},
					{
						type: "string",
						"const": "@set"
					},
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdContainerType"
					},
					{
						type: "array",
						items: false,
						prefixItems: [
							{
								anyOf: [
									{
										type: "string",
										"const": "@list"
									},
									{
										type: "string",
										"const": "@set"
									},
									{
										$ref: "https://schema.twindev.org/json-ld/JsonLdContainerType"
									}
								]
							}
						]
					},
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdContainerTypeArray"
					},
					{
						type: "null"
					}
				]
			},
			"@type": {
				type: "string"
			},
			"@language": {
				type: "string"
			},
			"@index": {
				type: "string"
			},
			"@context": {
				$ref: "https://schema.twindev.org/json-ld/JsonLdContextDefinition"
			},
			"@prefix": {
				type: "boolean"
			},
			"@propagate": {
				type: "boolean"
			},
			"@protected": {
				type: "boolean"
			}
		}
	},
	{
		type: "object",
		additionalProperties: false,
		properties: {
			"@reverse": {
				type: "string"
			},
			"@container": {
				type: [
					"string",
					"null"
				],
				"enum": [
					"@set",
					"@index",
					null
				]
			},
			"@type": {
				type: "string"
			},
			"@language": {
				type: "string"
			},
			"@index": {
				type: "string"
			},
			"@context": {
				$ref: "https://schema.twindev.org/json-ld/JsonLdContextDefinition"
			},
			"@prefix": {
				type: "boolean"
			},
			"@propagate": {
				type: "boolean"
			},
			"@protected": {
				type: "boolean"
			}
		},
		required: [
			"@reverse"
		]
	}
];
var JsonLdExpandedTermDefinitionSchema = {
	$schema: $schema$i,
	$id: $id$i,
	description: description$i,
	anyOf: anyOf$6
};

var $schema$h = "https://json-schema.org/draft/2020-12/schema";
var $id$h = "https://schema.twindev.org/json-ld/JsonLdGraphObject";
var description$h = "A graph object represents a named graph, which MAY include an explicit graph name.";
var type$b = "object";
var properties$4 = {
	"@graph": {
		anyOf: [
			{
				$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
			},
			{
				type: "array",
				items: false,
				prefixItems: [
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
					}
				]
			}
		]
	},
	"@index": {
		type: "string"
	},
	"@id": {
		anyOf: [
			{
				type: "string"
			},
			{
				type: "array",
				items: false,
				prefixItems: [
					{
						type: "string"
					}
				]
			}
		]
	},
	"@context": {
		$ref: "https://schema.twindev.org/json-ld/JsonLdContextDefinitionRoot"
	}
};
var required$2 = [
	"@graph"
];
var additionalProperties$9 = false;
var JsonLdGraphObjectSchema = {
	$schema: $schema$h,
	$id: $id$h,
	description: description$h,
	type: type$b,
	properties: properties$4,
	required: required$2,
	additionalProperties: additionalProperties$9
};

var $schema$g = "https://json-schema.org/draft/2020-12/schema";
var $id$g = "https://schema.twindev.org/json-ld/JsonLdIdMap";
var description$g = "An id map is used to associate an IRI with a value that allows easy programmatic access.";
var type$a = "object";
var additionalProperties$8 = {
	$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
};
var JsonLdIdMapSchema = {
	$schema: $schema$g,
	$id: $id$g,
	description: description$g,
	type: type$a,
	additionalProperties: additionalProperties$8
};

var $schema$f = "https://json-schema.org/draft/2020-12/schema";
var $id$f = "https://schema.twindev.org/json-ld/JsonLdIncludedBlock";
var description$f = "An included block is used to provide a set of node objects.";
var anyOf$5 = [
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
	},
	{
		type: "array",
		items: false,
		prefixItems: [
			{
				$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
			}
		]
	}
];
var JsonLdIncludedBlockSchema = {
	$schema: $schema$f,
	$id: $id$f,
	description: description$f,
	anyOf: anyOf$5
};

var $schema$e = "https://json-schema.org/draft/2020-12/schema";
var $id$e = "https://schema.twindev.org/json-ld/JsonLdIndexMap";
var description$e = "An index map allows keys that have no semantic meaning, but should be preserved regardless, to be used in JSON-LD documents.";
var type$9 = "object";
var additionalProperties$7 = {
	anyOf: [
		{
			$ref: "https://schema.twindev.org/json-ld/JsonLdIndexMapItem"
		},
		{
			type: "array",
			items: false,
			prefixItems: [
				{
					$ref: "https://schema.twindev.org/json-ld/JsonLdIndexMapItem"
				}
			]
		}
	]
};
var JsonLdIndexMapSchema = {
	$schema: $schema$e,
	$id: $id$e,
	description: description$e,
	type: type$9,
	additionalProperties: additionalProperties$7
};

var $schema$d = "https://json-schema.org/draft/2020-12/schema";
var $id$d = "https://schema.twindev.org/json-ld/JsonLdIndexMapItem";
var description$d = "The items that can be stored in an index map.";
var anyOf$4 = [
	{
		type: "null"
	},
	{
		type: "boolean"
	},
	{
		type: "number"
	},
	{
		type: "string"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdValueObject"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdListObject"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdSetObject"
	}
];
var JsonLdIndexMapItemSchema = {
	$schema: $schema$d,
	$id: $id$d,
	description: description$d,
	anyOf: anyOf$4
};

var $schema$c = "https://json-schema.org/draft/2020-12/schema";
var $id$c = "https://schema.twindev.org/json-ld/JsonLdJsonArray";
var description$c = "JSON Type for array.";
var type$8 = "array";
var items = false;
var prefixItems = [
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdJsonValue"
	}
];
var JsonLdJsonArraySchema = {
	$schema: $schema$c,
	$id: $id$c,
	description: description$c,
	type: type$8,
	items: items,
	prefixItems: prefixItems
};

var $schema$b = "https://json-schema.org/draft/2020-12/schema";
var $id$b = "https://schema.twindev.org/json-ld/JsonLdJsonObject";
var description$b = "JSON Type for object.";
var type$7 = "object";
var additionalProperties$6 = {
	anyOf: [
		{
			$ref: "https://schema.twindev.org/json-ld/JsonLdJsonValue"
		},
		{
			not: {
			}
		}
	]
};
var JsonLdJsonObjectSchema = {
	$schema: $schema$b,
	$id: $id$b,
	description: description$b,
	type: type$7,
	additionalProperties: additionalProperties$6
};

var $schema$a = "https://json-schema.org/draft/2020-12/schema";
var $id$a = "https://schema.twindev.org/json-ld/JsonLdJsonPrimitive";
var description$a = "JSON Primitive.";
var type$6 = [
	"string",
	"number",
	"boolean",
	"null"
];
var JsonLdJsonPrimitiveSchema = {
	$schema: $schema$a,
	$id: $id$a,
	description: description$a,
	type: type$6
};

var $schema$9 = "https://json-schema.org/draft/2020-12/schema";
var $id$9 = "https://schema.twindev.org/json-ld/JsonLdJsonValue";
var description$9 = "JSON Value.";
var anyOf$3 = [
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdJsonPrimitive"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdJsonArray"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdJsonObject"
	}
];
var JsonLdJsonValueSchema = {
	$schema: $schema$9,
	$id: $id$9,
	description: description$9,
	anyOf: anyOf$3
};

var $schema$8 = "https://json-schema.org/draft/2020-12/schema";
var $id$8 = "https://schema.twindev.org/json-ld/JsonLdLanguageMap";
var description$8 = "A language map is used to associate a language with a value in a way that allows easy programmatic access.";
var type$5 = "object";
var additionalProperties$5 = {
	anyOf: [
		{
			type: "null"
		},
		{
			type: "string"
		},
		{
			type: "array",
			items: false,
			prefixItems: [
				{
					type: "string"
				}
			]
		}
	]
};
var JsonLdLanguageMapSchema = {
	$schema: $schema$8,
	$id: $id$8,
	description: description$8,
	type: type$5,
	additionalProperties: additionalProperties$5
};

var $schema$7 = "https://json-schema.org/draft/2020-12/schema";
var $id$7 = "https://schema.twindev.org/json-ld/JsonLdListObject";
var description$7 = "A list represents an ordered set of values.";
var type$4 = "object";
var properties$3 = {
	"@list": {
		anyOf: [
			{
				$ref: "https://schema.twindev.org/json-ld/JsonLdListOrSetItem"
			},
			{
				type: "array",
				items: false,
				prefixItems: [
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdListOrSetItem"
					}
				]
			}
		]
	},
	"@index": {
		type: "string"
	}
};
var required$1 = [
	"@list"
];
var additionalProperties$4 = false;
var JsonLdListObjectSchema = {
	$schema: $schema$7,
	$id: $id$7,
	description: description$7,
	type: type$4,
	properties: properties$3,
	required: required$1,
	additionalProperties: additionalProperties$4
};

var $schema$6 = "https://json-schema.org/draft/2020-12/schema";
var $id$6 = "https://schema.twindev.org/json-ld/JsonLdListOrSetItem";
var description$6 = "A list or set item can be a null, boolean, number, string, node object, or value object.";
var anyOf$2 = [
	{
		type: "null"
	},
	{
		type: "boolean"
	},
	{
		type: "number"
	},
	{
		type: "string"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdValueObject"
	}
];
var JsonLdListOrSetItemSchema = {
	$schema: $schema$6,
	$id: $id$6,
	description: description$6,
	anyOf: anyOf$2
};

var $schema$5 = "https://json-schema.org/draft/2020-12/schema";
var $id$5 = "https://schema.twindev.org/json-ld/JsonLdNodeObject";
var description$5 = "A node object represents zero or more properties of a node in the graph serialized by the JSON-LD document.";
var type$3 = "object";
var additionalProperties$3 = {
	anyOf: [
		{
			$ref: "https://schema.twindev.org/json-ld/JsonLdNodePrimitive"
		},
		{
			$ref: "https://schema.twindev.org/json-ld/JsonLdLanguageMap"
		},
		{
			$ref: "https://schema.twindev.org/json-ld/JsonLdIndexMap"
		},
		{
			$ref: "https://schema.twindev.org/json-ld/JsonLdIncludedBlock"
		},
		{
			$ref: "https://schema.twindev.org/json-ld/JsonLdIdMap"
		},
		{
			$ref: "https://schema.twindev.org/json-ld/JsonLdTypeMap"
		},
		{
			type: "array"
		}
	]
};
var properties$2 = {
	"@context": {
		$ref: "https://schema.twindev.org/json-ld/JsonLdContextDefinitionRoot"
	},
	"@id": {
		anyOf: [
			{
				type: "string"
			},
			{
				type: "array",
				items: false,
				prefixItems: [
					{
						type: "string"
					}
				]
			}
		]
	},
	"@included": {
		$ref: "https://schema.twindev.org/json-ld/JsonLdIncludedBlock"
	},
	"@graph": {
		anyOf: [
			{
				$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
			},
			{
				type: "array",
				items: false,
				prefixItems: [
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
					}
				]
			}
		]
	},
	"@nest": {
		anyOf: [
			{
				$ref: "https://schema.twindev.org/json-ld/JsonLdJsonObject"
			},
			{
				type: "array",
				items: false,
				prefixItems: [
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdJsonObject"
					}
				]
			}
		]
	},
	"@type": {
		anyOf: [
			{
				type: "string"
			},
			{
				type: "array",
				items: false,
				prefixItems: [
					{
						type: "string"
					}
				]
			}
		]
	},
	"@reverse": {
		type: "object",
		additionalProperties: {
			type: "string"
		}
	},
	"@index": {
		type: "string"
	}
};
var JsonLdNodeObjectSchema = {
	$schema: $schema$5,
	$id: $id$5,
	description: description$5,
	type: type$3,
	additionalProperties: additionalProperties$3,
	properties: properties$2
};

var $schema$4 = "https://json-schema.org/draft/2020-12/schema";
var $id$4 = "https://schema.twindev.org/json-ld/JsonLdNodePrimitive";
var description$4 = "A node primitive is a JSON-LD value which is not one of the defined NodeObject properties.";
var anyOf$1 = [
	{
		type: "null"
	},
	{
		type: "boolean"
	},
	{
		type: "number"
	},
	{
		type: "string"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdGraphObject"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdValueObject"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdListObject"
	},
	{
		$ref: "https://schema.twindev.org/json-ld/JsonLdSetObject"
	}
];
var JsonLdNodePrimitiveSchema = {
	$schema: $schema$4,
	$id: $id$4,
	description: description$4,
	anyOf: anyOf$1
};

var $schema$3 = "https://json-schema.org/draft/2020-12/schema";
var $id$3 = "https://schema.twindev.org/json-ld/JsonLdObject";
var description$3 = "An object represents the pre-defined properties of the node object in the graph serialized by the JSON-LD document.";
var type$2 = "object";
var properties$1 = {
	"@context": {
		$ref: "https://schema.twindev.org/json-ld/JsonLdContextDefinitionRoot"
	},
	"@id": {
		anyOf: [
			{
				type: "string"
			},
			{
				type: "array",
				items: false,
				prefixItems: [
					{
						type: "string"
					}
				]
			}
		]
	},
	"@included": {
		$ref: "https://schema.twindev.org/json-ld/JsonLdIncludedBlock"
	},
	"@graph": {
		anyOf: [
			{
				$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
			},
			{
				type: "array",
				items: false,
				prefixItems: [
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
					}
				]
			}
		]
	},
	"@nest": {
		anyOf: [
			{
				$ref: "https://schema.twindev.org/json-ld/JsonLdJsonObject"
			},
			{
				type: "array",
				items: false,
				prefixItems: [
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdJsonObject"
					}
				]
			}
		]
	},
	"@type": {
		anyOf: [
			{
				type: "string"
			},
			{
				type: "array",
				items: false,
				prefixItems: [
					{
						type: "string"
					}
				]
			}
		]
	},
	"@reverse": {
		type: "object",
		additionalProperties: {
			type: "string"
		}
	},
	"@index": {
		type: "string"
	}
};
var additionalProperties$2 = false;
var JsonLdObjectSchema = {
	$schema: $schema$3,
	$id: $id$3,
	description: description$3,
	type: type$2,
	properties: properties$1,
	additionalProperties: additionalProperties$2
};

var $schema$2 = "https://json-schema.org/draft/2020-12/schema";
var $id$2 = "https://schema.twindev.org/json-ld/JsonLdSetObject";
var description$2 = "A set represents an unordered set of values.";
var type$1 = "object";
var properties = {
	"@set": {
		anyOf: [
			{
				$ref: "https://schema.twindev.org/json-ld/JsonLdListOrSetItem"
			},
			{
				type: "array",
				items: false,
				prefixItems: [
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdListOrSetItem"
					}
				]
			}
		]
	},
	"@index": {
		type: "string"
	}
};
var required = [
	"@set"
];
var additionalProperties$1 = false;
var JsonLdSetObjectSchema = {
	$schema: $schema$2,
	$id: $id$2,
	description: description$2,
	type: type$1,
	properties: properties,
	required: required,
	additionalProperties: additionalProperties$1
};

var $schema$1 = "https://json-schema.org/draft/2020-12/schema";
var $id$1 = "https://schema.twindev.org/json-ld/JsonLdTypeMap";
var description$1 = "A type map is used to associate an IRI with a value that allows easy programmatic access.";
var type = "object";
var additionalProperties = {
	anyOf: [
		{
			type: "string"
		},
		{
			$ref: "https://schema.twindev.org/json-ld/JsonLdNodeObject"
		}
	]
};
var JsonLdTypeMapSchema = {
	$schema: $schema$1,
	$id: $id$1,
	description: description$1,
	type: type,
	additionalProperties: additionalProperties
};

var $schema = "https://json-schema.org/draft/2020-12/schema";
var $id = "https://schema.twindev.org/json-ld/JsonLdValueObject";
var description = "A value object is used to explicitly associate a type or a language with a value to create a typed value or a language-tagged string and possibly associate a base direction.";
var anyOf = [
	{
		type: "object",
		additionalProperties: false,
		properties: {
			"@value": {
				type: [
					"null",
					"boolean",
					"number",
					"string"
				]
			},
			"@language": {
				type: "string"
			},
			"@direction": {
				type: [
					"string",
					"null"
				],
				"enum": [
					"ltr",
					"rtl",
					null
				]
			},
			"@index": {
				type: "string"
			},
			"@context": {
				$ref: "https://schema.twindev.org/json-ld/JsonLdContextDefinitionRoot"
			}
		},
		required: [
			"@value"
		]
	},
	{
		type: "object",
		additionalProperties: false,
		properties: {
			"@value": {
				type: [
					"null",
					"boolean",
					"number",
					"string"
				]
			},
			"@type": {
				type: "string"
			},
			"@index": {
				type: "string"
			},
			"@context": {
				$ref: "https://schema.twindev.org/json-ld/JsonLdContextDefinitionRoot"
			}
		},
		required: [
			"@type",
			"@value"
		]
	},
	{
		type: "object",
		additionalProperties: false,
		properties: {
			"@value": {
				anyOf: [
					{
						type: "null"
					},
					{
						type: "boolean"
					},
					{
						type: "number"
					},
					{
						type: "string"
					},
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdJsonObject"
					},
					{
						$ref: "https://schema.twindev.org/json-ld/JsonLdJsonArray"
					}
				]
			},
			"@type": {
				type: "string",
				"const": "@json"
			},
			"@index": {
				type: "string"
			},
			"@context": {
				$ref: "https://schema.twindev.org/json-ld/JsonLdContextDefinitionRoot"
			}
		},
		required: [
			"@type",
			"@value"
		]
	}
];
var JsonLdValueObjectSchema = {
	$schema: $schema,
	$id: $id,
	description: description,
	anyOf: anyOf
};

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Handle all the data types for JSON-LD.
 */
class JsonLdDataTypes {
    /**
     * Register all the data types.
     */
    static registerTypes() {
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.Document}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.Document,
            jsonSchema: async () => JsonLdDocumentSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.Object}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.Object,
            jsonSchema: async () => JsonLdObjectSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.NodeObject}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.NodeObject,
            jsonSchema: async () => JsonLdNodeObjectSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.NodePrimitive}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.NodePrimitive,
            jsonSchema: async () => JsonLdNodePrimitiveSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.GraphObject}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.GraphObject,
            jsonSchema: async () => JsonLdGraphObjectSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.ValueObject}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.ValueObject,
            jsonSchema: async () => JsonLdValueObjectSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.ListObject}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.ListObject,
            jsonSchema: async () => JsonLdListObjectSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.ListObject}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.ListObject,
            jsonSchema: async () => JsonLdListObjectSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.SetObject}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.SetObject,
            jsonSchema: async () => JsonLdSetObjectSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.LanguageMap}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.LanguageMap,
            jsonSchema: async () => JsonLdLanguageMapSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.IndexMap}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.IndexMap,
            jsonSchema: async () => JsonLdIndexMapSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.IndexMapItem}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.IndexMapItem,
            jsonSchema: async () => JsonLdIndexMapItemSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.IdMap}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.IdMap,
            jsonSchema: async () => JsonLdIdMapSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.TypeMap}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.TypeMap,
            jsonSchema: async () => JsonLdTypeMapSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.IncludedBlock}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.IncludedBlock,
            jsonSchema: async () => JsonLdIncludedBlockSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.ContextDefinition}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.ContextDefinition,
            jsonSchema: async () => JsonLdContextDefinitionSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.ContextDefinitionElement}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.ContextDefinitionElement,
            jsonSchema: async () => JsonLdContextDefinitionElementSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.ContextDefinitionRoot}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.ContextDefinitionRoot,
            jsonSchema: async () => JsonLdContextDefinitionRootSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.ExpandedTermDefinition}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.ExpandedTermDefinition,
            jsonSchema: async () => JsonLdExpandedTermDefinitionSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.ListOrSetItem}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.ListOrSetItem,
            jsonSchema: async () => JsonLdListOrSetItemSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.ContainerType}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.ContainerType,
            jsonSchema: async () => JsonLdContainerTypeSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.ContainerTypeArray}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.ContainerTypeArray,
            jsonSchema: async () => JsonLdContainerTypeArraySchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.JsonPrimitive}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.JsonPrimitive,
            jsonSchema: async () => JsonLdJsonPrimitiveSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.JsonArray}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.JsonArray,
            jsonSchema: async () => JsonLdJsonArraySchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.JsonObject}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.JsonObject,
            jsonSchema: async () => JsonLdJsonObjectSchema
        }));
        dataCore.DataTypeHandlerFactory.register(`${JsonLdContexts.ContextRoot}${JsonLdTypes.JsonValue}`, () => ({
            context: JsonLdContexts.ContextRoot,
            type: JsonLdTypes.JsonValue,
            jsonSchema: async () => JsonLdJsonValueSchema
        }));
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * JSON-LD Processor.
 */
class JsonLdProcessor {
    /**
     * The class name.
     * @internal
     */
    static _CLASS_NAME = "JsonLdProcessor";
    /**
     * The document loader to use.
     * @param documentLoader The document loader to use.
     */
    static setDocumentLoader(documentLoader) {
        core.SharedStore.set("jsonLdDocumentLoader", documentLoader);
    }
    /**
     * The document loader to use for retrieving JSON-LD documents.
     * @returns The document loader.
     */
    static getDocumentLoader() {
        let documentLoader = core.SharedStore.get("jsonLdDocumentLoader");
        if (core.Is.empty(documentLoader)) {
            documentLoader = async (url) => JsonLdProcessor.documentLoader(url);
        }
        return documentLoader;
    }
    /**
     * Set the cache time limit for documents.
     * @param cacheLimitMs The cache limit in milliseconds.
     */
    static setCacheLimit(cacheLimitMs) {
        core.SharedStore.set("jsonLdDocumentCacheLimit", cacheLimitMs);
    }
    /**
     * Get the cache limit for documents.
     * @returns The document loader.
     */
    static getCacheLimit() {
        let cacheLimitMs = core.SharedStore.get("jsonLdDocumentCacheLimit");
        if (core.Is.empty(cacheLimitMs)) {
            cacheLimitMs = 3600000;
            core.SharedStore.set("jsonLdDocumentCacheLimit", cacheLimitMs);
        }
        return cacheLimitMs;
    }
    /**
     * Set the global redirects for JSON-LD, use addRedirect for default handling.
     * @param redirects The redirects to use.
     */
    static setRedirects(redirects) {
        core.SharedStore.set("jsonLdRedirects", redirects);
    }
    /**
     * Get the global redirects for JSON-LD.
     * @returns The registered redirects.
     */
    static getRedirects() {
        let redirects = core.SharedStore.get("jsonLdRedirects");
        if (core.Is.empty(redirects)) {
            redirects = [];
            core.SharedStore.set("jsonLdRedirects", redirects);
        }
        return redirects;
    }
    /**
     * Compact a document according to a particular context.
     * @param document The JSON-LD document to compact.
     * @param context The context to compact the document to, if not provided will use the one in the document.
     * @param options The options for compacting the document.
     * @param options.itemListOverride Whether to override the itemListElement context with a set, defaults to true.
     * @returns The compacted JSON-LD document.
     */
    static async compact(document, context, options) {
        try {
            if (core.Is.object(document)) {
                // If the user didn't provide a context, use the one from the document
                if (core.Is.empty(context) && !core.Is.empty(document["@context"])) {
                    context = document["@context"];
                }
                const overrideListElementOption = options?.itemListOverride ?? true;
                let overrideContext;
                if (overrideListElementOption) {
                    // The compactArrays flag doesn't work with the current version of jsonld.js
                    // For list results we standardise on ItemList and itemListElement
                    // so we modify the schema.org type for itemListElement to be a set which bypasses the issue
                    // https://github.com/digitalbazaar/jsonld.js/issues/247
                    overrideContext = {
                        itemListElement: {
                            "@id": "http://schema.org/itemListElement",
                            "@container": "@set",
                            "@protected": true
                        }
                    };
                    if (core.Is.object(context) && "@context" in context) {
                        // If the context is an object, we need to merge it with the override context
                        context = JsonLdProcessor.combineContexts(context["@context"], overrideContext);
                    }
                    else {
                        // If the context is a string or an array, we need to merge it with the override context
                        context = JsonLdProcessor.combineContexts(context, overrideContext);
                    }
                }
                const compacted = await jsonLd.compact(core.ObjectHelper.removeEmptyProperties(document), context, {
                    documentLoader: JsonLdProcessor.getDocumentLoader()
                });
                if (!core.Is.empty(overrideContext)) {
                    // Remove the override context from the compacted document
                    compacted["@context"] = JsonLdProcessor.removeContexts(compacted["@context"], [overrideContext]);
                }
                return compacted;
            }
            return document;
        }
        catch (err) {
            JsonLdProcessor.handleCommonErrors(err);
            throw new core.GeneralError(JsonLdProcessor._CLASS_NAME, "compact", undefined, err);
        }
    }
    /**
     * Expand a document, removing its context.
     * @param compacted The compacted JSON-LD document to expand.
     * @returns The expanded JSON-LD document.
     */
    static async expand(compacted) {
        try {
            if (core.Is.object(compacted)) {
                const expanded = await jsonLd.expand(core.ObjectHelper.removeEmptyProperties(compacted), {
                    documentLoader: JsonLdProcessor.getDocumentLoader()
                });
                return expanded;
            }
            return [];
        }
        catch (err) {
            JsonLdProcessor.handleCommonErrors(err);
            throw new core.GeneralError(JsonLdProcessor._CLASS_NAME, "expand", undefined, err);
        }
    }
    /**
     * Canonize a document.
     * @param document The document to canonize.
     * @param options The options for canonization.
     * @param options.algorithm The algorithm to use for canonization, defaults to URDNA2015.
     * @returns The canonized document.
     */
    static async canonize(document, options) {
        try {
            const normalized = await jsonLd.canonize(core.ObjectHelper.removeEmptyProperties(document), {
                algorithm: options?.algorithm ?? "URDNA2015",
                format: "application/n-quads",
                documentLoader: JsonLdProcessor.getDocumentLoader()
            });
            return normalized;
        }
        catch (err) {
            JsonLdProcessor.handleCommonErrors(err);
            throw new core.GeneralError(JsonLdProcessor._CLASS_NAME, "canonize", undefined, err);
        }
    }
    /**
     * Add a redirect to use during document resolution.
     * @param from The URL to redirect from.
     * @param to The URL to redirect to.
     */
    static addRedirect(from, to) {
        const redirects = JsonLdProcessor.getRedirects();
        if (!redirects.some(r => r.from === from)) {
            redirects.push({ from, to });
        }
    }
    /**
     * Combine contexts.
     * @param context1 The first JSON-LD context to combine.
     * @param context2 The second JSON-LD context to combine.
     * @returns The combined context.
     */
    static combineContexts(context1, context2) {
        const combinedContext = [];
        if (core.Is.string(context1)) {
            if (!combinedContext.includes(context1)) {
                combinedContext.push(context1);
            }
        }
        else if (core.Is.array(context1)) {
            for (const context of context1) {
                const hasMatch = combinedContext.some(c => core.ObjectHelper.equal(c, context));
                if (!hasMatch) {
                    combinedContext.push(context);
                }
            }
        }
        else if (core.Is.object(context1)) {
            const hasMatch = combinedContext.some(c => core.ObjectHelper.equal(c, context1));
            if (!hasMatch) {
                combinedContext.push(context1);
            }
        }
        if (core.Is.string(context2)) {
            if (!combinedContext.includes(context2)) {
                combinedContext.push(context2);
            }
        }
        else if (core.Is.array(context2)) {
            for (const context of context2) {
                const hasMatch = combinedContext.some(c => core.ObjectHelper.equal(c, context));
                if (!hasMatch) {
                    combinedContext.push(context);
                }
            }
        }
        else if (core.Is.object(context2)) {
            const hasMatch = combinedContext.some(c => core.ObjectHelper.equal(c, context2));
            if (!hasMatch) {
                combinedContext.push(context2);
            }
        }
        if (combinedContext.length === 0) {
            return null;
        }
        if (combinedContext.length === 1) {
            return combinedContext[0];
        }
        return combinedContext;
    }
    /**
     * Gather all the contexts from the element and it's children.
     * @param element The element to gather the contexts from.
     * @param initial The initial context.
     * @returns The combined contexts.
     */
    static gatherContexts(element, initial) {
        let combinedContexts = initial;
        if (core.Is.object(element)) {
            if (!core.Is.empty(element["@context"])) {
                combinedContexts = JsonLdProcessor.combineContexts(initial, element["@context"]);
            }
            for (const prop of Object.keys(element)) {
                const value = element[prop];
                if (core.Is.object(value)) {
                    combinedContexts = this.gatherContexts(value, combinedContexts);
                }
                else if (core.Is.array(value)) {
                    for (const item of value) {
                        if (core.Is.object(item)) {
                            combinedContexts = this.gatherContexts(item, combinedContexts);
                        }
                    }
                }
            }
        }
        return combinedContexts;
    }
    /**
     * Remove all the contexts that match the pattern.
     * @param context The context to remove the entries from.
     * @param match The element to try and match.
     * @returns The updated contexts.
     */
    static removeContexts(context, match) {
        if (!core.Is.arrayValue(match)) {
            return context;
        }
        let finalContext;
        if (core.Is.string(context)) {
            for (const m of match) {
                if (context === m) {
                    break;
                }
            }
        }
        else if (core.Is.array(context)) {
            for (const item of context) {
                const hasMatch = match.some(m => core.ObjectHelper.equal(m, item));
                if (!hasMatch) {
                    finalContext ??= [];
                    if (core.Is.array(finalContext)) {
                        finalContext.push(item);
                    }
                }
            }
        }
        else if (core.Is.object(context)) {
            const hasMatch = match.some(m => core.ObjectHelper.equal(m, context));
            if (!hasMatch) {
                finalContext = context;
            }
        }
        return core.Is.arrayValue(finalContext) && finalContext.length === 1
            ? finalContext[0]
            : finalContext;
    }
    /**
     * Add a context directly to the document loader cache.
     * @param url The url the ld context is for.
     * @param ldContext The context to add.
     * @returns Nothing.
     */
    static async documentCacheAdd(url, ldContext) {
        await web.FetchHelper.setCacheEntry(url, ldContext);
    }
    /**
     * Remove a context from the document loader cache.
     * @param url The url the ld context is for.
     * @returns Nothing.
     */
    static async documentCacheRemove(url) {
        await web.FetchHelper.removeCacheEntry(url);
    }
    /**
     * Document loader which uses a caching mechanism.
     * @param url The document url to load.
     * @returns The document.
     * @internal
     */
    static async documentLoader(url) {
        const redirects = JsonLdProcessor.getRedirects();
        for (const redirect of redirects) {
            if (redirect.from.test(url)) {
                url = redirect.to;
                break;
            }
        }
        try {
            const response = await web.FetchHelper.fetchJson(JsonLdProcessor._CLASS_NAME, url, web.HttpMethod.GET, undefined, {
                cacheTtlMs: JsonLdProcessor.getCacheLimit(),
                headers: {
                    [web.HeaderTypes.Accept]: web.MimeTypes.JsonLd
                }
            });
            return {
                documentUrl: url,
                document: response
            };
        }
        catch (err) {
            const error = core.BaseError.fromError(err);
            if (error.message.includes("is not valid JSON")) {
                const response = await web.FetchHelper.fetchJson(JsonLdProcessor._CLASS_NAME, url, web.HttpMethod.GET, undefined, {
                    cacheTtlMs: JsonLdProcessor.getCacheLimit(),
                    headers: {
                        [web.HeaderTypes.Accept]: web.MimeTypes.Json
                    }
                });
                return {
                    documentUrl: url,
                    document: response
                };
            }
            throw err;
        }
    }
    /**
     * Handle common errors.
     * @param err The error to handle.
     * @internal
     */
    static handleCommonErrors(err) {
        if (core.Is.object(err) &&
            err.name === "jsonld.InvalidUrl") {
            throw new core.GeneralError(JsonLdProcessor._CLASS_NAME, "invalidUrl", { url: err.details?.url }, err);
        }
        else if (core.Is.object(err) &&
            err.name.startsWith("jsonld.")) {
            throw new core.GeneralError(JsonLdProcessor._CLASS_NAME, "jsonLdError", err.details, err);
        }
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to help with JSON LD.
 */
class JsonLdHelper {
    /**
     * Validate a JSON-LD document.
     * @param document The JSON-LD document to validate.
     * @param validationFailures The list of validation failures to add to.
     * @param options Optional options for validation.
     * @param options.failOnMissingType If true, will fail validation if the data type is missing, defaults to false.
     * @param options.validationMode The validation mode to use, defaults to either.
     * @returns True if the document was valid.
     */
    static async validate(document, validationFailures, options) {
        if (core.Is.array(document)) {
            // If the document is an array of nodes, validate each node
            for (const node of document) {
                await JsonLdHelper.validate(node, validationFailures, options);
            }
        }
        else if (core.Is.array(document["@graph"])) {
            // If the graph is an array of nodes, validate each node
            for (const node of document["@graph"]) {
                await JsonLdHelper.validate(node, validationFailures, options);
            }
        }
        else if (core.Is.object(document)) {
            // Expand the document to ensure we have the full context for types
            // As the data types in the factories are always fully qualified
            const expandedDocs = await JsonLdProcessor.expand(document);
            if (core.Is.arrayValue(expandedDocs)) {
                for (const expandedDoc of expandedDocs) {
                    const expandedDataTypes = core.ArrayHelper.fromObjectOrArray(expandedDoc["@type"]);
                    if (core.Is.arrayValue(expandedDataTypes)) {
                        for (const expandedDataType of expandedDataTypes) {
                            await dataCore.DataTypeHelper.validate("document", expandedDataType, document, validationFailures, options);
                        }
                    }
                }
            }
        }
        return validationFailures.length === 0;
    }
}

exports.JsonLdContexts = JsonLdContexts;
exports.JsonLdDataTypes = JsonLdDataTypes;
exports.JsonLdHelper = JsonLdHelper;
exports.JsonLdProcessor = JsonLdProcessor;
exports.JsonLdTypes = JsonLdTypes;
