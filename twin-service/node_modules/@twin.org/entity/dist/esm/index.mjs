import 'reflect-metadata';
import { Factory, Is, ObjectHelper, ArrayHelper, Guards, GeneralError } from '@twin.org/core';

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
const META_DATA_KEY = "EntitySchemaMetadata";
/**
 * Class to help with decorators.
 */
class DecoratorHelper {
    /**
     * Get the schema from the reflection metadata.
     * @param target The object to get the schema data from.
     * @returns The schema from the metadata if it can be found.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static getSchema(target) {
        return (Reflect.getMetadata(META_DATA_KEY, typeof target === "object" ? target : target.prototype) ??
            {});
    }
    /**
     * Set the schema from the reflection metadata.
     * @param target The object to get the schema data from.
     * @param entitySchema The schema to set.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static setSchema(target, entitySchema) {
        Reflect.defineMetadata(META_DATA_KEY, entitySchema, typeof target === "object" ? target : target.prototype);
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Decorator to produce schema data for entity.
 * @param options The options for the entity.
 * @returns The class decorator.
 */
function entity(options) {
    return (target) => {
        const entitySchema = DecoratorHelper.getSchema(target);
        entitySchema.type = target.name;
        entitySchema.options = options;
        DecoratorHelper.setSchema(target, entitySchema);
    };
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Decorator to produce schema property data for entities.
 * @param options The options for the property.
 * @returns The property decorator.
 */
function property(options) {
    return (target, propertyKey) => {
        const entitySchema = DecoratorHelper.getSchema(target);
        entitySchema.properties ??= [];
        const idx = entitySchema.properties.findIndex(p => p.property === propertyKey);
        if (idx !== -1) {
            entitySchema.properties[idx] = {
                ...options,
                property: propertyKey
            };
        }
        else {
            entitySchema.properties.push({
                ...options,
                property: propertyKey
            });
        }
        DecoratorHelper.setSchema(target, entitySchema);
    };
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Factory for creating entity schemas.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const EntitySchemaFactory = Factory.createFactory("entity-schema");

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * The types of comparisons.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const ComparisonOperator = {
    /**
     * Equals.
     */
    Equals: "equals",
    /**
     * Not Equals.
     */
    NotEquals: "not-equals",
    /**
     * Greater Than.
     */
    GreaterThan: "greater-than",
    /**
     * Greater Than Or Equal.
     */
    GreaterThanOrEqual: "greater-than-or-equal",
    /**
     * Less Than.
     */
    LessThan: "less-than",
    /**
     * Less Than Or Equal.
     */
    LessThanOrEqual: "less-than-or-equal",
    /**
     * Includes.
     * A string in a substring.
     * A set contains an element.
     * A list contains an element.
     */
    Includes: "includes",
    /**
     * Not Includes.
     * A string not in a substring.
     * A set does not contain an element.
     * A list does not contain an element.
     */
    NotIncludes: "not-includes",
    /**
     * In.
     * A element is in a set.
     */
    In: "in"
};

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Definition of the entity property format.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const EntitySchemaPropertyFormat = {
    /**
     * UUID.
     */
    Uuid: "uuid",
    /**
     * URI.
     */
    Uri: "uri",
    /**
     * email.
     */
    Email: "email",
    /**
     * int8.
     */
    Int8: "int8",
    /**
     * uint8.
     */
    Uint8: "uint8",
    /**
     * int16.
     */
    Int16: "int16",
    /**
     * uint16.
     */
    Uint16: "uint16",
    /**
     * int32.
     */
    Int32: "int32",
    /**
     * uint32.
     */
    Uint32: "uint32",
    /**
     * float.
     */
    Float: "float",
    /**
     * double.
     */
    Double: "double",
    /**
     * int64.
     */
    Int64: "int64",
    /**
     * uint64.
     */
    Uint64: "uint64",
    /**
     * date.
     */
    Date: "date",
    /**
     * time.
     */
    Time: "time",
    /**
     * date-time.
     */
    DateTime: "date-time",
    /**
     * JSON.
     */
    Json: "json"
};

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Definition of the entity property types.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const EntitySchemaPropertyType = {
    /**
     * String.
     */
    String: "string",
    /**
     * Number.
     */
    Number: "number",
    /**
     * Integer.
     */
    Integer: "integer",
    /**
     * Boolean.
     */
    Boolean: "boolean",
    /**
     * Array.
     */
    Array: "array",
    /**
     * Object.
     */
    Object: "object"
};

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * The logical operators for condition combining.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const LogicalOperator = {
    /**
     * Logical operator AND.
     */
    And: "and",
    /**
     * Logical operator OR.
     */
    Or: "or"
};

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * The sort directions.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const SortDirection = {
    /**
     * Ascending.
     */
    Ascending: "asc",
    /**
     * Descending.
     */
    Descending: "desc"
};

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to perform condition checks.
 */
class EntityConditions {
    /**
     * See if the entity matches the conditions.
     * @param entity The entity to test.
     * @param condition The conditions to test.
     * @returns True if the entity matches.
     */
    static check(entity, condition) {
        // If no conditions are defined then it's a match
        if (Is.undefined(condition)) {
            return true;
        }
        if ("conditions" in condition) {
            // It's a group of comparisons, so check the individual items and combine with the logical operator
            const results = condition.conditions.map(c => this.check(entity, c));
            if ((condition.logicalOperator ?? LogicalOperator.And) === LogicalOperator.And) {
                return results.every(Boolean);
            }
            return results.some(Boolean);
        }
        if (condition.property.includes(".")) {
            // It's a child property comparison, so evaluate the child property
            // and then compare it to the conditions
            const path = condition.property.split(".");
            const child = ObjectHelper.propertyGet(entity, path[0]);
            // If the child is an array then check each item
            if (Is.array(child)) {
                for (const c of child) {
                    const check = EntityConditions.check(c, {
                        ...condition,
                        property: path.slice(1).join(".")
                    });
                    if (check) {
                        return true;
                    }
                }
                return false;
            }
        }
        // It's a single value so just check the condition
        return EntityConditions.compare(entity, condition);
    }
    /**
     * See if the entity matches the conditions.
     * @param entity The entity to test.
     * @param comparator The condition to test.
     * @returns True if the entity matches.
     */
    static compare(entity, comparator) {
        const val = ObjectHelper.propertyGet(entity, comparator.property);
        const conditionValue = comparator.value;
        if (Is.undefined(conditionValue)) {
            const valUndefined = Is.undefined(val);
            if (valUndefined && comparator.comparison === ComparisonOperator.Equals) {
                return true;
            }
            else if (!valUndefined && comparator.comparison === ComparisonOperator.NotEquals) {
                return true;
            }
            return false;
        }
        else if (Is.string(val)) {
            if (Is.string(conditionValue)) {
                if (!((comparator.comparison === ComparisonOperator.Equals && val === conditionValue) ||
                    (comparator.comparison === ComparisonOperator.NotEquals && val !== conditionValue) ||
                    (comparator.comparison === ComparisonOperator.GreaterThan && val > conditionValue) ||
                    (comparator.comparison === ComparisonOperator.LessThan && val < conditionValue) ||
                    (comparator.comparison === ComparisonOperator.GreaterThanOrEqual &&
                        val >= conditionValue) ||
                    (comparator.comparison === ComparisonOperator.LessThanOrEqual &&
                        val <= conditionValue) ||
                    (comparator.comparison === ComparisonOperator.Includes &&
                        val.includes(conditionValue)) ||
                    (comparator.comparison === ComparisonOperator.NotIncludes &&
                        !val.includes(conditionValue)))) {
                    return false;
                }
                return true;
            }
            else if (Is.array(conditionValue)) {
                if (!(comparator.comparison === ComparisonOperator.In && conditionValue.includes(val))) {
                    return false;
                }
                return true;
            }
            return false;
        }
        else if (Is.number(val)) {
            if (Is.number(conditionValue)) {
                if (!((comparator.comparison === ComparisonOperator.Equals && val === conditionValue) ||
                    (comparator.comparison === ComparisonOperator.NotEquals && val !== conditionValue) ||
                    (comparator.comparison === ComparisonOperator.GreaterThan && val > conditionValue) ||
                    (comparator.comparison === ComparisonOperator.LessThan && val < conditionValue) ||
                    (comparator.comparison === ComparisonOperator.GreaterThanOrEqual &&
                        val >= conditionValue) ||
                    (comparator.comparison === ComparisonOperator.LessThanOrEqual && val <= conditionValue))) {
                    return false;
                }
                return true;
            }
            else if (Is.array(conditionValue)) {
                if (!(comparator.comparison === ComparisonOperator.In && conditionValue.includes(val))) {
                    return false;
                }
                return true;
            }
            return false;
        }
        else if (Is.boolean(val)) {
            if (Is.boolean(conditionValue)) {
                if (!((comparator.comparison === ComparisonOperator.Equals && val === conditionValue) ||
                    (comparator.comparison === ComparisonOperator.NotEquals && val !== conditionValue))) {
                    return false;
                }
                return true;
            }
            return false;
        }
        else if (Is.array(val)) {
            if (Is.array(conditionValue)) {
                if (comparator.comparison === ComparisonOperator.Equals ||
                    comparator.comparison === ComparisonOperator.NotEquals) {
                    const matches = ArrayHelper.matches(val, conditionValue);
                    if (!((comparator.comparison === ComparisonOperator.Equals && matches) ||
                        (comparator.comparison === ComparisonOperator.NotEquals && !matches))) {
                        return false;
                    }
                    return true;
                }
                return false;
            }
            else if (Is.number(conditionValue) || Is.string(conditionValue)) {
                if (comparator.comparison === ComparisonOperator.Includes ||
                    comparator.comparison === ComparisonOperator.NotIncludes ||
                    comparator.comparison === ComparisonOperator.In) {
                    const includes = val.includes(conditionValue);
                    if (!((comparator.comparison === ComparisonOperator.Includes && includes) ||
                        (comparator.comparison === ComparisonOperator.NotIncludes && !includes) ||
                        (comparator.comparison === ComparisonOperator.In && includes))) {
                        return false;
                    }
                    return true;
                }
                return false;
            }
            else if (Is.object(conditionValue)) {
                if (comparator.comparison === ComparisonOperator.Includes) {
                    for (const v of val) {
                        if (ObjectHelper.equal(v, conditionValue)) {
                            return true;
                        }
                    }
                }
                else if (comparator.comparison === ComparisonOperator.NotIncludes) {
                    for (const v of val) {
                        if (!ObjectHelper.equal(v, conditionValue)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        return false;
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to help with entity schema operations.
 */
class EntitySchemaHelper {
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "EntitySchemaHelper";
    /**
     * Get the schema for the specified object.
     * @param target The object to get the schema data for.
     * @returns The schema for the object if it can be found.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static getSchema(target) {
        return DecoratorHelper.getSchema(target);
    }
    /**
     * Get the primary key from the entity schema.
     * @param entitySchema The entity schema to find the primary key from.
     * @returns The key if only one was found.
     * @throws If no primary key was found, or more than one.
     */
    static getPrimaryKey(entitySchema) {
        Guards.object(EntitySchemaHelper._CLASS_NAME, "entitySchema", entitySchema);
        const primaryKeys = (entitySchema.properties ?? [])?.filter(p => p.isPrimary);
        if (primaryKeys.length === 0) {
            throw new GeneralError(EntitySchemaHelper._CLASS_NAME, "noIsPrimary");
        }
        if (primaryKeys.length > 1) {
            throw new GeneralError(EntitySchemaHelper._CLASS_NAME, "multipleIsPrimary");
        }
        return primaryKeys[0];
    }
    /**
     * Get the sort properties from the schema.
     * @param entitySchema The entity schema to find the primary key from.
     * @returns The sort keys from the schema or undefined if there are none.
     */
    static getSortProperties(entitySchema) {
        Guards.object(EntitySchemaHelper._CLASS_NAME, "entitySchema", entitySchema);
        const sortFields = (entitySchema.properties ?? []).filter(p => !Is.undefined(p.sortDirection));
        return sortFields.length > 0
            ? sortFields.map(p => ({
                property: p.property,
                type: p.type,
                sortDirection: p.sortDirection
            }))
            : undefined;
    }
    /**
     * Build sort properties from the schema and override if necessary.
     * @param entitySchema The entity schema to retrieve the default sort keys.
     * @param overrideSortKeys The override sort keys.
     * @returns The finalised sort keys.
     */
    static buildSortProperties(entitySchema, overrideSortKeys) {
        Guards.object(EntitySchemaHelper._CLASS_NAME, "entitySchema", entitySchema);
        let finalSortKeys;
        if (Is.arrayValue(overrideSortKeys)) {
            finalSortKeys = [];
            for (const sortKey of overrideSortKeys) {
                const property = (entitySchema.properties ?? []).find(p => p.property === sortKey.property);
                if (property) {
                    finalSortKeys.push({
                        property: sortKey.property,
                        sortDirection: sortKey.sortDirection,
                        type: property.type
                    });
                }
            }
        }
        else {
            finalSortKeys = EntitySchemaHelper.getSortProperties(entitySchema);
        }
        return finalSortKeys;
    }
    /**
     * Validate the entity against the schema.
     * @param entity The entity to validate.
     * @param entitySchema The schema to validate against.
     * @throws If the entity is invalid.
     */
    static validateEntity(entity, entitySchema) {
        Guards.object(EntitySchemaHelper._CLASS_NAME, "entity", entity);
        Guards.object(EntitySchemaHelper._CLASS_NAME, "entitySchema", entitySchema);
        const properties = entitySchema.properties ?? [];
        if (properties.length === 0 && Is.objectValue(entity)) {
            throw new GeneralError(EntitySchemaHelper._CLASS_NAME, "invalidEntityProperties");
        }
        const allKeys = Object.keys(entity);
        for (const prop of properties) {
            const idx = allKeys.indexOf(prop.property);
            if (idx !== -1) {
                allKeys.splice(idx, 1);
            }
            const value = entity[prop.property];
            if (Is.empty(value)) {
                // If the value is empty but the property is not optional, then it's invalid
                if (!prop.optional) {
                    throw new GeneralError(EntitySchemaHelper._CLASS_NAME, "invalidOptional", {
                        property: prop.property,
                        type: prop.type
                    });
                }
            }
            else if (prop.type === "integer" && Is.integer(value)) ;
            else if (prop.type === "object" &&
                (Is.object(value) ||
                    Is.array(value) ||
                    Is.string(value) ||
                    Is.number(value) ||
                    Is.boolean(value) ||
                    Is.null(value))) ;
            else if (prop.type === "array" && Is.array(value)) ;
            else if (prop.type !== typeof value) {
                // The schema type does not match the value type
                throw new GeneralError(EntitySchemaHelper._CLASS_NAME, "invalidEntityProperty", {
                    value,
                    property: prop.property,
                    type: prop.type
                });
            }
        }
        if (allKeys.length > 0) {
            // There are keys in the entity that are not in the schema
            throw new GeneralError(EntitySchemaHelper._CLASS_NAME, "invalidEntityKeys", {
                keys: allKeys.join(", ")
            });
        }
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to perform sort operations on entities.
 */
class EntitySorter {
    /**
     * Sort a list of entities using multiple keys and direction.
     * @param entities The list of entities.
     * @param entitySorters The sort keys to use.
     * @returns The sorted list.
     */
    static sort(entities, entitySorters) {
        if (!Is.arrayValue(entities) || Is.empty(entitySorters)) {
            return entities;
        }
        return entities.sort((a, b) => {
            for (const entitySorter of entitySorters) {
                const compareResult = EntitySorter.compare(a, b, entitySorter.property, entitySorter.type, entitySorter.sortDirection);
                if (compareResult !== 0) {
                    return compareResult;
                }
            }
            return 0;
        });
    }
    /**
     * Compare two properties.
     * @param entity1 The first entity.
     * @param entity2 The second entity.
     * @param prop The property to compare.
     * @param type The type of the property.
     * @param direction The direction of the sort.
     * @returns The result of the comparison.
     */
    static compare(entity1, entity2, prop, type, direction = SortDirection.Ascending) {
        let res = 0;
        const hasProp1 = !Is.empty(entity1[prop]);
        const hasProp2 = !Is.empty(entity2[prop]);
        if (hasProp1 && hasProp2) {
            if (type === "number" || type === "integer") {
                res = entity1[prop] - entity2[prop];
            }
            else if (type === "boolean") {
                const b1 = entity1[prop];
                const b2 = entity2[prop];
                if (b1 === b2) {
                    res = 0;
                }
                else if (b1) {
                    res = -1;
                }
                else {
                    res = 1;
                }
            }
            else if (type === "string") {
                res = entity1[prop].localeCompare(entity2[prop]);
            }
        }
        else if (hasProp1) {
            res = -1;
        }
        else {
            res = 1;
        }
        return direction === SortDirection.Ascending ? res : res * -1;
    }
}

export { ComparisonOperator, DecoratorHelper, EntityConditions, EntitySchemaFactory, EntitySchemaHelper, EntitySchemaPropertyFormat, EntitySchemaPropertyType, EntitySorter, LogicalOperator, SortDirection, entity, property };
