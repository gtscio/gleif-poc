import { createPatch, applyPatch } from 'rfc6902';
import { IntlMessageFormat } from 'intl-messageformat';

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Helper methods for hex conversions.
 */
class HexHelper {
    /**
     * Strip the 0x prefix if it exists.
     * @param hex The hex value to strip.
     * @returns The stripped hex without the prefix.
     */
    static stripPrefix(hex) {
        return hex.replace(/^0x/, "");
    }
    /**
     * Add the 0x prefix if it does not exist.
     * @param hex The hex value to add the prefix to.
     * @returns The hex with the prefix.
     */
    static addPrefix(hex) {
        return HexHelper.hasPrefix(hex) ? hex : `0x${hex}`;
    }
    /**
     * Does the hex string have the prefix.
     * @param hex The hex value to check for the prefix.
     * @returns True if the hex string has the prefix.
     */
    static hasPrefix(hex) {
        return hex.startsWith("0x");
    }
    /**
     * Is the data hex format.
     * @param value The value to test.
     * @param allowPrefix Allow the hex to have the 0x prefix.
     * @returns True if the string is hex.
     */
    static isHex(value, allowPrefix = false) {
        const localHex = allowPrefix ? HexHelper.stripPrefix(value) : value;
        if (localHex.length % 2 === 1) {
            return false;
        }
        return /^[\da-f]+$/g.test(localHex);
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to check types of objects.
 */
class Is {
    /**
     * Is the property undefined.
     * @param value The value to test.
     * @returns True if the value is a empty.
     */
    static undefined(value) {
        return value === undefined;
    }
    /**
     * Is the property null.
     * @param value The value to test.
     * @returns True if the value is a empty.
     */
    static null(value) {
        return value === null;
    }
    /**
     * Is the property null or undefined.
     * @param value The value to test.
     * @returns True if the value is a empty.
     */
    static empty(value) {
        return value === null || value === undefined;
    }
    /**
     * Is the property is not null or undefined.
     * @param value The value to test.
     * @returns True if the value is a not empty.
     */
    static notEmpty(value) {
        return value !== null && value !== undefined;
    }
    /**
     * Is the value a string.
     * @param value The value to test.
     * @returns True if the value is a string.
     */
    static string(value) {
        return typeof value === "string";
    }
    /**
     * Is the value a string.
     * @param value The value to test.
     * @returns True if the value is a string.
     */
    static stringValue(value) {
        return Is.string(value) && value.trim().length > 0;
    }
    /**
     * Is the value a JSON string.
     * @param value The value to test.
     * @returns True if the value is a JSON string.
     */
    static json(value) {
        if (!Is.stringValue(value)) {
            return false;
        }
        try {
            const json = JSON.parse(value);
            return (Is.object(json) ||
                Is.array(json) ||
                Is.string(json) ||
                Is.number(json) ||
                Is.boolean(json) ||
                Is.null(json));
        }
        catch {
            return false;
        }
    }
    /**
     * Is the value a base64 string.
     * @param value The value to test.
     * @returns True if the value is a base64 string.
     */
    static stringBase64(value) {
        return (Is.stringValue(value) &&
            // eslint-disable-next-line unicorn/better-regex
            /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(value));
    }
    /**
     * Is the value a base64 url string.
     * @param value The value to test.
     * @returns True if the value is a base64 string.
     */
    static stringBase64Url(value) {
        return (Is.stringValue(value) &&
            // eslint-disable-next-line unicorn/better-regex
            /^([A-Za-z0-9-_])*$/.test(value));
    }
    /**
     * Is the value a base58 string.
     * @param value The value to test.
     * @returns True if the value is a base58 string.
     */
    static stringBase58(value) {
        return (Is.stringValue(value) &&
            // eslint-disable-next-line unicorn/better-regex
            /^[A-HJ-NP-Za-km-z1-9]*$/.test(value));
    }
    /**
     * Is the value a hex string.
     * @param value The value to test.
     * @param allowPrefix Allow the hex to have the 0x prefix.
     * @returns True if the value is a hex string.
     */
    static stringHex(value, allowPrefix = false) {
        return Is.string(value) && HexHelper.isHex(value, allowPrefix);
    }
    /**
     * Is the value a hex string of fixed length.
     * @param value The value to test.
     * @param length The length to test.
     * @param allowPrefix Allow the hex to have the 0x prefix.
     * @returns True if the value is a hex string of required length.
     */
    static stringHexLength(value, length, allowPrefix = false) {
        return Is.stringHex(value, allowPrefix) && value.length === length;
    }
    /**
     * Is the value a number.
     * @param value The value to test.
     * @returns True if the value is a number.
     */
    static number(value) {
        return typeof value === "number" && Number.isFinite(value) && !Number.isNaN(value);
    }
    /**
     * Is the value an integer.
     * @param value The value to test.
     * @returns True if the value is an integer.
     */
    static integer(value) {
        return Is.number(value) && Number.isInteger(value);
    }
    /**
     * Is the value a big integer.
     * @param value The value to test.
     * @returns True if the value is a big integer.
     */
    static bigint(value) {
        return typeof value === "bigint";
    }
    /**
     * Is the value a boolean.
     * @param value The value to test.
     * @returns True if the value is a boolean.
     */
    static boolean(value) {
        return typeof value === "boolean";
    }
    /**
     * Is the value a date.
     * @param value The value to test.
     * @returns True if the value is a date.
     */
    static date(value) {
        return (Object.prototype.toString.call(value) === "[object Date]" &&
            !Number.isNaN(value.getTime()));
    }
    /**
     * Is the value an empty date.
     * @param value The value to test.
     * @returns True if the value is an empty date.
     */
    static dateEmpty(value) {
        return (Object.prototype.toString.call(value) === "[object Date]" &&
            Number.isNaN(value.getTime()));
    }
    /**
     * Is the value a date string.
     * @param value The value to test.
     * @returns True if the value is a string in ISO 8601 date format.
     */
    static dateString(value) {
        if (typeof value !== "string" || value.length === 0 || value.includes("T")) {
            return false;
        }
        return !Number.isNaN(Date.parse(value));
    }
    /**
     * Is the value a date string.
     * @param value The value to test.
     * @returns True if the value is a string in ISO 8601 date/time format.
     */
    static dateTimeString(value) {
        if (typeof value !== "string" || value.length === 0 || !value.includes("T")) {
            return false;
        }
        return !Number.isNaN(Date.parse(value));
    }
    /**
     * Is the value a time string.
     * @param value The value to test.
     * @returns True if the value is a string in ISO 8601 time format.
     */
    static timeString(value) {
        if (typeof value !== "string" || value.length === 0 || value.includes("T")) {
            return false;
        }
        return !Number.isNaN(Date.parse(`1970-01-01T${value}`));
    }
    /**
     * Is the value a timestamp in seconds.
     * @param value The value to test.
     * @returns True if the value is a date.
     */
    static timestampSeconds(value) {
        if (!Is.integer(value)) {
            return false;
        }
        return value.toString().length < 12;
    }
    /**
     * Is the value a timestamp in milliseconds.
     * @param value The value to test.
     * @returns True if the value is a date.
     */
    static timestampMilliseconds(value) {
        if (!Is.integer(value)) {
            return false;
        }
        return value.toString().length >= 12;
    }
    /**
     * Is the value an object.
     * @param value The value to test.
     * @returns True if the value is a object.
     */
    static object(value) {
        return typeof value === "object" && value !== null && !Array.isArray(value);
    }
    /**
     * Is the value an object with at least one property.
     * @param value The value to test.
     * @returns True if the value is a object.
     */
    static objectValue(value) {
        return (typeof value === "object" &&
            value !== null &&
            !Array.isArray(value) &&
            Object.keys(value).length > 0);
    }
    /**
     * Is the value an array.
     * @param value The value to test.
     * @returns True if the value is an array.
     */
    static array(value) {
        return Array.isArray(value);
    }
    /**
     * Is the value an array with at least one element.
     * @param value The value to test.
     * @returns True if the value is an array with at least one element.
     */
    static arrayValue(value) {
        return Array.isArray(value) && value.length > 0;
    }
    /**
     * Is the value an array with at least one element.
     * @param value The value to test.
     * @param options The options the value must be one of.
     * @returns True if the value is an element from the options array.
     */
    static arrayOneOf(value, options) {
        if (Is.empty(value) || !Is.array(options) || !options.includes(value)) {
            return false;
        }
        return true;
    }
    /**
     * Is the value a Uint8Array.
     * @param value The value to test.
     * @returns True if the value is a Uint8Array.
     */
    static uint8Array(value) {
        return value instanceof Uint8Array;
    }
    /**
     * Is the value a TypedArray.
     * @param value The value to test.
     * @returns True if the value is a TypedArray.
     */
    static typedArray(value) {
        return value instanceof Object.getPrototypeOf(Uint8Array);
    }
    /**
     * Is the property a function.
     * @param value The value to test.
     * @returns True if the value is a function.
     */
    static function(value) {
        return typeof value === "function";
    }
    /**
     * Is the value a string formatted as an email address.
     * @param value The value to test.
     * @returns True if the value is a string.
     */
    static email(value) {
        return (Is.stringValue(value) &&
            /^[\w!#$%&'*+./=?^`{|}~-]+@[\dA-Za-z](?:[\dA-Za-z-]{0,61}[\dA-Za-z])?(?:\.[\dA-Za-z](?:[\dA-Za-z-]{0,61}[\dA-Za-z])?)*$/.test(value));
    }
    /**
     * Is the value a promise.
     * @param value The value to test.
     * @returns True if the value is a promise.
     */
    static promise(value) {
        return value instanceof Promise;
    }
    /**
     * Is the value a regexp.
     * @param value The value to test.
     * @returns True if the value is a regexp.
     */
    static regexp(value) {
        return value instanceof RegExp;
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/* eslint-disable no-continue */
/* eslint-disable no-bitwise */
/**
 * Class to help with string.
 */
class StringHelper {
    /**
     * Trim trailing slashes from a string.
     * @param value The value to trim.
     * @returns The trimmed value.
     */
    static trimTrailingSlashes(value) {
        if (Is.stringValue(value)) {
            return value.replace(/\/+$/, "");
        }
        return "";
    }
    /**
     * Trim leading slashes from a string.
     * @param value The value to trim.
     * @returns The trimmed value.
     */
    static trimLeadingSlashes(value) {
        if (Is.stringValue(value)) {
            return value.replace(/^\/+/, "");
        }
        return "";
    }
    /**
     * Convert the input string to kebab case.
     * @param input The input to convert.
     * @param stripInterfacePrefix Strip interface prefixes.
     * @returns The kebab case version of the input.
     */
    static kebabCase(input, stripInterfacePrefix = true) {
        if (Is.stringValue(input)) {
            let output = input;
            if (stripInterfacePrefix && /I[A-Z]/.test(output)) {
                output = output.slice(1);
            }
            return StringHelper.words(output).join("-").toLowerCase();
        }
        return "";
    }
    /**
     * Convert the input string to snake case.
     * @param input The input to convert.
     * @param stripInterfacePrefix Strip interface prefixes.
     * @returns The snake case version of the input.
     */
    static snakeCase(input, stripInterfacePrefix = true) {
        if (Is.stringValue(input)) {
            let output = input;
            if (stripInterfacePrefix && /I[A-Z]/.test(output)) {
                output = output.slice(1);
            }
            return StringHelper.words(output).join("_").toLowerCase();
        }
        return "";
    }
    /**
     * Title case all the words.
     * @param input The input to convert.
     * @param stripInterfacePrefix Strip interface prefixes.
     * @returns The title case version of the input.
     */
    static titleCase(input, stripInterfacePrefix = true) {
        if (Is.stringValue(input)) {
            let output = input;
            if (stripInterfacePrefix && /I[A-Z]/.test(output)) {
                output = output.slice(1);
            }
            return StringHelper.words(output)
                .map(w => `${w[0].toUpperCase()}${w.slice(1).toLowerCase()}`)
                .join(" ");
        }
        return "";
    }
    /**
     * Pascal case all the words.
     * @param input The input to convert.
     * @param stripInterfacePrefix Strip interface prefixes.
     * @returns The pascal case version of the input.
     */
    static pascalCase(input, stripInterfacePrefix = true) {
        if (Is.stringValue(input)) {
            let output = input;
            if (stripInterfacePrefix && /I[A-Z]/.test(output)) {
                output = output.slice(1);
            }
            return StringHelper.words(output)
                .map(w => `${w[0].toUpperCase()}${w.slice(1).toLowerCase()}`)
                .join("");
        }
        return "";
    }
    /**
     * Camel case all the words.
     * @param input The input to convert.
     * @param stripInterfacePrefix Strip interface prefixes.
     * @returns The camel case version of the input.
     */
    static camelCase(input, stripInterfacePrefix = true) {
        if (Is.stringValue(input)) {
            let output = input;
            if (stripInterfacePrefix && /I[A-Z]/.test(output)) {
                output = output.slice(1);
            }
            const words = StringHelper.words(output);
            return words.length === 0
                ? ""
                : `${words[0].toLowerCase()}${words
                    .slice(1)
                    .map(w => `${w[0].toUpperCase()}${w.slice(1).toLowerCase()}`)
                    .join("")}`;
        }
        return "";
    }
    /**
     * Convert the words to a path.
     * @param input The input to convert.
     * @param stripInterfacePrefix Strip interface prefixes.
     * @returns The path version of the input.
     */
    static wordPath(input, stripInterfacePrefix = true) {
        if (Is.stringValue(input)) {
            let output = input;
            if (stripInterfacePrefix && /I[A-Z]/.test(output)) {
                output = output.slice(1);
            }
            const words = StringHelper.words(output);
            return words.join("/").toLowerCase();
        }
        return "";
    }
    /**
     * Strip interface prefix if there is one.
     * @param input The input to strip.
     * @returns The input with any interface prefix stripped.
     */
    static stripPrefix(input) {
        if (Is.stringValue(input)) {
            let output = input;
            if (/I[A-Z]/.test(output)) {
                output = output.slice(1);
            }
            return output;
        }
        return "";
    }
    /**
     * Split a string into words.
     * @param input The input to split.
     * @returns The string split into words.
     */
    static words(input) {
        if (!Is.stringValue(input)) {
            return [];
        }
        return (input
            .replace(/([A-Z])/g, " $1")
            .trim()
            .match(/[^\u0000-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007F]+/g) ?? []);
    }
    /**
     * Check if a Node.js Buffer or Uint8Array is UTF-8.
     * Url https://tools.ietf.org/html/rfc3629
     * Source https://github.com/hcodes/isutf8
     * UTF8-char = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4.
     * UTF8-1    = %x00-7F.
     * UTF8-2    = %xC2-DF UTF8-tail.
     * UTF8-3    = %xE0 %xA0-BF UTF8-tail.
     * -           %xE1-EC 2( UTF8-tail ).
     * -           %xED %x80-9F UTF8-tail.
     * -           %xEE-EF 2( UTF8-tail ).
     * UTF8-4    = %xF0 %x90-BF 2( UTF8-tail ).
     * -           %xF1-F3 3( UTF8-tail ).
     * -           %xF4 %x80-8F 2( UTF8-tail ).
     * UTF8-tail = %x80-BF.
     * @param data The data to check.
     * @returns True if the data is utf8.
     */
    static isUtf8(data) {
        if (!Is.uint8Array(data)) {
            return false;
        }
        let i = 0;
        const len = data.length;
        while (i < len) {
            // UTF8-1 = %x00-7F
            if (data[i] <= 0x7f) {
                i++;
                continue;
            }
            // UTF8-2 = %xC2-DF UTF8-tail
            if (data[i] >= 0xc2 && data[i] <= 0xdf) {
                // if(buf[i + 1] >= 0x80 && buf[i + 1] <= 0xBF) {
                if (data[i + 1] >> 6 === 2) {
                    i += 2;
                    continue;
                }
                else {
                    return false;
                }
            }
            // UTF8-3 = %xE0 %xA0-BF UTF8-tail
            // UTF8-3 = %xED %x80-9F UTF8-tail
            if (((data[i] === 0xe0 && data[i + 1] >= 0xa0 && data[i + 1] <= 0xbf) ||
                (data[i] === 0xed && data[i + 1] >= 0x80 && data[i + 1] <= 0x9f)) &&
                data[i + 2] >> 6 === 2) {
                i += 3;
                continue;
            }
            // UTF8-3 = %xE1-EC 2( UTF8-tail )
            // UTF8-3 = %xEE-EF 2( UTF8-tail )
            if (((data[i] >= 0xe1 && data[i] <= 0xec) || (data[i] >= 0xee && data[i] <= 0xef)) &&
                data[i + 1] >> 6 === 2 &&
                data[i + 2] >> 6 === 2) {
                i += 3;
                continue;
            }
            // UTF8-4 = %xF0 %x90-BF 2( UTF8-tail )
            //          %xF1-F3 3( UTF8-tail )
            //          %xF4 %x80-8F 2( UTF8-tail )
            if (((data[i] === 0xf0 && data[i + 1] >= 0x90 && data[i + 1] <= 0xbf) ||
                (data[i] >= 0xf1 && data[i] <= 0xf3 && data[i + 1] >> 6 === 2) ||
                (data[i] === 0xf4 && data[i + 1] >= 0x80 && data[i + 1] <= 0x8f)) &&
                data[i + 2] >> 6 === 2 &&
                data[i + 3] >> 6 === 2) {
                i += 4;
                continue;
            }
            return false;
        }
        return true;
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to handle errors.
 */
class BaseError extends Error {
    /**
     * The source of the error.
     */
    source;
    /**
     * Any additional information for the error.
     */
    properties;
    /**
     * The inner error if there was one.
     */
    inner;
    /**
     * Create a new instance of BaseError.
     * @param name The name of the error.
     * @param source The source of the error.
     * @param message The message as a code.
     * @param properties Any additional information for the error.
     * @param inner The inner error if we have wrapped another error.
     */
    constructor(name, source, message, properties, inner) {
        super(message);
        this.name = name;
        this.source = source;
        // If the message is camel case but has no namespace then prefix it
        // with the source name in camel case
        if (Is.stringValue(source) &&
            Is.stringValue(message) &&
            !message.includes(".") &&
            StringHelper.camelCase(message) === message) {
            this.message = `${StringHelper.camelCase(source)}.${message}`;
        }
        this.properties = properties;
        this.inner = inner ? BaseError.fromError(inner).toJsonObject() : undefined;
    }
    /**
     * Construct an error from an existing one.
     * @param err The existing error.
     * @returns The new instance.
     */
    static fromError(err) {
        let name = "Base";
        let message;
        let source;
        let properties;
        let inner;
        let stack;
        if (Is.object(err) && Is.stringValue(err.error)) {
            message = err.error;
        }
        else if (Is.object(err)) {
            if (Is.stringValue(err.name)) {
                name = err.name;
            }
            if (Is.stringValue(err.source)) {
                source = err.source;
            }
            if (Is.stringValue(err.message)) {
                message = err.message;
            }
            if (Is.notEmpty(err.properties)) {
                properties = err.properties;
            }
            if (Is.notEmpty(err.inner)) {
                inner = err.inner;
            }
            if (Is.notEmpty(err.stack)) {
                stack = err.stack;
            }
        }
        else if (Is.stringValue(err)) {
            message = err;
        }
        else {
            message = JSON.stringify(err);
        }
        const baseError = new BaseError(name, source ?? "", message ?? "", properties, inner);
        baseError.stack = stack;
        return baseError;
    }
    /**
     * Flatten an error tree.
     * @param err The starting error.
     * @returns The list of all internal errors.
     */
    static flatten(err) {
        const flattened = [];
        let e = BaseError.fromError(err).toJsonObject(true);
        while (e) {
            const inner = e.inner;
            e.inner = undefined;
            flattened.push(e);
            e = inner;
        }
        return flattened;
    }
    /**
     * Expand an error tree.
     * @param errors The list of errors to expand.
     * @returns The first level error.
     */
    static expand(errors) {
        let first;
        if (Is.arrayValue(errors)) {
            first = errors[0];
            let current = first;
            for (let i = 1; i < errors.length; i++) {
                current.inner = errors[i];
                current = current.inner;
            }
        }
        return first;
    }
    /**
     * Test to see if the error has the specified error name.
     * @param error The error to test.
     * @param name The name to check for.
     * @returns True if the error has the name.
     */
    static isErrorName(error, name) {
        return (Is.object(error) &&
            (Is.string(name) ? error.name === name : name.test(error.name)));
    }
    /**
     * Test to see if the error has the specified error message.
     * @param error The error to test.
     * @param message The message to check for.
     * @returns True if the error has the name.
     */
    static isErrorMessage(error, message) {
        return (Is.object(error) &&
            (Is.string(message) ? error.message === message : message.test(error.message)));
    }
    /**
     * Test to see if the error has the specified error code.
     * @param error The error to test.
     * @param code The code to check for.
     * @returns True if the error has the code.
     */
    static isErrorCode(error, code) {
        return (Is.object(error) &&
            (Is.string(code) ? error.code === code : code.test(error.code)));
    }
    /**
     * Test to see if any of the errors or children have the given error name.
     * @param error The error to test.
     * @param name The name to check for.
     * @returns True if the error has the name.
     */
    static someErrorName(error, name) {
        return BaseError.flatten(error).some(e => BaseError.isErrorName(e, name));
    }
    /**
     * Test to see if any of the errors or children have the given error message.
     * @param error The error to test.
     * @param message The message to check for.
     * @returns True if the error has the name.
     */
    static someErrorMessage(error, message) {
        return BaseError.flatten(error).some(e => BaseError.isErrorMessage(e, message));
    }
    /**
     * Test to see if any of the errors or children are from a specific class.
     * @param error The error to test.
     * @param cls The class to check for.
     * @returns True if the error has the specific class.
     */
    static someErrorClass(error, cls) {
        const errorClass = StringHelper.camelCase(cls);
        const regExp = new RegExp(`^${errorClass}\\.`);
        return BaseError.flatten(error).some(e => BaseError.isErrorMessage(e, regExp));
    }
    /**
     * Test to see if any of the errors or children have the given error code.
     * @param error The error to test.
     * @param code The code to check for.
     * @returns True if the error has the name.
     */
    static someErrorCode(error, code) {
        return BaseError.flatten(error).some(e => BaseError.isErrorCode(e, code));
    }
    /**
     * Serialize the error to the error model.
     * @param includeStackTrace Whether to include the error stack in the model, defaults to false.
     * @returns The error model.
     */
    toJsonObject(includeStackTrace) {
        const err = {};
        if (Is.stringValue(this.name)) {
            err.name = this.name;
        }
        if (Is.stringValue(this.source)) {
            err.source = this.source;
        }
        if (Is.stringValue(this.message)) {
            err.message = this.message;
        }
        if (Is.object(this.properties)) {
            err.properties = this.properties;
        }
        if ((includeStackTrace ?? false) && Is.stringValue(this.stack)) {
            err.stack = this.stack;
        }
        if (Is.notEmpty(this.inner)) {
            err.inner = BaseError.fromError(this.inner).toJsonObject(includeStackTrace);
        }
        return err;
    }
}

/**
 * Class to handle errors.
 */
class GeneralError extends BaseError {
    /**
     * Runtime name for the class.
     */
    static CLASS_NAME = "GeneralError";
    /**
     * Create a new instance of GeneralError.
     * @param source The source of the error.
     * @param message The message as a code.
     * @param properties Any additional information for the error.
     * @param inner The inner error if we have wrapped another error.
     */
    constructor(source, message, properties, inner) {
        super(GeneralError.CLASS_NAME, source, message, properties, inner);
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/* eslint-disable no-bitwise */
/**
 * Class to help with base63 Encoding/Decoding.
 */
class Base32 {
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "Base32";
    /**
     * Alphabet table for encoding.
     * @internal
     */
    static _ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
    /**
     * Convert the base 32 string to a byte array.
     * @param base32 The base32 string to convert.
     * @returns The byte array.
     * @throws If the input string contains a character not in the Base32 alphabet.
     */
    static decode(base32) {
        let bits = 0;
        let value = 0;
        base32 = base32.replace(/=+$/, "");
        let index = 0;
        const output = new Uint8Array(Math.trunc((base32.length * 5) / 8));
        for (let i = 0; i < base32.length; i++) {
            const idx = Base32._ALPHABET.indexOf(base32[i]);
            if (idx === -1) {
                throw new GeneralError(Base32._CLASS_NAME, "invalidCharacter", {
                    invalidCharacter: base32[i]
                });
            }
            value = (value << 5) | idx;
            bits += 5;
            if (bits >= 8) {
                output[index++] = (value >>> (bits - 8)) & 255;
                bits -= 8;
            }
        }
        return output;
    }
    /**
     * Convert a byte array to base 32.
     * @param bytes The byte array to convert.
     * @returns The data as base32 string.
     */
    static encode(bytes) {
        let bits = 0;
        let value = 0;
        let output = "";
        for (let i = 0; i < bytes.byteLength; i++) {
            value = (value << 8) | bytes[i];
            bits += 8;
            while (bits >= 5) {
                output += Base32._ALPHABET[(value >>> (bits - 5)) & 31];
                bits -= 5;
            }
        }
        if (bits > 0) {
            output += Base32._ALPHABET[(value << (5 - bits)) & 31];
        }
        while (output.length % 8 !== 0) {
            output += "=";
        }
        return output;
    }
}

/**
 * Class to help with base58 Encoding/Decoding.
 */
class Base58 {
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "Base58";
    /**
     * Alphabet table for encoding.
     * @internal
     */
    static _ALPHABET = 
    // cspell:disable-next-line
    "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    /**
     * Reverse map for decoding.
     * @internal
     */
    static _ALPHABET_REVERSE = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, -1, -1, -1, -1, -1, -1, -1, 9, 10, 11, 12, 13, 14, 15, 16, -1,
        17, 18, 19, 20, 21, -1, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, -1, -1, -1, -1, -1, -1, 33,
        34, 35, 36, 37, 38, 39, 40, 41, 42, 43, -1, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
        57, -1, -1, -1, -1, -1
    ];
    /**
     * Convert the base 58 string to a byte array.
     * @param base58 The base58 string to convert.
     * @returns The byte array.
     * @throws If the input string contains a character not in the Base58 alphabet.
     */
    static decode(base58) {
        let zeroes = 0;
        for (let i = 0; i < base58.length; i++) {
            if (base58[i] !== "1") {
                break;
            }
            zeroes += 1;
        }
        const size = Math.trunc((base58.length * 733) / 1000) + 1;
        const b256 = new Uint8Array(size).fill(0);
        let length = 0;
        for (let i = zeroes; i < base58.length; i++) {
            const ch = base58.charCodeAt(i);
            if (ch & 0xff80) {
                throw new GeneralError(Base58._CLASS_NAME, "invalidCharacter", { invalidCharacter: ch });
            }
            const val = Base58._ALPHABET_REVERSE[ch];
            if (val === -1) {
                throw new GeneralError(Base58._CLASS_NAME, "invalidCharacter", { invalidCharacter: ch });
            }
            let carry = val;
            let j = 0;
            for (let k = size - 1; k >= 0; k--, j++) {
                if (carry === 0 && j >= length) {
                    break;
                }
                carry += b256[k] * 58;
                b256[k] = carry;
                carry >>>= 8;
            }
            length = j;
        }
        const out = new Uint8Array(zeroes + length);
        let j;
        for (j = 0; j < zeroes; j++) {
            out[j] = 0;
        }
        let i = size - length;
        while (i < size) {
            out[j++] = b256[i++];
        }
        return out;
    }
    /**
     * Convert a byte array to base 58.
     * @param bytes The byte array to encode.
     * @returns The data as base58 string.
     */
    static encode(bytes) {
        let zeroes = 0;
        for (let i = 0; i < bytes.length; i++) {
            if (bytes[i] !== 0) {
                break;
            }
            zeroes += 1;
        }
        const size = Math.trunc(((bytes.length - zeroes) * 138) / 100) + 1;
        const b58 = new Uint8Array(size).fill(0);
        let length = 0;
        for (let i = zeroes; i < bytes.length; i++) {
            let carry = bytes[i];
            let j = 0;
            for (let k = size - 1; k >= 0; k--, j++) {
                if (carry === 0 && j >= length) {
                    break;
                }
                carry += b58[k] * 256;
                b58[k] = carry % 58;
                carry = Math.trunc(carry / 58);
            }
            length = j;
        }
        let i = size - length;
        while (i < size && b58[i] === 0) {
            i += 1;
        }
        let str = "";
        for (let j = 0; j < zeroes; j++) {
            str += "1";
        }
        while (i < size) {
            str += Base58._ALPHABET[b58[i++]];
        }
        return str;
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/* eslint-disable no-bitwise */
/* eslint-disable no-mixed-operators */
/**
 * Class to help with base64 Encoding/Decoding.
 * Sourced from https://github.com/beatgammit/base64-js.
 */
class Base64 {
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "Base64";
    /**
     * Alphabet table for encoding.
     * @internal
     */
    static _LOOKUP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    /**
     * Alphabet table for decoding.
     * @internal
     */
    static _REVERSE_LOOKUP = {
        "43": 62,
        "45": 62,
        "47": 63,
        "48": 52,
        "49": 53,
        "50": 54,
        "51": 55,
        "52": 56,
        "53": 57,
        "54": 58,
        "55": 59,
        "56": 60,
        "57": 61,
        "65": 0,
        "66": 1,
        "67": 2,
        "68": 3,
        "69": 4,
        "70": 5,
        "71": 6,
        "72": 7,
        "73": 8,
        "74": 9,
        "75": 10,
        "76": 11,
        "77": 12,
        "78": 13,
        "79": 14,
        "80": 15,
        "81": 16,
        "82": 17,
        "83": 18,
        "84": 19,
        "85": 20,
        "86": 21,
        "87": 22,
        "88": 23,
        "89": 24,
        "90": 25,
        "95": 63,
        "97": 26,
        "98": 27,
        "99": 28,
        "100": 29,
        "101": 30,
        "102": 31,
        "103": 32,
        "104": 33,
        "105": 34,
        "106": 35,
        "107": 36,
        "108": 37,
        "109": 38,
        "110": 39,
        "111": 40,
        "112": 41,
        "113": 42,
        "114": 43,
        "115": 44,
        "116": 45,
        "117": 46,
        "118": 47,
        "119": 48,
        "120": 49,
        "121": 50,
        "122": 51
    };
    /**
     * Get the byte length of the data.
     * @param base64 The base64 string.
     * @returns The byte length of the data.
     */
    static byteLength(base64) {
        const lens = Base64.getLengths(base64);
        return Base64.calcByteLength(lens[0], lens[1]);
    }
    /**
     * Convert the base 64 string to a byte array.
     * @param base64 The base64 string to convert.
     * @returns The byte array.
     */
    static decode(base64) {
        let tmp;
        const lens = Base64.getLengths(base64);
        const validLen = lens[0];
        const placeHoldersLen = lens[1];
        const arr = new Uint8Array(Base64.calcByteLength(validLen, placeHoldersLen));
        let curByte = 0;
        // if there are placeholders, only get up to the last complete 4 chars
        const len = placeHoldersLen > 0 ? validLen - 4 : validLen;
        let i;
        for (i = 0; i < len; i += 4) {
            tmp =
                (Base64._REVERSE_LOOKUP[base64.charCodeAt(i)] << 18) |
                    (Base64._REVERSE_LOOKUP[base64.charCodeAt(i + 1)] << 12) |
                    (Base64._REVERSE_LOOKUP[base64.charCodeAt(i + 2)] << 6) |
                    Base64._REVERSE_LOOKUP[base64.charCodeAt(i + 3)];
            arr[curByte++] = (tmp >> 16) & 0xff;
            arr[curByte++] = (tmp >> 8) & 0xff;
            arr[curByte++] = tmp & 0xff;
        }
        if (placeHoldersLen === 2) {
            tmp =
                (Base64._REVERSE_LOOKUP[base64.charCodeAt(i)] << 2) |
                    (Base64._REVERSE_LOOKUP[base64.charCodeAt(i + 1)] >> 4);
            arr[curByte++] = tmp & 0xff;
        }
        if (placeHoldersLen === 1) {
            tmp =
                (Base64._REVERSE_LOOKUP[base64.charCodeAt(i)] << 10) |
                    (Base64._REVERSE_LOOKUP[base64.charCodeAt(i + 1)] << 4) |
                    (Base64._REVERSE_LOOKUP[base64.charCodeAt(i + 2)] >> 2);
            arr[curByte++] = (tmp >> 8) & 0xff;
            arr[curByte++] = tmp & 0xff;
        }
        return arr;
    }
    /**
     * Convert a byte array to base 64.
     * @param bytes The byte array to convert.
     * @returns The data as base64 string.
     */
    static encode(bytes) {
        let tmp;
        const len = bytes.length;
        const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
        const parts = [];
        const maxChunkLength = 16383; // must be multiple of 3
        // go through the array every three bytes, we'll deal with trailing stuff later
        for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
            parts.push(Base64.encodeChunk(bytes, i, Math.min(i + maxChunkLength, len2)));
        }
        // pad the end with zeros, but make sure to not forget the extra bytes
        if (extraBytes === 1) {
            tmp = bytes[len - 1];
            parts.push(`${Base64._LOOKUP[tmp >> 2] + Base64._LOOKUP[(tmp << 4) & 0x3f]}==`);
        }
        else if (extraBytes === 2) {
            tmp = (bytes[len - 2] << 8) + bytes[len - 1];
            parts.push(`${Base64._LOOKUP[tmp >> 10] + Base64._LOOKUP[(tmp >> 4) & 0x3f] + Base64._LOOKUP[(tmp << 2) & 0x3f]}=`);
        }
        return parts.join("");
    }
    /**
     * Calculate the byte length.
     * @param validLen The valid length.
     * @param placeHoldersLen The placeholder length.
     * @returns The length.
     * @internal
     */
    static calcByteLength(validLen, placeHoldersLen) {
        return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
    }
    /**
     * Get the valid and placeholder lengths from a bas64 string.
     * @param base64 The base64 string.
     * @returns The lengths.
     * @internal
     */
    static getLengths(base64) {
        const len = base64.length;
        if (len % 4 > 0) {
            throw new GeneralError(Base64._CLASS_NAME, "length4Multiple", { value: len });
        }
        // Trim off extra bytes after placeholder bytes are found
        // See: https://github.com/beatgammit/base64-js/issues/42
        let validLen = base64.indexOf("=");
        if (validLen === -1) {
            validLen = len;
        }
        const placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);
        return [validLen, placeHoldersLen];
    }
    /**
     * Convert the triplet to base 64.
     * @param num The number to convert.
     * @returns The base64 encoding.
     * @internal
     */
    static tripletToBase64(num) {
        return (Base64._LOOKUP[(num >> 18) & 0x3f] +
            Base64._LOOKUP[(num >> 12) & 0x3f] +
            Base64._LOOKUP[(num >> 6) & 0x3f] +
            Base64._LOOKUP[num & 0x3f]);
    }
    /**
     * Encode a chunk.
     * @param bytes The byte array.
     * @param start The start index in the buffer.
     * @param end The end index in the buffer.
     * @returns The encoded chunk.
     * @internal
     */
    static encodeChunk(bytes, start, end) {
        let tmp;
        const output = [];
        for (let i = start; i < end; i += 3) {
            tmp = ((bytes[i] << 16) & 0xff0000) + ((bytes[i + 1] << 8) & 0xff00) + (bytes[i + 2] & 0xff);
            output.push(Base64.tripletToBase64(tmp));
        }
        return output.join("");
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to help with base64 URL Encoding/Decoding.
 * https://www.rfc-editor.org/rfc/rfc4648#section-5.
 */
class Base64Url {
    /**
     * Convert the base 64 string to a byte array.
     * @param base64Url The base64 url string to convert.
     * @returns The byte array.
     */
    static decode(base64Url) {
        let base64 = base64Url;
        // Base 64 url can have padding removed, so add it back if it is missing.
        if (base64.length > 0 && !base64.endsWith("=")) {
            const placeHoldersLen = 4 - (base64.length % 4);
            if (placeHoldersLen > 0 && placeHoldersLen < 4) {
                base64 = base64.padEnd(base64.length + placeHoldersLen, "=");
            }
        }
        base64 = base64.replace(/-/g, "+").replace(/_/g, "/");
        return Base64.decode(base64);
    }
    /**
     * Convert a byte array to base 64 url.
     * @param bytes The byte array to convert.
     * @returns The data as base64 url string.
     */
    static encode(bytes) {
        const base64 = Base64.encode(bytes);
        // Base 64 url can have padding removed, so remove it.
        return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    }
}

/**
 * Class to handle errors which are triggered by data already existing.
 */
class AlreadyExistsError extends BaseError {
    /**
     * Runtime name for the class.
     */
    static CLASS_NAME = "AlreadyExistsError";
    /**
     * Create a new instance of AlreadyExistsError.
     * @param source The source of the error.
     * @param message The message as a code.
     * @param existingId The id for the item.
     * @param inner The inner error if we have wrapped another error.
     */
    constructor(source, message, existingId, inner) {
        super(AlreadyExistsError.CLASS_NAME, source, message, { existingId }, inner);
    }
}

/**
 * Class to handle errors which are triggered by conflicting data.
 */
class ConflictError extends BaseError {
    /**
     * Runtime name for the class.
     */
    static CLASS_NAME = "ConflictError";
    /**
     * Create a new instance of ConflictError.
     * @param source The source of the error.
     * @param message The message as a code.
     * @param conflictId The id that has conflicts.
     * @param conflicts The conflicts that occurred.
     * @param inner The inner error if we have wrapped another error.
     */
    constructor(source, message, conflictId, conflicts, inner) {
        super(ConflictError.CLASS_NAME, source, message, { conflictId, conflicts }, inner);
    }
}

/**
 * Class to handle errors which are triggered by data guards.
 */
class GuardError extends BaseError {
    /**
     * Runtime name for the class.
     */
    static CLASS_NAME = "GuardError";
    /**
     * Create a new instance of GuardError.
     * @param source The source of the error.
     * @param message The message as a code.
     * @param propertyName The property which triggered the guard error for the item.
     * @param propertyValue The property value which triggered the guard error for the item.
     * @param propertyOptions The property options which might be allowed.
     */
    constructor(source, message, propertyName, propertyValue, propertyOptions) {
        super(GuardError.CLASS_NAME, source, message, {
            property: propertyName ?? "property",
            value: Is.undefined(propertyValue) ? "undefined" : propertyValue,
            options: propertyOptions
        });
    }
}

/**
 * Class to handle errors which are triggered by data not being found.
 */
class NotFoundError extends BaseError {
    /**
     * Runtime name for the class.
     */
    static CLASS_NAME = "NotFoundError";
    /**
     * Create a new instance of NotFoundError.
     * @param source The source of the error.
     * @param message The message as a code.
     * @param notFoundId The id for the item.
     * @param inner The inner error if we have wrapped another error.
     */
    constructor(source, message, notFoundId, inner) {
        super(NotFoundError.CLASS_NAME, source, message, { notFoundId }, inner);
    }
}

/**
 * Class to handle errors.
 */
class NotImplementedError extends BaseError {
    /**
     * Runtime name for the class.
     */
    static CLASS_NAME = "NotImplementedError";
    /**
     * Create a new instance of NotImplementedError.
     * @param source The source of the error.
     * @param method The method for the error.
     */
    constructor(source, method) {
        super(NotImplementedError.CLASS_NAME, source, "common.notImplementedMethod", {
            method
        });
    }
}

/**
 * Class to handle errors when a feature is unsupported.
 */
class NotSupportedError extends BaseError {
    /**
     * Runtime name for the class.
     */
    static CLASS_NAME = "NotSupportedError";
    /**
     * Create a new instance of NotSupportedError.
     * @param source The source of the error.
     * @param message The message as a code.
     * @param inner The inner error if we have wrapped another error.
     */
    constructor(source, message, inner) {
        super(NotSupportedError.CLASS_NAME, source, message, undefined, inner);
    }
}

/**
 * Class to handle errors which are triggered by access not being unauthorized.
 */
class UnauthorizedError extends BaseError {
    /**
     * Runtime name for the class.
     */
    static CLASS_NAME = "UnauthorizedError";
    /**
     * Create a new instance of UnauthorizedError.
     * @param source The source of the error.
     * @param message The message as a code.
     * @param inner The inner error if we have wrapped another error.
     */
    constructor(source, message, inner) {
        super(UnauthorizedError.CLASS_NAME, source, message, undefined, inner);
    }
}

/**
 * Class to handle errors when some data can not be processed.
 */
class UnprocessableError extends BaseError {
    /**
     * Runtime name for the class.
     */
    static CLASS_NAME = "UnprocessableError";
    /**
     * Create a new instance of UnprocessableError.
     * @param source The source of the error.
     * @param message The message as a code.
     * @param properties Any additional information for the error.
     * @param inner The inner error if we have wrapped another error.
     */
    constructor(source, message, properties, inner) {
        super(UnprocessableError.CLASS_NAME, source, message, properties, inner);
    }
}

/**
 * Class to handle errors which are triggered by entity validation.
 */
class ValidationError extends BaseError {
    /**
     * Runtime name for the class.s
     */
    static CLASS_NAME = "ValidationError";
    /**
     * Create a new instance of ValidationError.
     * @param source The source of the error.
     * @param validationObject The object that failed validation.
     * @param validationFailures The validation failures.
     */
    constructor(source, validationObject, validationFailures) {
        super(ValidationError.CLASS_NAME, source, "common.validation", {
            validationObject,
            validationFailures
        });
    }
}

/**
 * Class to help with arrays.
 */
class ArrayHelper {
    /**
     * Do the two arrays match.
     * @param arr1 The first array.
     * @param arr2 The second array.
     * @returns True if both arrays are empty of have the same values.
     */
    static matches(arr1, arr2) {
        if (Is.empty(arr1) && Is.empty(arr2)) {
            return true;
        }
        if (!((Is.array(arr1) && Is.array(arr2)) || (Is.typedArray(arr1) && Is.typedArray(arr2)))) {
            return false;
        }
        if (arr1.length !== arr2.length) {
            return false;
        }
        for (let i = 0; i < arr1.length; i++) {
            if (arr1[i] !== arr2[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Convert an object or array to an array.
     * @param value The object or array to convert.
     * @returns The array.
     */
    static fromObjectOrArray(value) {
        if (Is.empty(value)) {
            return undefined;
        }
        if (Is.array(value)) {
            return value;
        }
        return [value];
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to handle guard operations for parameters.
 */
class Guards {
    /**
     * Is the property defined.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static defined(source, property, value) {
        if (Is.undefined(value)) {
            throw new GuardError(source, "guard.undefined", property, value);
        }
    }
    /**
     * Is the property a string.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static string(source, property, value) {
        if (!Is.string(value)) {
            throw new GuardError(source, "guard.string", property, value);
        }
    }
    /**
     * Is the property a string with a value.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static stringValue(source, property, value) {
        if (!Is.string(value)) {
            throw new GuardError(source, "guard.string", property, value);
        }
        if (value.length === 0) {
            throw new GuardError(source, "guard.stringEmpty", property, value);
        }
    }
    /**
     * Is the property a JSON value.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static json(source, property, value) {
        if (!Is.json(value)) {
            throw new GuardError(source, "guard.stringJson", property, value);
        }
    }
    /**
     * Is the property a base64 string.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static stringBase64(source, property, value) {
        if (!Is.stringBase64(value)) {
            throw new GuardError(source, "guard.base64", property, value);
        }
    }
    /**
     * Is the property a base64 url string.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static stringBase64Url(source, property, value) {
        if (!Is.stringBase64Url(value)) {
            throw new GuardError(source, "guard.base64Url", property, value);
        }
    }
    /**
     * Is the property a base58 string.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static stringBase58(source, property, value) {
        if (!Is.stringBase58(value)) {
            throw new GuardError(source, "guard.base58", property, value);
        }
    }
    /**
     * Is the property a string with a hex value.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @param allowPrefix Allow the hex to have the 0x prefix.
     * @throws GuardError If the value does not match the assertion.
     */
    static stringHex(source, property, value, allowPrefix = false) {
        Guards.stringValue(source, property, value);
        if (!HexHelper.isHex(value, allowPrefix)) {
            throw new GuardError(source, "guard.stringHex", property, value);
        }
    }
    /**
     * Is the property a string with a hex value with fixed length.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @param length The length of the string to match.
     * @param allowPrefix Allow the hex to have the 0x prefix.
     * @throws GuardError If the value does not match the assertion.
     */
    static stringHexLength(source, property, value, length, allowPrefix = false) {
        Guards.stringHex(source, property, value, allowPrefix);
        if (HexHelper.stripPrefix(value).length !== length) {
            throw new GuardError(source, "guard.stringHexLength", property, value.length, length.toString());
        }
    }
    /**
     * Is the property a number.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static number(source, property, value) {
        if (!Is.number(value)) {
            throw new GuardError(source, "guard.number", property, value);
        }
    }
    /**
     * Is the property an integer.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static integer(source, property, value) {
        if (!Is.integer(value)) {
            throw new GuardError(source, "guard.integer", property, value);
        }
    }
    /**
     * Is the property a bigint.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static bigint(source, property, value) {
        if (!Is.bigint(value)) {
            throw new GuardError(source, "guard.bigint", property, value);
        }
    }
    /**
     * Is the property a boolean.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static boolean(source, property, value) {
        if (!Is.boolean(value)) {
            throw new GuardError(source, "guard.boolean", property, value);
        }
    }
    /**
     * Is the property a date.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static date(source, property, value) {
        if (!Is.date(value)) {
            throw new GuardError(source, "guard.date", property, value);
        }
    }
    /**
     * Is the property a timestamp in milliseconds.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static timestampMilliseconds(source, property, value) {
        if (!Is.timestampMilliseconds(value)) {
            throw new GuardError(source, "guard.timestampMilliseconds", property, value);
        }
    }
    /**
     * Is the property a timestamp in seconds.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static timestampSeconds(source, property, value) {
        if (!Is.timestampSeconds(value)) {
            throw new GuardError(source, "guard.timestampSeconds", property, value);
        }
    }
    /**
     * Is the property an object.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static object(source, property, value) {
        if (Is.undefined(value)) {
            throw new GuardError(source, "guard.objectUndefined", property, value);
        }
        if (!Is.object(value)) {
            throw new GuardError(source, "guard.object", property, value);
        }
    }
    /**
     * Is the property is an object with at least one property.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static objectValue(source, property, value) {
        if (Is.undefined(value)) {
            throw new GuardError(source, "guard.objectUndefined", property, value);
        }
        if (!Is.object(value)) {
            throw new GuardError(source, "guard.object", property, value);
        }
        if (Object.keys(value || {}).length === 0) {
            throw new GuardError(source, "guard.objectValue", property, value);
        }
    }
    /**
     * Is the property is an array.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static array(source, property, value) {
        if (!Is.array(value)) {
            throw new GuardError(source, "guard.array", property, value);
        }
    }
    /**
     * Is the property is an array with at least one item.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static arrayValue(source, property, value) {
        if (!Is.array(value)) {
            throw new GuardError(source, "guard.array", property, value);
        }
        if (value.length === 0) {
            throw new GuardError(source, "guard.arrayValue", property, value);
        }
    }
    /**
     * Is the property one of a list of items.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @param options The options the value must be one of.
     * @throws GuardError If the value does not match the assertion.
     */
    static arrayOneOf(source, property, value, options) {
        if (!Is.array(options)) {
            throw new GuardError(source, "guard.array", property, value);
        }
        if (!options.includes(value)) {
            throw new GuardError(source, "guard.arrayOneOf", property, value, options.join(", "));
        }
    }
    /**
     * Does the array start with the specified data.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @param startValues The values that must start the array.
     * @throws GuardError If the value does not match the assertion.
     */
    static arrayStartsWith(source, property, value, startValues) {
        if (!Is.arrayValue(value)) {
            throw new GuardError(source, "guard.array", property, value);
        }
        const startValuesArray = ArrayHelper.fromObjectOrArray(startValues);
        if (!Is.arrayValue(startValuesArray)) {
            throw new GuardError(source, "guard.array", property, startValuesArray);
        }
        for (let i = 0; i < startValuesArray.length; i++) {
            if (value[i] !== startValuesArray[i]) {
                throw new GuardError(source, "guard.arrayStartsWith", property, value, startValuesArray.join(", "));
            }
        }
    }
    /**
     * Does the array end with the specified data.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @param endValues The values that must end the array.
     * @throws GuardError If the value does not match the assertion.
     */
    static arrayEndsWith(source, property, value, endValues) {
        if (!Is.arrayValue(value)) {
            throw new GuardError(source, "guard.array", property, value);
        }
        const endValuesArray = ArrayHelper.fromObjectOrArray(endValues);
        if (!Is.arrayValue(endValuesArray)) {
            throw new GuardError(source, "guard.array", property, endValuesArray);
        }
        for (let i = 0; i < endValuesArray.length; i++) {
            if (value[value.length - i - 1] !== endValuesArray[endValuesArray.length - i - 1]) {
                throw new GuardError(source, "guard.arrayEndsWith", property, value, endValuesArray.join(", "));
            }
        }
    }
    /**
     * Is the property a Uint8Array.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static uint8Array(source, property, value) {
        if (!Is.uint8Array(value)) {
            throw new GuardError(source, "guard.uint8Array", property, value);
        }
    }
    /**
     * Is the property a function.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @returns True if the value is a function.
     * @throws GuardError If the value does not match the assertion.
     */
    static function(source, property, value) {
        if (!Is.function(value)) {
            throw new GuardError(source, "guard.function", property, value);
        }
        return true;
    }
    /**
     * Is the property a string formatted as an email address.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The value to test.
     * @throws GuardError If the value does not match the assertion.
     */
    static email(source, property, value) {
        if (!Is.email(value)) {
            throw new GuardError(source, "guard.email", property, value);
        }
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Provide a store for shared objects which can be accesses through multiple
 * instance loads of a packages.
 */
class SharedStore {
    /**
     * Get a property from the shared store.
     * @param prop The name of the property to get.
     * @returns The property if it exists.
     */
    static get(prop) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const shared = globalThis.__TWIN_SHARED__;
        if (Is.undefined(shared)) {
            return;
        }
        return shared[prop];
    }
    /**
     * Set the property in the shared store.
     * @param prop The name of the property to set.
     * @param value The value to set.
     */
    static set(prop, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (Is.undefined(globalThis.__TWIN_SHARED__)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            globalThis.__TWIN_SHARED__ = {};
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        globalThis.__TWIN_SHARED__[prop] = value;
    }
    /**
     * Remove a property from the shared store.
     * @param prop The name of the property to remove.
     */
    static remove(prop) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const shared = globalThis.__TWIN_SHARED__;
        if (!Is.undefined(shared)) {
            delete shared[prop];
        }
    }
}

/**
 * Factory for creating implementation of generic types.
 */
class Factory {
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "Factory";
    /**
     * Type name for the instances.
     * @internal
     */
    _typeName;
    /**
     * Store the generators.
     * @internal
     */
    _generators;
    /**
     * Store the created instances.
     * @internal
     */
    _instances;
    /**
     * Counter for the ordering.
     * @internal
     */
    _orderCounter;
    /**
     * Automatically created an instance when registered.
     * @internal
     */
    _autoInstance;
    /**
     * Match the name of the instance.
     * @internal
     */
    _matcher;
    /**
     * Create a new instance of Factory, private use createFactory.
     * @param typeName The type name for the instances.
     * @param autoInstance Automatically create an instance when registered.
     * @param matcher Match the name of the instance.
     * @internal
     */
    constructor(typeName, autoInstance = false, matcher) {
        this._typeName = typeName;
        this._generators = {};
        this._instances = {};
        this._orderCounter = 0;
        this._autoInstance = autoInstance;
        this._matcher = matcher ?? this.defaultMatcher.bind(this);
    }
    /**
     * Create a new factory, which is shared throughout all library instances.
     * @param typeName The type name for the instances.
     * @param autoInstance Automatically create an instance when registered.
     * @param matcher Match the name of the instance.
     * @returns The factory instance.
     */
    static createFactory(typeName, autoInstance = false, matcher) {
        const factories = Factory.getFactories();
        if (Is.undefined(factories[typeName])) {
            factories[typeName] = new Factory(typeName, autoInstance, matcher);
        }
        return factories[typeName];
    }
    /**
     * Get all the factories.
     * @returns All the factories.
     */
    static getFactories() {
        let factories = SharedStore.get("factories");
        if (Is.undefined(factories)) {
            factories = {};
            SharedStore.set("factories", factories);
        }
        return factories;
    }
    /**
     * Reset all the factories, which removes any created instances, but not the registrations.
     */
    static resetFactories() {
        const factories = Factory.getFactories();
        for (const typeName in factories) {
            factories[typeName].reset();
        }
    }
    /**
     * Clear all the factories, which removes anything registered with the factories.
     */
    static clearFactories() {
        const factories = Factory.getFactories();
        for (const typeName in factories) {
            factories[typeName].clear();
        }
    }
    /**
     * Register a new generator.
     * @param name The name of the generator.
     * @param generator The function to create an instance.
     */
    register(name, generator) {
        Guards.stringValue(Factory._CLASS_NAME, "name", name);
        Guards.function(Factory._CLASS_NAME, "generator", generator);
        this._generators[name] = {
            generator,
            order: this._orderCounter++
        };
        // Remove any existing instance
        this.removeInstance(name);
        if (this._autoInstance) {
            this._instances[name] = generator();
        }
    }
    /**
     * Unregister a generator.
     * @param name The name of the generator to unregister.
     * @throws GuardError if the parameters are invalid.
     * @throws GeneralError if no generator exists.
     */
    unregister(name) {
        Guards.stringValue(Factory._CLASS_NAME, "name", name);
        if (!this._generators[name]) {
            throw new GeneralError(Factory._CLASS_NAME, "noUnregister", {
                typeName: this._typeName,
                name
            });
        }
        delete this._generators[name];
        // Remove any existing instance
        this.removeInstance(name);
    }
    /**
     * Get a generator instance.
     * @param name The name of the instance to generate.
     * @returns An instance of the item.
     * @throws GuardError if the parameters are invalid.
     * @throws GeneralError if no item exists to get.
     */
    get(name) {
        const instance = this.getIfExists(name);
        if (!instance) {
            throw new GeneralError(Factory._CLASS_NAME, "noGet", {
                typeName: this._typeName,
                name
            });
        }
        return instance;
    }
    /**
     * Get a generator instance with no exceptions.
     * @param name The name of the instance to generate.
     * @returns An instance of the item or undefined if it does not exist.
     */
    getIfExists(name) {
        Guards.stringValue(Factory._CLASS_NAME, "name", name);
        const matchName = this._matcher(Object.keys(this._generators), name);
        if (Is.stringValue(matchName) && this._generators[matchName]) {
            if (!this._instances[matchName]) {
                this._instances[matchName] = this._generators[matchName].generator();
            }
            if (this._instances[matchName]) {
                return this._instances[matchName];
            }
        }
    }
    /**
     * Remove all the instances and leave the generators intact.
     */
    reset() {
        for (const name in this._generators) {
            this.removeInstance(name);
        }
        this._instances = {};
    }
    /**
     * Remove all the instances and the generators.
     */
    clear() {
        this._instances = {};
        this._generators = {};
        this._orderCounter = 0;
    }
    /**
     * Get all the instances as a map.
     * @returns The instances as a map.
     */
    instancesMap() {
        return this._instances;
    }
    /**
     * Get all the instances as a list in the order they were registered.
     * @returns The instances as a list in the order they were registered.
     */
    instancesList() {
        const orderedInstances = [];
        for (const instanceName in this._instances) {
            orderedInstances.push({
                instance: this._instances[instanceName],
                order: this._generators[instanceName].order
            });
        }
        return orderedInstances.sort((a, b) => a.order - b.order).map(o => o.instance);
    }
    /**
     * Get all the generator names in the order they were registered.
     * @returns The ordered generator names.
     */
    names() {
        const orderedNames = [];
        for (const generator in this._generators) {
            orderedNames.push({
                name: generator,
                order: this._generators[generator].order
            });
        }
        return orderedNames.sort((a, b) => a.order - b.order).map(o => o.name);
    }
    /**
     * Does the factory contain the name.
     * @param name The name of the instance to find.
     * @returns True if the factory has a matching name.
     */
    hasName(name) {
        Guards.stringValue(Factory._CLASS_NAME, "name", name);
        return Is.stringValue(this._matcher(Object.keys(this._generators), name));
    }
    /**
     * Remove any instances of the given name.
     * @param name The name of the instances to remove.
     * @internal
     */
    removeInstance(name) {
        delete this._instances[name];
    }
    /**
     * Match the requested name to the generator name.
     * @param names The list of names for all the generators.
     * @param name The name to match.
     * @returns The matched name or undefined if no match.
     * @internal
     */
    defaultMatcher(names, name) {
        return this._generators[name] ? name : undefined;
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Factory for creating implementation of component types.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const ComponentFactory = Factory.createFactory("component");

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/* eslint-disable no-bitwise */
/**
 * Convert arrays to and from different formats.
 */
class Converter {
    /**
     * Lookup table for encoding.
     * @internal
     */
    static _ENCODE_LOOKUP;
    /**
     * Lookup table for decoding.
     * @internal
     */
    static _DECODE_LOOKUP;
    /**
     * Encode a raw array to UTF8 string.
     * @param array The bytes to encode.
     * @param startIndex The index to start in the bytes.
     * @param length The length of bytes to read.
     * @returns The array formatted as UTF8.
     */
    static bytesToUtf8(array, startIndex, length) {
        const start = startIndex ?? 0;
        const len = length ?? array.length;
        let str = "";
        for (let i = start; i < start + len; i++) {
            const value = array[i];
            if (value < 0x80) {
                str += String.fromCharCode(value);
            }
            else if (value > 0xbf && value < 0xe0) {
                str += String.fromCharCode(((value & 0x1f) << 6) | (array[i + 1] & 0x3f));
                i += 1;
            }
            else if (value > 0xdf && value < 0xf0) {
                str += String.fromCharCode(((value & 0x0f) << 12) | ((array[i + 1] & 0x3f) << 6) | (array[i + 2] & 0x3f));
                i += 2;
            }
            else {
                // surrogate pair
                const charCode = (((value & 0x07) << 18) |
                    ((array[i + 1] & 0x3f) << 12) |
                    ((array[i + 2] & 0x3f) << 6) |
                    (array[i + 3] & 0x3f)) -
                    0x010000;
                str += String.fromCharCode((charCode >> 10) | 0xd800, (charCode & 0x03ff) | 0xdc00);
                i += 3;
            }
        }
        return str;
    }
    /**
     * Convert a UTF8 string to raw array.
     * @param utf8 The text to decode.
     * @returns The array.
     */
    static utf8ToBytes(utf8) {
        const bytes = [];
        for (let i = 0; i < utf8.length; i++) {
            let charCode = utf8.charCodeAt(i);
            if (charCode < 0x80) {
                bytes.push(charCode);
            }
            else if (charCode < 0x800) {
                bytes.push(0xc0 | (charCode >> 6), 0x80 | (charCode & 0x3f));
            }
            else if (charCode < 0xd800 || charCode >= 0xe000) {
                bytes.push(0xe0 | (charCode >> 12), 0x80 | ((charCode >> 6) & 0x3f), 0x80 | (charCode & 0x3f));
            }
            else {
                // surrogate pair
                i++;
                // UTF-16 encodes 0x10000-0x10FFFF by
                // subtracting 0x10000 and splitting the
                // 20 bits of 0x0-0xFFFFF into two halves
                charCode = 0x10000 + (((charCode & 0x3ff) << 10) | (utf8.charCodeAt(i) & 0x3ff));
                bytes.push(0xf0 | (charCode >> 18), 0x80 | ((charCode >> 12) & 0x3f), 0x80 | ((charCode >> 6) & 0x3f), 0x80 | (charCode & 0x3f));
            }
        }
        return Uint8Array.from(bytes);
    }
    /**
     * Encode a raw array to hex string.
     * @param array The bytes to encode.
     * @param includePrefix Include the 0x prefix on the returned hex.
     * @param startIndex The index to start in the bytes.
     * @param length The length of bytes to read.
     * @param reverse Reverse the combine direction.
     * @returns The array formatted as hex.
     */
    static bytesToHex(array, includePrefix = false, startIndex, length, reverse) {
        let hex = "";
        this.buildHexLookups();
        if (Converter._ENCODE_LOOKUP) {
            const len = length ?? array.length;
            const start = startIndex ?? 0;
            if (reverse) {
                for (let i = 0; i < len; i++) {
                    hex = Converter._ENCODE_LOOKUP[array[start + i]] + hex;
                }
            }
            else {
                for (let i = 0; i < len; i++) {
                    hex += Converter._ENCODE_LOOKUP[array[start + i]];
                }
            }
        }
        return includePrefix ? HexHelper.addPrefix(hex) : hex;
    }
    /**
     * Decode a hex string to raw array.
     * @param hex The hex to decode.
     * @param reverse Store the characters in reverse.
     * @returns The array.
     */
    static hexToBytes(hex, reverse) {
        const strippedHex = HexHelper.stripPrefix(hex);
        const sizeof = strippedHex.length >> 1;
        const length = sizeof << 1;
        const array = new Uint8Array(sizeof);
        this.buildHexLookups();
        if (Converter._DECODE_LOOKUP) {
            let i = 0;
            let n = 0;
            while (i < length) {
                array[n++] =
                    (Converter._DECODE_LOOKUP[strippedHex.charCodeAt(i++)] << 4) |
                        Converter._DECODE_LOOKUP[strippedHex.charCodeAt(i++)];
            }
            if (reverse) {
                array.reverse();
            }
        }
        return array;
    }
    /**
     * Convert the UTF8 to hex.
     * @param utf8 The text to convert.
     * @param includePrefix Include the 0x prefix on the returned hex.
     * @returns The hex version of the bytes.
     */
    static utf8ToHex(utf8, includePrefix = false) {
        const hex = Converter.bytesToHex(Converter.utf8ToBytes(utf8));
        return includePrefix ? HexHelper.addPrefix(hex) : hex;
    }
    /**
     * Convert the hex text to text.
     * @param hex The hex to convert.
     * @returns The UTF8 version of the bytes.
     */
    static hexToUtf8(hex) {
        return Converter.bytesToUtf8(Converter.hexToBytes(HexHelper.stripPrefix(hex)));
    }
    /**
     * Convert bytes to binary string.
     * @param bytes The bytes to convert.
     * @returns A binary string of the bytes.
     */
    static bytesToBinary(bytes) {
        const b = [];
        for (let i = 0; i < bytes.length; i++) {
            b.push(bytes[i].toString(2).padStart(8, "0"));
        }
        return b.join("");
    }
    /**
     * Convert a binary string to bytes.
     * @param binary The binary string.
     * @returns The bytes.
     */
    static binaryToBytes(binary) {
        const bytes = new Uint8Array(Math.ceil(binary.length / 8));
        for (let i = 0; i < bytes.length; i++) {
            bytes[i] = Number.parseInt(binary.slice(i * 8, (i + 1) * 8), 2);
        }
        return bytes;
    }
    /**
     * Convert bytes to base64 string.
     * @param bytes The bytes to convert.
     * @returns A base64 string of the bytes.
     */
    static bytesToBase64(bytes) {
        return Base64.encode(bytes);
    }
    /**
     * Convert a base64 string to bytes.
     * @param base64 The base64 string.
     * @returns The bytes.
     */
    static base64ToBytes(base64) {
        return Base64.decode(base64);
    }
    /**
     * Convert bytes to base64 url string.
     * @param bytes The bytes to convert.
     * @returns A base64 url string of the bytes.
     */
    static bytesToBase64Url(bytes) {
        return Base64Url.encode(bytes);
    }
    /**
     * Convert a base64 url string to bytes.
     * @param base64Url The base64 url string.
     * @returns The bytes.
     */
    static base64UrlToBytes(base64Url) {
        return Base64Url.decode(base64Url);
    }
    /**
     * Convert bytes to base58 string.
     * @param bytes The bytes to convert.
     * @returns A base58 string of the bytes.
     */
    static bytesToBase58(bytes) {
        return Base58.encode(bytes);
    }
    /**
     * Convert a base58 string to bytes.
     * @param base58 The base58 string.
     * @returns The bytes.
     */
    static base58ToBytes(base58) {
        return Base58.decode(base58);
    }
    /**
     * Build the static lookup tables.
     * @internal
     */
    static buildHexLookups() {
        if (!Converter._ENCODE_LOOKUP || !Converter._DECODE_LOOKUP) {
            const alphabet = "0123456789abcdef";
            Converter._ENCODE_LOOKUP = [];
            Converter._DECODE_LOOKUP = [];
            for (let i = 0; i < 256; i++) {
                Converter._ENCODE_LOOKUP[i] = alphabet[(i >> 4) & 0xf] + alphabet[i & 0xf];
                if (i < 16) {
                    if (i < 10) {
                        Converter._DECODE_LOOKUP[0x30 + i] = i;
                    }
                    else {
                        Converter._DECODE_LOOKUP[0x61 - 10 + i] = i;
                    }
                }
            }
        }
    }
}

/**
 * Helpers methods for JSON objects.
 */
class JsonHelper {
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "JsonHelper";
    /**
     * Serializes in canonical format.
     * Based on https://www.rfc-editor.org/rfc/rfc8785.
     * @param object The object to be serialized.
     * @returns The serialized object.
     */
    static canonicalize(object) {
        const buffer = [];
        if (object === null ||
            typeof object !== "object" ||
            ("toJSON" in object && object.toJSON instanceof Function)) {
            // Primitive data type
            buffer.push(JSON.stringify(object));
        }
        else if (Array.isArray(object)) {
            // Array maintain element order
            const parts = [];
            for (const element of object) {
                if (element === undefined) {
                    parts.push("null");
                }
                else {
                    parts.push(JsonHelper.canonicalize(element));
                }
            }
            buffer.push(`[${parts.join(",")}]`);
        }
        else {
            // Object sort properties
            const props = [];
            const keys = Object.keys(object).sort();
            const o = object;
            for (const key of keys) {
                if (o[key] !== undefined) {
                    props.push(`${JSON.stringify(key)}:${JsonHelper.canonicalize(o[key])}`);
                }
            }
            buffer.push(`{${props.join(",")}}`);
        }
        return buffer.join("");
    }
    /**
     * Creates a RFC 6902 diff set.
     * Based on https://www.rfc-editor.org/rfc/rfc6902.
     * @param object1 The first object.
     * @param object2 The second object.
     * @returns The list of patches.
     */
    static diff(object1, object2) {
        const operations = createPatch(object1, object2);
        return operations;
    }
    /**
     * Applies a RFC 6902 diff set to an object.
     * Based on https://www.rfc-editor.org/rfc/rfc6902.
     * @param object The object to patch.
     * @param patches The second object.
     * @returns The updated object.
     * @throws GeneralError if the patch fails.
     */
    static patch(object, patches) {
        const clone = ObjectHelper.clone(object);
        const result = applyPatch(clone, patches);
        for (let i = 0; i < result.length; i++) {
            if (!Is.empty(result[i])) {
                throw new GeneralError(JsonHelper._CLASS_NAME, "failedPatch", { index: i }, result[i]);
            }
        }
        return clone;
    }
    /**
     * Stringify the JSON with support for extended data types date/bigint/uint8array.
     * @param object The object to stringify.
     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
     * @returns The stringified object.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static stringifyEx(object, space) {
        // We want to keep the 'this' intact for the replacer
        // eslint-disable-next-line @typescript-eslint/unbound-method
        return JSON.stringify(object, JsonHelper.stringifyExReplacer, space);
    }
    /**
     * Parse the JSON string with support for extended data types date/bigint/uint8array.
     * @param json The object to pause.
     * @returns The object.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static parseEx(json) {
        // We want to keep the 'this' intact for the reviver
        // eslint-disable-next-line @typescript-eslint/unbound-method
        return JSON.parse(json, JsonHelper.parseExReviver);
    }
    /**
     * Replacer function to handle extended data types.
     * @param this The object.
     * @param key The key.
     * @param value The value.
     * @returns The value.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static stringifyExReplacer(key, value) {
        const rawValue = this[key];
        if (Is.bigint(rawValue)) {
            return {
                "@ext": "bigint",
                value: rawValue.toString()
            };
        }
        else if (Is.date(rawValue)) {
            return {
                "@ext": "date",
                value: rawValue.getTime()
            };
        }
        else if (Is.uint8Array(rawValue)) {
            return {
                "@ext": "uint8array",
                value: Converter.bytesToBase64(rawValue)
            };
        }
        return value;
    }
    /**
     * Reviver function to handle extended data types.
     * @param this The object.
     * @param key The key.
     * @param value The value.
     * @returns The value.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static parseExReviver(key, value) {
        if (Is.object(value)) {
            if (value["@ext"] === "bigint") {
                return BigInt(value.value);
            }
            else if (value["@ext"] === "date") {
                return new Date(value.value);
            }
            else if (value["@ext"] === "uint8array") {
                return Converter.base64ToBytes(value.value);
            }
        }
        return value;
    }
}

/**
 * Class to help with objects.
 */
class ObjectHelper {
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "ObjectHelper";
    /**
     * Convert an object to bytes.
     * @param obj The object to convert.
     * @param format Format the JSON content.
     * @returns The object as bytes.
     */
    static toBytes(obj, format = false) {
        if (obj === undefined) {
            return new Uint8Array();
        }
        const json = format ? JSON.stringify(obj, undefined, "\t") : JSON.stringify(obj);
        return Converter.utf8ToBytes(json);
    }
    /**
     * Convert a bytes to an object.
     * @param bytes The bytes to convert to an object.
     * @returns The object.
     * @throws GeneralError if there was an error parsing the JSON.
     */
    static fromBytes(bytes) {
        if (Is.empty(bytes) || bytes.length === 0) {
            return undefined;
        }
        try {
            const utf8 = Converter.bytesToUtf8(bytes);
            return JSON.parse(utf8);
        }
        catch (err) {
            throw new GeneralError(ObjectHelper._CLASS_NAME, "failedBytesToJSON", undefined, err);
        }
    }
    /**
     * Make a deep clone of an object.
     * @param obj The object to clone.
     * @returns The objects clone.
     */
    static clone(obj) {
        if (Is.undefined(obj)) {
            return undefined;
        }
        return structuredClone(obj);
    }
    /**
     * Deep merge objects.
     * @param obj1 The first object to merge.
     * @param obj2 The second object to merge.
     * @returns The combined deep merge of the objects.
     */
    static merge(obj1, obj2) {
        if (Is.empty(obj1)) {
            return ObjectHelper.clone(obj2);
        }
        if (Is.empty(obj2)) {
            return ObjectHelper.clone(obj1);
        }
        const obj1Clone = ObjectHelper.clone(obj1);
        if (Is.object(obj1Clone) && Is.object(obj2)) {
            const keys = Object.keys(obj2);
            for (const key of keys) {
                if (Is.object(obj1Clone[key]) && Is.object(obj2[key])) {
                    ObjectHelper.propertySet(obj1Clone, key, ObjectHelper.merge(obj1Clone[key], obj2[key]));
                }
                else {
                    ObjectHelper.propertySet(obj1Clone, key, obj2[key]);
                }
            }
        }
        return obj1Clone;
    }
    /**
     * Does one object equal another.
     * @param obj1 The first object to compare.
     * @param obj2 The second object to compare.
     * @param strictPropertyOrder Should the properties be in the same order, defaults to true.
     * @returns True is the objects are equal.
     */
    static equal(obj1, obj2, strictPropertyOrder) {
        if (strictPropertyOrder ?? true) {
            return JSON.stringify(obj1) === JSON.stringify(obj2);
        }
        return JsonHelper.canonicalize(obj1) === JsonHelper.canonicalize(obj2);
    }
    /**
     * Get the property of an unknown object.
     * @param obj The object to get the property from.
     * @param property The property to get, can be separated by dots for nested path.
     * @returns The property.
     */
    static propertyGet(obj, property) {
        const pathParts = property.split(".");
        let pathValue = obj;
        for (const pathPart of pathParts) {
            // Is the path part numeric i.e. an array index.
            const arrayMatch = /^(\d+)$/.exec(pathPart);
            if (arrayMatch) {
                const arrayIndex = Number.parseInt(arrayMatch[1], 10);
                if (Is.arrayValue(pathValue) && arrayIndex < pathValue.length) {
                    // There is no prop name so this is a direct array index on the current object
                    pathValue = pathValue[arrayIndex];
                }
                else {
                    // Array index for non array object so return
                    return undefined;
                }
            }
            else if (Is.object(pathValue)) {
                // No array part in path so assume object sub property
                pathValue = pathValue[pathPart];
            }
            else {
                return undefined;
            }
        }
        return pathValue;
    }
    /**
     * Set the property of an unknown object.
     * @param obj The object to set the property from.
     * @param property The property to set.
     * @param value The value to set.
     * @throws GeneralError if the property target is not an object.
     */
    static propertySet(obj, property, value) {
        const pathParts = property.split(".");
        let pathValue = obj;
        let parentObj;
        for (let i = 0; i < pathParts.length; i++) {
            const pathPart = pathParts[i];
            // Is the path part numeric i.e. an array index.
            const arrayMatch = /^(\d+)$/.exec(pathPart);
            const arrayIndex = arrayMatch ? Number.parseInt(arrayMatch[1], 10) : -1;
            if (i === pathParts.length - 1) {
                // Last part of path so set the value
                if (arrayIndex >= 0) {
                    if (Is.array(pathValue)) {
                        pathValue[arrayIndex] = value;
                    }
                    else if (Is.object(pathValue)) {
                        pathValue[arrayIndex] = value;
                    }
                    else {
                        throw new GeneralError(ObjectHelper._CLASS_NAME, "cannotSetArrayIndex", {
                            property,
                            index: arrayIndex
                        });
                    }
                }
                else if (Is.object(pathValue)) {
                    pathValue[pathPart] = value;
                }
                else {
                    throw new GeneralError(ObjectHelper._CLASS_NAME, "cannotSetProperty", { property });
                }
            }
            else {
                parentObj = pathValue;
                if (Is.object(pathValue)) {
                    pathValue = pathValue[pathPart];
                }
                else if (Is.array(pathValue)) {
                    pathValue = pathValue[arrayIndex];
                }
                if (Is.empty(pathValue)) {
                    const nextArrayMatch = /^(\d+)$/.exec(pathParts[i + 1]);
                    const nextArrayIndex = nextArrayMatch ? Number.parseInt(nextArrayMatch[1], 10) : -1;
                    if (nextArrayIndex >= 0) {
                        pathValue = [];
                    }
                    else {
                        pathValue = {};
                    }
                    if (Is.object(parentObj)) {
                        parentObj[pathPart] = pathValue;
                    }
                    else if (Is.array(parentObj)) {
                        parentObj[arrayIndex] = pathValue;
                    }
                }
            }
        }
    }
    /**
     * Delete the property of an unknown object.
     * @param obj The object to set the property from.
     * @param property The property to set
     */
    static propertyDelete(obj, property) {
        if (Is.object(obj)) {
            delete obj[property];
        }
    }
    /**
     * Extract a property from the object, providing alternative names.
     * @param obj The object to extract from.
     * @param propertyNames The possible names for the property.
     * @param removeProperties Remove the properties from the object, defaults to true.
     * @returns The property if available.
     */
    static extractProperty(obj, propertyNames, removeProperties = true) {
        let retVal;
        if (Is.object(obj)) {
            const names = Is.string(propertyNames) ? [propertyNames] : propertyNames;
            for (const prop of names) {
                retVal ??= ObjectHelper.propertyGet(obj, prop);
                if (removeProperties) {
                    ObjectHelper.propertyDelete(obj, prop);
                }
            }
        }
        return retVal;
    }
    /**
     * Pick a subset of properties from an object.
     * @param obj The object to pick the properties from.
     * @param keys The property keys to pick.
     * @returns The partial object.
     */
    static pick(obj, keys) {
        if (Is.object(obj) && Is.arrayValue(keys)) {
            const result = {};
            for (const key of keys) {
                result[key] = obj[key];
            }
            return result;
        }
        return obj;
    }
    /**
     * Omit a subset of properties from an object.
     * @param obj The object to omit the properties from.
     * @param keys The property keys to omit.
     * @returns The partial object.
     */
    static omit(obj, keys) {
        if (Is.object(obj) && Is.arrayValue(keys)) {
            const result = { ...obj };
            for (const key of keys) {
                delete result[key];
            }
            return result;
        }
        return obj;
    }
    /**
     * Converter the non JSON primitives to extended types.
     * @param obj The object to convert.
     * @returns The object with extended properties.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static toExtended(obj) {
        const jsonExtended = JsonHelper.stringifyEx(obj);
        return JSON.parse(jsonExtended);
    }
    /**
     * Converter the extended types to non JSON primitives.
     * @param obj The object to convert.
     * @returns The object with regular properties.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static fromExtended(obj) {
        const jsonExtended = JsonHelper.stringifyEx(obj);
        return JsonHelper.parseEx(jsonExtended);
    }
    /**
     * Remove empty properties from an object.
     * @param obj The object to remove the empty properties from.
     * @param options The options for the removal.
     * @param options.removeUndefined Remove undefined properties, defaults to true.
     * @param options.removeNull Remove null properties, defaults to false.
     * @returns The object with empty properties removed.
     */
    static removeEmptyProperties(obj, options) {
        if (Is.object(obj)) {
            const removeUndefined = options?.removeUndefined ?? true;
            const removeNull = options?.removeNull ?? false;
            const newObj = {};
            const keys = Object.keys(obj);
            for (const key of keys) {
                if (!((removeUndefined && Is.undefined(obj[key])) || (removeNull && Is.null(obj[key])))) {
                    newObj[key] = ObjectHelper.removeEmptyProperties(obj[key], options);
                }
            }
            return newObj;
        }
        else if (Is.array(obj)) {
            const arr = [];
            for (const element of obj) {
                arr.push(ObjectHelper.removeEmptyProperties(element, options));
            }
            return arr;
        }
        return obj;
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Environment variable helper.
 */
class EnvHelper {
    /**
     * Get the environment variable as an object with camel cased names.
     * @param envVars The environment variables.
     * @param prefix The prefix of the environment variables, if not provided gets all.
     * @returns The object with camel cased names.
     */
    static envToJson(envVars, prefix) {
        const result = {};
        if (!Is.empty(envVars)) {
            if (Is.empty(prefix)) {
                for (const envVar in envVars) {
                    if (Is.stringValue(envVars[envVar])) {
                        const camelCaseName = StringHelper.camelCase(envVar.toLowerCase());
                        ObjectHelper.propertySet(result, camelCaseName, envVars[envVar]);
                    }
                }
            }
            else {
                for (const envVar in envVars) {
                    if (envVar.startsWith(prefix) && Is.stringValue(envVars[envVar])) {
                        const camelCaseName = StringHelper.camelCase(envVar.replace(prefix, "").toLowerCase());
                        ObjectHelper.propertySet(result, camelCaseName, envVars[envVar]);
                    }
                }
            }
        }
        return result;
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to perform internationalization.
 */
class I18n {
    /**
     * The default translation.
     */
    static DEFAULT_LOCALE = "en";
    /**
     * Set the locale.
     * @param locale The new locale.
     */
    static setLocale(locale) {
        const i18nShared = I18n.getI18nShared();
        i18nShared.currentLocale = locale;
        for (const callback in i18nShared.localeChangedHandlers) {
            i18nShared.localeChangedHandlers[callback](i18nShared.currentLocale);
        }
    }
    /**
     * Get the locale.
     * @returns The current locale.
     */
    static getLocale() {
        const i18nShared = I18n.getI18nShared();
        return i18nShared.currentLocale;
    }
    /**
     * Add a locale dictionary.
     * @param locale The locale.
     * @param dictionary The dictionary to add.
     */
    static addDictionary(locale, dictionary) {
        const i18nShared = I18n.getI18nShared();
        const mergedKeys = {};
        I18n.flattenTranslationKeys(dictionary, "", mergedKeys);
        i18nShared.localeDictionaries[locale] = mergedKeys;
        for (const callback in i18nShared.dictionaryChangedHandlers) {
            i18nShared.dictionaryChangedHandlers[callback](i18nShared.currentLocale);
        }
    }
    /**
     * Get a locale dictionary.
     * @param locale The locale.
     * @returns The dictionary of undefined if it does not exist.
     */
    static getDictionary(locale) {
        const i18nShared = I18n.getI18nShared();
        return i18nShared.localeDictionaries[locale];
    }
    /**
     * Get all the locale dictionaries.
     * @returns The dictionaries.
     */
    static getAllDictionaries() {
        const i18nShared = I18n.getI18nShared();
        return i18nShared.localeDictionaries;
    }
    /**
     * Add a locale changed handler.
     * @param id The id of the handler.
     * @param handler The handler to add.
     */
    static addLocaleHandler(id, handler) {
        const i18nShared = I18n.getI18nShared();
        i18nShared.localeChangedHandlers[id] = handler;
    }
    /**
     * Remove a locale changed handler.
     * @param id The id of the handler.
     */
    static removeLocaleHandler(id) {
        const i18nShared = I18n.getI18nShared();
        delete i18nShared.localeChangedHandlers[id];
    }
    /**
     * Add a dictionary changed handler.
     * @param id The id of the handler.
     * @param handler The handler to add.
     */
    static addDictionaryHandler(id, handler) {
        const i18nShared = I18n.getI18nShared();
        i18nShared.dictionaryChangedHandlers[id] = handler;
    }
    /**
     * Remove a dictionary changed handler.
     * @param id The id of the handler.
     */
    static removeDictionaryHandler(id) {
        const i18nShared = I18n.getI18nShared();
        delete i18nShared.dictionaryChangedHandlers[id];
    }
    /**
     * Format a message.
     * @param key The key of the message to format.
     * @param values The values to substitute into the message.
     * @param overrideLocale Override the locale.
     * @returns The formatted string.
     */
    static formatMessage(key, values, overrideLocale) {
        const i18nShared = I18n.getI18nShared();
        let cl = overrideLocale ?? i18nShared.currentLocale;
        if (cl.startsWith("debug-")) {
            cl = I18n.DEFAULT_LOCALE;
        }
        if (!i18nShared.localeDictionaries[cl]) {
            return `!!Missing ${cl}`;
        }
        if (!i18nShared.localeDictionaries[cl][key]) {
            return `!!Missing ${cl}.${key}`;
        }
        if (i18nShared.currentLocale === "debug-k") {
            return key;
        }
        let ret = new IntlMessageFormat(i18nShared.localeDictionaries[cl][key], cl).format(values);
        if (i18nShared.currentLocale === "debug-x") {
            ret = ret.replace(/[a-z]/g, "x").replace(/[A-Z]/g, "x").replace(/\d/g, "n");
        }
        return ret;
    }
    /**
     * Check if the dictionaries have a message for the given key.
     * @param key The key to check for existence.
     * @returns True if the key exists.
     */
    static hasMessage(key) {
        const i18nShared = I18n.getI18nShared();
        return Is.string(i18nShared.localeDictionaries[i18nShared.currentLocale]?.[key]);
    }
    /**
     * Flatten the translation property paths for faster lookup.
     * @param translation The translation to merge.
     * @param propertyPath The current root path.
     * @param mergedKeys The merged keys dictionary to populate.
     * @internal
     */
    static flattenTranslationKeys(translation, propertyPath, mergedKeys) {
        for (const key in translation) {
            const val = translation[key];
            const mergedPath = propertyPath.length > 0 ? `${propertyPath}.${key}` : key;
            if (Is.string(val)) {
                mergedKeys[mergedPath] = val;
            }
            else if (Is.object(val)) {
                I18n.flattenTranslationKeys(val, mergedPath, mergedKeys);
            }
        }
    }
    /**
     * Get the I18n shared data.
     * @returns The I18n shared data.
     * @internal
     */
    static getI18nShared() {
        let i18nShared = SharedStore.get("i18n");
        if (Is.undefined(i18nShared)) {
            i18nShared = {
                localeDictionaries: {},
                currentLocale: I18n.DEFAULT_LOCALE,
                localeChangedHandlers: {},
                dictionaryChangedHandlers: {}
            };
            SharedStore.set("i18n", i18nShared);
        }
        return i18nShared;
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Error helper functions.
 */
class ErrorHelper {
    /**
     * Format Errors and returns just their messages.
     * @param error The error to format.
     * @param includeDetails Whether to include error details, defaults to false.
     * @returns The error formatted including any inner errors.
     */
    static formatErrors(error, includeDetails) {
        const localizedErrors = ErrorHelper.localizeErrors(error);
        if (includeDetails ?? false) {
            const output = [];
            for (const err of localizedErrors) {
                let detailedError = err.message;
                if (Is.stringValue(err.stack)) {
                    detailedError += `\n${err.stack}`;
                }
                output.push(detailedError);
            }
            return output;
        }
        return localizedErrors.map(e => e.message);
    }
    /**
     * Localize the content of an error and any inner errors.
     * @param error The error to format.
     * @returns The localized version of the errors flattened.
     */
    static localizeErrors(error) {
        const formattedErrors = [];
        if (Is.notEmpty(error)) {
            const errors = BaseError.flatten(error);
            for (const err of errors) {
                const errorNameKey = `errorNames.${StringHelper.camelCase(err.name)}`;
                const errorMessageKey = `error.${err.message}`;
                // If there is no error message then it is probably
                // from a 3rd party lib, so don't format it just display
                const hasErrorName = I18n.hasMessage(errorNameKey);
                const hasErrorMessage = I18n.hasMessage(errorMessageKey);
                const localizedError = {
                    name: I18n.formatMessage(hasErrorName ? errorNameKey : "errorNames.error"),
                    message: hasErrorMessage
                        ? I18n.formatMessage(errorMessageKey, err.properties)
                        : err.message
                };
                if (Is.stringValue(err.source)) {
                    localizedError.source = err.source;
                }
                if (Is.stringValue(err.stack)) {
                    // Remove the first line from the stack traces as they
                    // just have the error type and message duplicated
                    const lines = err.stack.split("\n");
                    lines.shift();
                    localizedError.stack = lines.join("\n");
                }
                const additional = ErrorHelper.formatValidationErrors(err);
                if (Is.stringValue(additional)) {
                    localizedError.additional = additional;
                }
                formattedErrors.push(localizedError);
            }
        }
        return formattedErrors;
    }
    /**
     * Localize the content of an error and any inner errors.
     * @param error The error to format.
     * @returns The localized version of the errors flattened.
     */
    static formatValidationErrors(error) {
        if (Is.object(error.properties) &&
            Object.keys(error.properties).length > 0 &&
            Is.object(error.properties) &&
            Is.arrayValue(error.properties.validationFailures)) {
            const validationErrors = [];
            for (const validationFailure of error.properties.validationFailures) {
                const errorI18n = `error.${validationFailure.reason}`;
                const errorMessage = I18n.hasMessage(errorI18n)
                    ? I18n.formatMessage(errorI18n, validationFailure.properties)
                    : errorI18n;
                let v = `${validationFailure.property}: ${errorMessage}`;
                if (Is.object(validationFailure.properties) &&
                    Is.notEmpty(validationFailure.properties.value)) {
                    v += ` = ${JSON.stringify(validationFailure.properties.value)}`;
                }
                validationErrors.push(v);
            }
            return validationErrors.join("\n");
        }
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * The types the extracted data can be coerced to.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const CoerceType = {
    /**
     * String.
     */
    String: "string",
    /**
     * Number.
     */
    Number: "number",
    /**
     * Integer.
     */
    Integer: "integer",
    /**
     * Boolean.
     */
    Boolean: "boolean",
    /**
     * Big Integer.
     */
    BigInt: "bigint",
    /**
     * Date.
     */
    Date: "date",
    /**
     * Date Time.
     */
    DateTime: "datetime",
    /**
     * Time.
     */
    Time: "time",
    /**
     * Object.
     */
    Object: "object",
    /**
     * Uint8Array.
     */
    Uint8Array: "uint8array"
};

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Coerce an object from one type to another.
 */
class Coerce {
    /**
     * Coerce the value to a string.
     * @param value The value to coerce.
     * @throws TypeError If the value can not be coerced.
     * @returns The value if it can be coerced.
     */
    static string(value) {
        if (Is.undefined(value)) {
            return value;
        }
        if (Is.string(value)) {
            return value;
        }
        if (Is.number(value)) {
            return value.toString();
        }
        if (Is.boolean(value)) {
            return value ? "true" : "false";
        }
        if (Is.date(value)) {
            return value.toISOString();
        }
    }
    /**
     * Coerce the value to a number.
     * @param value The value to coerce.
     * @throws TypeError If the value can not be coerced.
     * @returns The value if it can be coerced.
     */
    static number(value) {
        if (Is.undefined(value)) {
            return value;
        }
        if (Is.number(value)) {
            return value;
        }
        if (Is.string(value)) {
            const parsed = Number.parseFloat(value);
            if (Is.number(parsed)) {
                return parsed;
            }
        }
        if (Is.boolean(value)) {
            return value ? 1 : 0;
        }
        if (Is.date(value)) {
            return value.getTime();
        }
    }
    /**
     * Coerce the value to an integer.
     * @param value The value to coerce.
     * @throws TypeError If the value can not be coerced.
     * @returns The value if it can be coerced.
     */
    static integer(value) {
        const num = Coerce.number(value);
        if (!Is.undefined(num)) {
            return Math.trunc(num);
        }
    }
    /**
     * Coerce the value to a bigint.
     * @param value The value to coerce.
     * @throws TypeError If the value can not be coerced.
     * @returns The value if it can be coerced.
     */
    static bigint(value) {
        if (Is.undefined(value)) {
            return value;
        }
        if (Is.bigint(value)) {
            return value;
        }
        if (Is.number(value)) {
            return BigInt(value);
        }
        if (Is.string(value)) {
            const parsed = Number.parseFloat(value);
            if (Is.integer(parsed)) {
                return BigInt(parsed);
            }
        }
        if (Is.boolean(value)) {
            return value ? 1n : 0n;
        }
    }
    /**
     * Coerce the value to a boolean.
     * @param value The value to coerce.
     * @throws TypeError If the value can not be coerced.
     * @returns The value if it can be coerced.
     */
    static boolean(value) {
        if (Is.undefined(value)) {
            return value;
        }
        if (Is.boolean(value)) {
            return value;
        }
        if (Is.number(value)) {
            // eslint-disable-next-line no-unneeded-ternary
            return value ? true : false;
        }
        if (Is.string(value)) {
            if (/true/i.test(value)) {
                return true;
            }
            if (/false/i.test(value)) {
                return false;
            }
        }
    }
    /**
     * Coerce the value to a date.
     * @param value The value to coerce.
     * @throws TypeError If the value can not be coerced.
     * @returns The value if it can be coerced.
     */
    static date(value) {
        if (Is.undefined(value)) {
            return value;
        }
        if (Is.date(value)) {
            return value;
        }
        if (Is.number(value)) {
            return new Date(value);
        }
        if (Is.string(value)) {
            const dt = new Date(value);
            if (!Number.isNaN(dt.getTime())) {
                const utc = Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate());
                return new Date(utc);
            }
        }
    }
    /**
     * Coerce the value to a date/time.
     * @param value The value to coerce.
     * @throws TypeError If the value can not be coerced.
     * @returns The value if it can be coerced.
     */
    static dateTime(value) {
        if (Is.undefined(value)) {
            return value;
        }
        if (Is.date(value)) {
            return value;
        }
        if (Is.number(value)) {
            return new Date(value);
        }
        if (Is.string(value)) {
            const dt = new Date(value);
            if (!Number.isNaN(dt.getTime())) {
                const utc = Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate(), dt.getUTCHours(), dt.getUTCMinutes(), dt.getUTCSeconds(), dt.getUTCMilliseconds());
                return new Date(utc);
            }
        }
    }
    /**
     * Coerce the value to a time.
     * @param value The value to coerce.
     * @throws TypeError If the value can not be coerced.
     * @returns The value if it can be coerced.
     */
    static time(value) {
        if (Is.undefined(value)) {
            return value;
        }
        if (Is.date(value)) {
            return value;
        }
        if (Is.number(value)) {
            const dt = new Date(value);
            dt.setFullYear(1970, 0, 1);
            return dt;
        }
        if (Is.string(value)) {
            const dt = new Date(value);
            if (!Number.isNaN(dt.getTime())) {
                const utc = Date.UTC(1970, 0, 1, dt.getUTCHours(), dt.getUTCMinutes(), dt.getUTCSeconds(), dt.getUTCMilliseconds());
                return new Date(utc);
            }
        }
    }
    /**
     * Coerce the value to an object.
     * @param value The value to coerce.
     * @throws TypeError If the value can not be coerced.
     * @returns The value if it can be coerced.
     */
    static object(value) {
        if (Is.undefined(value)) {
            return value;
        }
        if (Is.object(value)) {
            return value;
        }
        if (Is.stringValue(value)) {
            try {
                return JSON.parse(value);
            }
            catch { }
        }
    }
    /**
     * Coerce the value to a Uint8Array.
     * @param value The value to coerce.
     * @throws TypeError If the value can not be coerced.
     * @returns The value if it can be coerced.
     */
    static uint8Array(value) {
        if (Is.undefined(value)) {
            return value;
        }
        if (Is.string(value)) {
            if (Is.stringHex(value.toLowerCase(), true)) {
                return Converter.hexToBytes(value.toLowerCase());
            }
            if (Is.stringBase64(value)) {
                return Converter.base64ToBytes(value);
            }
        }
    }
    /**
     * Coerces a value based on the coercion type.
     * @param value The value to coerce.
     * @param type The coercion type to perform.
     * @returns The coerced value.
     */
    static byType(value, type) {
        switch (type) {
            case CoerceType.String:
                return Coerce.string(value);
            case CoerceType.Number:
                return Coerce.number(value);
            case CoerceType.Integer:
                return Coerce.integer(value);
            case CoerceType.BigInt:
                return Coerce.bigint(value);
            case CoerceType.Boolean:
                return Coerce.boolean(value);
            case CoerceType.Date:
                return Coerce.date(value);
            case CoerceType.DateTime:
                return Coerce.dateTime(value);
            case CoerceType.Time:
                return Coerce.time(value);
            case CoerceType.Object:
                return Coerce.object(value);
            case CoerceType.Uint8Array:
                return Coerce.uint8Array(value);
            default:
                return value;
        }
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to help with filenames.
 */
class FilenameHelper {
    /**
     * Replaces any unsafe characters in the filename.
     * @param filename The filename to make safe.
     * @returns The safe filename.
     */
    static safeFilename(filename) {
        let safe = Coerce.string(filename);
        if (Is.empty(safe)) {
            return "";
        }
        // Common non filename characters
        safe = safe.replace(/["*/:<>?\\|]/g, "_");
        // Windows non filename characters
        safe = safe.replace(/^(con|prn|aux|nul|com\d|lpt\d)$/i, "_");
        // Control characters
        safe = safe.replace(/[\u0000-\u001F\u0080-\u009F]/g, "_");
        // Relative paths
        safe = safe.replace(/^\.+/, "_");
        // Trailing periods
        safe = safe.replace(/\.+$/, "");
        return safe;
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to help with random generation.
 */
class RandomHelper {
    /**
     * Generate a new random array.
     * @param length The length of buffer to create.
     * @returns The random array.
     */
    static generate(length) {
        const randomBytes = new Uint8Array(length);
        globalThis.crypto.getRandomValues(randomBytes);
        return randomBytes;
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to help with uint8 arrays.
 */
class Uint8ArrayHelper {
    /**
     * Concatenate multiple arrays.
     * @param arrays The array to concatenate.
     * @returns The combined array.
     */
    static concat(arrays) {
        let totalLength = 0;
        for (const array of arrays) {
            totalLength += array.length;
        }
        const concatBytes = new Uint8Array(totalLength);
        let offset = 0;
        for (const array of arrays) {
            concatBytes.set(array, offset);
            offset += array.length;
        }
        return concatBytes;
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Compression types.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const CompressionType = {
    /**
     * Gzip.
     */
    Gzip: "gzip",
    /**
     * Deflate.
     */
    Deflate: "deflate"
};

/**
 * A class to represent a bit string.
 */
class BitString {
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "BitString";
    /**
     * The storage for the bits.
     * @internal
     */
    _bits;
    /**
     * The number of bits stored in the buffer.
     * @internal
     */
    _numberBits;
    /**
     * Create a new instance of BitString.
     * @param numberBits The length of the bit string.
     */
    constructor(numberBits) {
        Guards.integer(BitString._CLASS_NAME, "numberBits", numberBits);
        this._numberBits = numberBits;
        this._bits = new Uint8Array(Math.ceil(numberBits / 8));
    }
    /**
     * Create a new instance of BitString from a bit array.
     * @param bits The bits to create the bit string from.
     * @param numberBits The number of bits in the bit string.
     * @returns The new instance of BitString.
     */
    static fromBits(bits, numberBits) {
        Guards.uint8Array(BitString._CLASS_NAME, "bits", bits);
        Guards.integer(BitString._CLASS_NAME, "numberBits", numberBits);
        const bs = new BitString(numberBits);
        bs._bits.set(bits);
        return bs;
    }
    /**
     * Get the bit at the given index.
     * @param index The index to get the bit for.
     * @returns True if the bit at the index is set.
     * @throws GeneralError if the index is out of range.
     */
    getBit(index) {
        Guards.integer(BitString._CLASS_NAME, "index", index);
        if (index < 0 || index >= this._numberBits) {
            throw new GeneralError(BitString._CLASS_NAME, "outOfRange", {
                index,
                numberBits: this._numberBits
            });
        }
        const byteIndex = Math.floor(index / 8);
        const bitIndex = index % 8;
        return (this._bits[byteIndex] & (1 << bitIndex)) !== 0;
    }
    /**
     * Set the bit at the given index.
     * @param index The index to set the bit for.
     * @param value The value to set the bit to.
     * @throws GeneralError if the index is out of range.
     */
    setBit(index, value) {
        if (index < 0 || index >= this._numberBits) {
            throw new GeneralError(BitString._CLASS_NAME, "outOfRange", {
                index,
                numberBits: this._numberBits
            });
        }
        const byteIndex = Math.floor(index / 8);
        const bitIndex = index % 8;
        if (value) {
            this._bits[byteIndex] |= 1 << bitIndex;
        }
        else {
            this._bits[byteIndex] &= ~(1 << bitIndex);
        }
    }
    /**
     * Get the bits of the bit string.
     * @returns The bits stored in a Uint8Array.
     */
    getBits() {
        return this._bits;
    }
    /**
     * Get the length of the bit string.
     * @returns The length of the bit string.
     */
    getLength() {
        return this._numberBits;
    }
}

/**
 * Class to help with urls.
 */
class Url {
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "Url";
    /**
     * The internal representation of the url.
     * @internal
     */
    _urlParts;
    /**
     * Create a new instance of Url.
     * @param url The url string.
     */
    constructor(url) {
        Guards.stringValue(Url._CLASS_NAME, "url", url);
        try {
            const u = new URL(url);
            this._urlParts = Url.fromURLToParts(u);
        }
        catch {
            throw new GuardError(Url._CLASS_NAME, "guard.url", "url", url);
        }
    }
    /**
     * Try and parse a string into the url parts.
     * @param url The url to parse.
     * @returns The formatted url or undefined if the value is not a url.
     */
    static tryParseExact(url) {
        if (!Is.stringValue(url)) {
            return;
        }
        try {
            // By constructing a new standard URL class this will
            // validate the format
            const u = new URL(url);
            return Url.fromParts(Url.fromURLToParts(u));
        }
        catch { }
    }
    /**
     * Parse a string into the url parts.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The url to parse.
     * @throws GuardError If the value does not match the assertion.
     */
    static guard(source, property, value) {
        Guards.stringValue(source, property, value);
        const result = Url.tryParseExact(value);
        if (!result) {
            throw new GuardError(source, "guard.url", property, value);
        }
    }
    /**
     * Validate a string as a Url.
     * @param property Throw an exception if the url property is invalid.
     * @param value The url to parse.
     * @param failures The list of failures to add to.
     * @returns The formatted url.
     */
    static validate(property, value, failures) {
        if (!Is.stringValue(value)) {
            failures.push({
                property,
                reason: "validation.notEmpty"
            });
            return false;
        }
        const result = Url.tryParseExact(value);
        if (Is.undefined(result)) {
            failures.push({
                property,
                reason: "validation.beUrl"
            });
            return false;
        }
        return true;
    }
    /**
     * Construct a url from a URL.
     * @param url The url to construct from.
     * @returns The formatted url.
     */
    static fromURLToParts(url) {
        return {
            schema: url.protocol.replace(/:$/, ""),
            host: url.hostname,
            port: Coerce.number(url.port),
            path: url.pathname,
            params: Is.stringValue(url.search) ? url.search.replace(/^\?/, "") : undefined,
            hash: Is.stringValue(url.hash) ? url.hash.replace(/^#/, "") : undefined
        };
    }
    /**
     * Construct a url from valid parts.
     * @param urlParts The url to create the parts from.
     * @returns The formatted url.
     */
    static fromParts(urlParts) {
        const u = new Url("http://dummy");
        u._urlParts = urlParts;
        return u;
    }
    /**
     * Get the parts of the url.
     * @returns The parts of the url.
     */
    parts() {
        return this._urlParts;
    }
    /**
     * Convert the parts in to a full string.
     * @returns The formatted url.
     */
    toString() {
        const parts = [this._urlParts.schema, "://", this._urlParts.host];
        if (Is.number(this._urlParts.port)) {
            parts.push(`:${this._urlParts.port}`);
        }
        if (Is.stringValue(this._urlParts.path)) {
            parts.push(this._urlParts.path);
        }
        if (Is.stringValue(this._urlParts.params)) {
            parts.push(`?${this._urlParts.params}`);
        }
        if (Is.stringValue(this._urlParts.hash)) {
            parts.push(`#${this._urlParts.hash}`);
        }
        return parts.join("");
    }
}

/**
 * Class to help with urns.
 */
class Urn {
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "Urn";
    /**
     * The specific part of the namespace.
     * @internal
     */
    _urnParts;
    /**
     * Create a new instance of Urn.
     * @param namespaceIdentifier The identifier for the namespace.
     * @param namespaceSpecific The specific part of the namespace.
     */
    constructor(namespaceIdentifier, namespaceSpecific) {
        Guards.stringValue(Urn._CLASS_NAME, "namespaceIdentifier", namespaceIdentifier);
        // Strip leading and trailing colons
        this._urnParts = [this.stripColons(namespaceIdentifier)];
        if (Is.array(namespaceSpecific)) {
            Guards.arrayValue(Urn._CLASS_NAME, "namespaceSpecific", namespaceSpecific);
            this._urnParts.push(...namespaceSpecific);
        }
        else {
            Guards.stringValue(Urn._CLASS_NAME, "namespaceSpecific", namespaceSpecific);
            this._urnParts.push(...this.stripColons(namespaceSpecific).split(":"));
        }
    }
    /**
     * Generate a random identifier with 32 byte id.
     * @param namespace The prefix for the urn.
     * @returns A new Id in URN format.
     */
    static generateRandom(namespace) {
        return new Urn(namespace, Converter.bytesToHex(RandomHelper.generate(32)));
    }
    /**
     * Does the provided urn match the namespace.
     * @param urn The urn to check.
     * @param namespace The namespace to match.
     * @returns True if the namespace matches.
     */
    static hasNamespace(urn, namespace) {
        if (!Is.stringValue(urn)) {
            return false;
        }
        if (urn.startsWith("urn:")) {
            urn = urn.slice(4);
        }
        if (urn.length === namespace.length) {
            return urn === namespace;
        }
        return urn.startsWith(`${namespace}:`);
    }
    /**
     * Try and parse a string into the urn parts.
     * @param urn The urn to parse.
     * @returns The formatted urn or undefined if the value is not a urn.
     */
    static tryParseExact(urn) {
        if (!Is.stringValue(urn)) {
            return;
        }
        const parts = urn.split(":");
        if (parts[0] === "urn") {
            parts.shift();
        }
        if (parts.length < 2) {
            return;
        }
        if (!/[\da-z][\da-z-]{0,31}/.test(parts[0])) {
            return;
        }
        for (let i = 1; i < parts.length; i++) {
            if (!/[\d!#$%'()*+,./:;=?@_a-z-]+/.test(parts[i])) {
                return;
            }
        }
        return new Urn(parts[0], parts.slice(1));
    }
    /**
     * Construct a urn from a string that has already been validated.
     * @param urn The urn to parse.
     * @returns The formatted urn.
     */
    static fromValidString(urn) {
        const parts = urn.split(":");
        if (parts[0] === "urn") {
            parts.shift();
        }
        return new Urn(parts[0], parts.slice(1));
    }
    /**
     * Add a urn: prefix if there isn't one already.
     * @param urn The urn string to add a prefix to.
     * @returns The urn with a prefix.
     */
    static addPrefix(urn) {
        if (Is.stringValue(urn)) {
            if (urn.startsWith("urn:")) {
                return urn;
            }
            return `urn:${urn}`;
        }
    }
    /**
     * Parse a string into the urn parts.
     * @param source The source of the error.
     * @param property The name of the property.
     * @param value The urn to parse.
     * @throws GuardError If the value does not match the assertion.
     */
    static guard(source, property, value) {
        Guards.stringValue(source, property, value);
        const result = Urn.tryParseExact(value);
        if (!result) {
            throw new GuardError(source, "guard.urn", property, value);
        }
    }
    /**
     * Validate a string as a Urn.
     * @param property Throw an exception if the urn property is invalid.
     * @param value The urn to parse.
     * @param failures The list of failures to add to.
     * @returns The formatted urn.
     */
    static validate(property, value, failures) {
        if (!Is.stringValue(value)) {
            failures.push({
                property,
                reason: "validation.notEmpty"
            });
            return false;
        }
        const result = Urn.tryParseExact(value);
        if (Is.undefined(result)) {
            failures.push({
                property,
                reason: "validation.beUrn"
            });
            return false;
        }
        return true;
    }
    /**
     * Get the parts.
     * @param startIndex The index to start from, defaults to 0.
     * @returns The parts.
     */
    parts(startIndex = 0) {
        return this._urnParts.slice(startIndex);
    }
    /**
     * Get the namespace identifier.
     * @returns The namespace identifier.
     */
    namespaceIdentifier() {
        return this._urnParts[0];
    }
    /**
     * Get the namespace method, the first component after the identifier.
     * @returns The namespace method.
     */
    namespaceMethod() {
        return this._urnParts.length > 1 ? this._urnParts[1] : "";
    }
    /**
     * Get the namespace specific parts.
     * @param startIndex The index to start from, defaults to 0.
     * @returns The namespace specific parts.
     */
    namespaceSpecificParts(startIndex = 0) {
        return this._urnParts.length > 1 ? this._urnParts.slice(startIndex + 1) : [];
    }
    /**
     * Get the namespace specific.
     * @param startIndex The index to start from, defaults to 0.
     * @returns The namespace specific.
     */
    namespaceSpecific(startIndex = 0) {
        return this._urnParts.length > 1 ? this._urnParts.slice(startIndex + 1).join(":") : "";
    }
    /**
     * Convert the parts in to a full string.
     * @param omitPrefix Omit the urn: prefix from the string.
     * @returns The formatted urn.
     */
    toString(omitPrefix = true) {
        return omitPrefix ? this._urnParts.join(":") : `urn:${this._urnParts.join(":")}`;
    }
    /**
     * Strip the leading and trailing colons from a string.
     * @param val The value to strip.
     * @returns The stripped string.
     * @internal
     */
    stripColons(val) {
        return val.replace(/^:?(.*?):?$/, "$1");
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Cache the results from asynchronous requests.
 */
class AsyncCache {
    /**
     * Execute an async request and cache the result.
     * @param key The key for the entry in the cache.
     * @param ttlMs The TTL of the entry in the cache.
     * @param requestMethod The method to call if not cached.
     * @param cacheFailures Cache failure results, defaults to false.
     * @returns The response.
     */
    static exec(key, ttlMs, requestMethod, cacheFailures) {
        const cacheEnabled = Is.integer(ttlMs) && ttlMs >= 0;
        if (cacheEnabled) {
            AsyncCache.cleanupExpired();
            const cache = AsyncCache.getSharedCache();
            // Do we have a cache entry for the key
            if (cache[key]) {
                if (!Is.empty(cache[key].result)) {
                    // If the cache has already resulted in a value, resolve it
                    return Promise.resolve(cache[key].result);
                }
                else if (!Is.empty(cache[key].error)) {
                    // If the cache has already resulted in an error, reject it
                    return Promise.reject(cache[key].error);
                }
                // Otherwise create a promise to return and store the resolver
                // and rejector in the cache entry, so that we can call then
                // when the request is done
                let storedResolve;
                let storedReject;
                const wait = new Promise((resolve, reject) => {
                    storedResolve = resolve;
                    storedReject = reject;
                });
                if (!Is.empty(storedResolve) && !Is.empty(storedReject)) {
                    cache[key].promiseQueue.push({
                        requestMethod,
                        resolve: storedResolve,
                        reject: storedReject
                    });
                }
                return wait;
            }
            // If we don't have a cache entry, create a new one
            cache[key] = {
                promiseQueue: [],
                expires: ttlMs === 0 ? 0 : Date.now() + ttlMs
            };
            // Return a promise that wraps the original request method
            // so that we can store any results or errors in the cache
            return new Promise((resolve, reject) => {
                // Call the request method and store the result
                requestMethod()
                    // eslint-disable-next-line promise/prefer-await-to-then
                    .then(res => {
                    // If the request was successful, store the result
                    cache[key].result = res;
                    // and resolve both this promise and all the waiters
                    resolve(res);
                    for (const wait of cache[key].promiseQueue) {
                        wait.resolve(res);
                    }
                    return res;
                })
                    // eslint-disable-next-line promise/prefer-await-to-then
                    .catch((err) => {
                    // Reject the promise
                    reject(err);
                    // Handle the waiters based on the cacheFailures flag
                    if (cacheFailures ?? false) {
                        // If we are caching failures, store the error and reject the waiters
                        cache[key].error = err;
                        for (const wait of cache[key].promiseQueue) {
                            wait.reject(err);
                        }
                        // Clear the waiters so we don't call them again
                        cache[key].promiseQueue = [];
                    }
                    else {
                        // If not caching failures for any queued requests we
                        // have no value to either resolve or reject, so we
                        // just resolve with the original request method
                        for (const wait of cache[key].promiseQueue) {
                            wait.resolve(wait.requestMethod());
                        }
                        delete cache[key];
                    }
                });
            });
        }
    }
    /**
     * Get an entry from the cache.
     * @param key The key to get from the cache.
     * @returns The item from the cache if it exists.
     */
    static async get(key) {
        const cache = AsyncCache.getSharedCache();
        if (!Is.empty(cache[key].result)) {
            // If the cache has already resulted in a value, resolve it
            return cache[key].result;
        }
        else if (!Is.empty(cache[key].error)) {
            // If the cache has already resulted in an error, reject it
            throw cache[key].error;
        }
    }
    /**
     * Set an entry into the cache.
     * @param key The key to set in the cache.
     * @param value The value to set in the cache.
     * @param ttlMs The TTL of the entry in the cache in ms, defaults to 1s.
     * @returns Nothing.
     */
    static async set(key, value, ttlMs) {
        const cache = AsyncCache.getSharedCache();
        cache[key] = {
            result: value,
            promiseQueue: [],
            expires: Date.now() + (ttlMs ?? 1000)
        };
    }
    /**
     * Remove an entry from the cache.
     * @param key The key to remove from the cache.
     */
    static remove(key) {
        const cache = AsyncCache.getSharedCache();
        delete cache[key];
    }
    /**
     * Clear the cache.
     * @param prefix Optional prefix to clear only entries with that prefix.
     */
    static clearCache(prefix) {
        const cache = AsyncCache.getSharedCache();
        if (Is.stringValue(prefix)) {
            for (const entry in cache) {
                if (entry.startsWith(prefix)) {
                    delete cache[entry];
                }
            }
        }
        else {
            SharedStore.set("asyncCache", {});
        }
    }
    /**
     * Perform a cleanup of the expired entries in the cache.
     */
    static cleanupExpired() {
        const cache = AsyncCache.getSharedCache();
        for (const entry in cache) {
            if (cache[entry].expires > 0 && cache[entry].expires < Date.now()) {
                delete cache[entry];
            }
        }
    }
    /**
     * Get the shared cache.
     * @returns The shared cache.
     * @internal
     */
    static getSharedCache() {
        let sharedCache = SharedStore.get("asyncCache");
        if (Is.undefined(sharedCache)) {
            sharedCache = {};
            SharedStore.set("asyncCache", sharedCache);
        }
        return sharedCache;
    }
}

/**
 * A class to handle compression.
 */
class Compression {
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "Compression";
    /**
     * Compress bytes using GZIP.
     * @param bytes The bytes to compress.
     * @param type The type of compression to use.
     * @returns The compressed bytes.
     */
    static async compress(bytes, type) {
        Guards.uint8Array(Compression._CLASS_NAME, "bytes", bytes);
        Guards.arrayOneOf(Compression._CLASS_NAME, "type", type, Object.values(CompressionType));
        const blob = new Blob([bytes]);
        const compressionStream = new CompressionStream(type);
        const compressionPipe = blob.stream().pipeThrough(compressionStream);
        const compressedBlob = await new Response(compressionPipe).blob();
        const compressedBytes = new Uint8Array(await compressedBlob.arrayBuffer());
        // GZIP header contains a byte which specifies the OS the
        // compression was performed on. We set this to 3 (Unix) to ensure
        // that we produce consistent results.
        if (type === CompressionType.Gzip && compressedBytes.length >= 10) {
            compressedBytes[9] = 3;
        }
        return compressedBytes;
    }
    /**
     * Decompress a gzipped compressed byte array.
     * @param compressedBytes The compressed bytes.
     * @param type The type of compression to use.
     * @returns The decompressed bytes.
     */
    static async decompress(compressedBytes, type) {
        Guards.uint8Array(Compression._CLASS_NAME, "compressedBytes", compressedBytes);
        Guards.arrayOneOf(Compression._CLASS_NAME, "type", type, Object.values(CompressionType));
        const blob = new Blob([compressedBytes]);
        const decompressionStream = new DecompressionStream(type);
        const decompressionPipe = blob.stream().pipeThrough(decompressionStream);
        const decompressedBlob = await new Response(decompressionPipe).blob();
        return new Uint8Array(await decompressedBlob.bytes());
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class to handle validation operations.
 */
class Validation {
    /**
     * Is the property null or undefined.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is a empty.
     */
    static empty(property, value, failures, fieldNameResource) {
        const is = Is.empty(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beEmpty",
                fieldName: fieldNameResource ?? "validation.defaultFieldName",
                properties: { value }
            });
        }
        return is;
    }
    /**
     * Is the property is not null or undefined.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is a not empty.
     */
    static notEmpty(property, value, failures, fieldNameResource) {
        const is = Is.notEmpty(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beNotEmpty",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property a string.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @param options Additional options for the validation.
     * @param options.minLength The minimum length of the string.
     * @param options.maxLength The maximum length of the string.
     * @param options.format Specific format to check.
     * @returns True if the value is a valid string.
     */
    static string(property, value, failures, fieldNameResource, options) {
        const is = Is.string(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beText",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        else {
            const minLength = options?.minLength;
            const maxLength = options?.maxLength;
            const minLimitDefined = Is.integer(minLength);
            const maxLimitDefined = Is.integer(maxLength);
            const belowMin = minLimitDefined && value.length < minLength;
            const aboveMax = maxLimitDefined && value.length > maxLength;
            if (options?.format === "base58" && !Is.stringBase58(value)) {
                failures.push({
                    property,
                    reason: "validation.beTextBase58",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value
                    }
                });
            }
            else if (options?.format === "base64" && !Is.stringBase64(value)) {
                failures.push({
                    property,
                    reason: "validation.beTextBase64",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value
                    }
                });
            }
            else if (options?.format === "hex" && !Is.stringHex(value)) {
                failures.push({
                    property,
                    reason: "validation.beTextHex",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value
                    }
                });
            }
            else if (Is.regexp(options?.format) && !options.format.test(value)) {
                failures.push({
                    property,
                    reason: "validation.beTextRegExp",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        format: options?.format
                    }
                });
            }
            if (minLimitDefined && maxLimitDefined && (belowMin || aboveMax)) {
                failures.push({
                    property,
                    reason: "validation.beTextMinMax",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        minLength,
                        maxLength
                    }
                });
            }
            else if (minLimitDefined && belowMin) {
                failures.push({
                    property,
                    reason: "validation.beTextMin",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        minLength
                    }
                });
            }
            else if (maxLimitDefined && aboveMax) {
                failures.push({
                    property,
                    reason: "validation.beTextMax",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        maxLength
                    }
                });
            }
        }
        return failures.length === 0;
    }
    /**
     * Is the property a string with a value.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @param options Additional options for the validation.
     * @param options.minLength The minimum length of the string.
     * @param options.maxLength The maximum length of the string.
     * @returns True if the value is a valid string.
     */
    static stringValue(property, value, failures, fieldNameResource, options) {
        const is = Is.stringValue(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beTextValue",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        else {
            const minLength = options?.minLength;
            const maxLength = options?.maxLength;
            const minLimitDefined = Is.integer(minLength);
            const maxLimitDefined = Is.integer(maxLength);
            const belowMin = minLimitDefined && value.length < minLength;
            const aboveMax = maxLimitDefined && value.length > maxLength;
            if (minLimitDefined && maxLimitDefined && (belowMin || aboveMax)) {
                failures.push({
                    property,
                    reason: "validation.beTextMinMax",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        minLength,
                        maxLength
                    }
                });
            }
            else if (minLimitDefined && belowMin) {
                failures.push({
                    property,
                    reason: "validation.beTextMin",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        minLength
                    }
                });
            }
            else if (maxLimitDefined && aboveMax) {
                failures.push({
                    property,
                    reason: "validation.beTextMax",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        maxLength
                    }
                });
            }
        }
        return failures.length === 0;
    }
    /**
     * Is the property a number.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @param options Additional options for the validation.
     * @param options.minValue The minimum value of the number.
     * @param options.maxValue The maximum value of the number.
     * @returns True if the value is a valid number.
     */
    static number(property, value, failures, fieldNameResource, options) {
        const is = Is.number(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beNumber",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        else {
            const minValue = options?.minValue;
            const maxValue = options?.maxValue;
            const minLimitDefined = Is.number(minValue);
            const maxLimitDefined = Is.number(maxValue);
            const belowMin = minLimitDefined && value < minValue;
            const aboveMax = maxLimitDefined && value > maxValue;
            if (minLimitDefined && maxLimitDefined && (belowMin || aboveMax)) {
                failures.push({
                    property,
                    reason: "validation.beNumberMinMax",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        minValue,
                        maxValue
                    }
                });
            }
            else if (minLimitDefined && belowMin) {
                failures.push({
                    property,
                    reason: "validation.beNumberMin",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        minValue
                    }
                });
            }
            else if (maxLimitDefined && aboveMax) {
                failures.push({
                    property,
                    reason: "validation.beNumberMax",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        maxValue
                    }
                });
            }
        }
        return failures.length === 0;
    }
    /**
     * Is the property an integer.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @param options Additional options for the validation.
     * @param options.minValue The minimum value of the integer.
     * @param options.maxValue The maximum value of the integer.
     * @returns True if the value is a valid integer.
     */
    static integer(property, value, failures, fieldNameResource, options) {
        const is = Is.integer(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beWholeNumber",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        else {
            const minValue = options?.minValue;
            const maxValue = options?.maxValue;
            const minLimitDefined = Is.integer(minValue);
            const maxLimitDefined = Is.integer(maxValue);
            const belowMin = minLimitDefined && value < minValue;
            const aboveMax = maxLimitDefined && value > maxValue;
            if (minLimitDefined && maxLimitDefined && (belowMin || aboveMax)) {
                failures.push({
                    property,
                    reason: "validation.beWholeNumberMinMax",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        minValue,
                        maxValue
                    }
                });
            }
            else if (minLimitDefined && belowMin) {
                failures.push({
                    property,
                    reason: "validation.beWholeNumberMin",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        minValue
                    }
                });
            }
            else if (maxLimitDefined && aboveMax) {
                failures.push({
                    property,
                    reason: "validation.beWholeNumberMax",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        maxValue
                    }
                });
            }
        }
        return failures.length === 0;
    }
    /**
     * Is the property a bigint.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @param options Additional options for the validation.
     * @param options.minValue The minimum value of the bigint.
     * @param options.maxValue The maximum value of the bigint.
     * @returns True if the value is a valid bigint.
     */
    static bigint(property, value, failures, fieldNameResource, options) {
        const is = Is.bigint(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beBigInteger",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        else {
            const minValue = options?.minValue;
            const maxValue = options?.maxValue;
            const minLimitDefined = Is.bigint(minValue);
            const maxLimitDefined = Is.bigint(maxValue);
            const belowMin = minLimitDefined && value < minValue;
            const aboveMax = maxLimitDefined && value > maxValue;
            if (minLimitDefined && maxLimitDefined && (belowMin || aboveMax)) {
                failures.push({
                    property,
                    reason: "validation.beBigIntegerMinMax",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        minValue,
                        maxValue
                    }
                });
            }
            else if (minLimitDefined && belowMin) {
                failures.push({
                    property,
                    reason: "validation.beBigIntegerMin",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        minValue
                    }
                });
            }
            else if (maxLimitDefined && aboveMax) {
                failures.push({
                    property,
                    reason: "validation.beBigIntegerMax",
                    properties: {
                        fieldName: fieldNameResource ?? "validation.defaultFieldName",
                        value,
                        maxValue
                    }
                });
            }
        }
        return failures.length === 0;
    }
    /**
     * Is the property a boolean.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is a boolean.
     */
    static boolean(property, value, failures, fieldNameResource) {
        const is = Is.boolean(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beBoolean",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property a date.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is a date.
     */
    static date(property, value, failures, fieldNameResource) {
        if (Is.dateEmpty(value)) {
            failures.push({
                property,
                reason: "validation.beDate",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
            return false;
        }
        const is = Is.date(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beDate",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property a date in ISO 8601 format.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is a date.
     */
    static dateString(property, value, failures, fieldNameResource) {
        if (!Is.stringValue(value)) {
            failures.push({
                property,
                reason: "validation.beDate",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
            return false;
        }
        const is = Is.dateString(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beDate",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property a date/time in ISO 8601 format.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is a date/time.
     */
    static dateTimeString(property, value, failures, fieldNameResource) {
        if (!Is.stringValue(value)) {
            failures.push({
                property,
                reason: "validation.beDateTime",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
            return false;
        }
        const is = Is.dateTimeString(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beDateTime",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property a time in ISO 8601 format.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is a time.
     */
    static timeString(property, value, failures, fieldNameResource) {
        if (!Is.stringValue(value)) {
            failures.push({
                property,
                reason: "validation.beTime",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
            return false;
        }
        const is = Is.timeString(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beTime",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property a timestamp in milliseconds.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is a timestamp in milliseconds.
     */
    static timestampMilliseconds(property, value, failures, fieldNameResource) {
        if (!Is.integer(value)) {
            failures.push({
                property,
                reason: "validation.beTimestampMilliseconds",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
            return false;
        }
        const is = Is.timestampMilliseconds(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beTimestampMilliseconds",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property a timestamp in seconds.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is a timestamp in seconds.
     */
    static timestampSeconds(property, value, failures, fieldNameResource) {
        if (!Is.integer(value)) {
            failures.push({
                property,
                reason: "validation.beTimestampSeconds",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
            return false;
        }
        const is = Is.timestampSeconds(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beTimestampSeconds",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property an object.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is a object.
     */
    static object(property, value, failures, fieldNameResource) {
        const is = Is.object(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beObject",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property an array.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is an array.
     */
    static array(property, value, failures, fieldNameResource) {
        const is = Is.array(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beArray",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property an array with at least one item.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is an array with at least one element.
     */
    static arrayValue(property, value, failures, fieldNameResource) {
        const is = Is.array(value) && value.length > 0;
        if (!is) {
            failures.push({
                property,
                reason: "validation.beArrayValue",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property one of a list of items.
     * @param property The name of the property.
     * @param value The value to test.
     * @param options The options the value must be one of.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is one of the items in the options.
     */
    static arrayOneOf(property, value, options, failures, fieldNameResource) {
        if (Is.empty(value)) {
            failures.push({
                property,
                reason: "validation.beIncluded",
                properties: {
                    fieldName: fieldNameResource ?? "validation.defaultFieldName",
                    value,
                    options
                }
            });
            return false;
        }
        const is = Is.arrayOneOf(value, options);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beIncluded",
                properties: {
                    fieldName: fieldNameResource ?? "validation.defaultFieldName",
                    value,
                    options
                }
            });
        }
        return is;
    }
    /**
     * Is the property a Uint8Array.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is a Uint8Array.
     */
    static uint8Array(property, value, failures, fieldNameResource) {
        const is = Is.uint8Array(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beByteArray",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property valid JSON.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is valid JSON.
     */
    static json(property, value, failures, fieldNameResource) {
        const is = Is.json(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beJSON",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Is the property a string in e-mail format.
     * @param property The name of the property.
     * @param value The value to test.
     * @param failures The list of failures to add to.
     * @param fieldNameResource Optional i18n resource of the field name to display in the message.
     * @returns True if the value is a valid looking e-mail.
     */
    static email(property, value, failures, fieldNameResource) {
        const is = Is.email(value);
        if (!is) {
            failures.push({
                property,
                reason: "validation.beEmail",
                properties: { fieldName: fieldNameResource ?? "validation.defaultFieldName", value }
            });
        }
        return is;
    }
    /**
     * Throw the validation failures as a ValidationError.
     * @param source The source of the error.
     * @param objectName The object that was being validated.
     * @param failures The validation failures.
     * @throws ValidationError From the converted failures.
     */
    static asValidationError(source, objectName, failures) {
        if (Is.arrayValue(failures)) {
            throw new ValidationError(source, objectName, failures);
        }
    }
    /**
     * Map a list of failures to their properties in a map.
     * @param failures The validation failures to combine into the map for the properties.
     * @param propertyMap The map to add the failures to.
     * @param clearMap Should the map be cleared before adding the failures.
     */
    static toPropertyMap(failures, propertyMap, clearMap = true) {
        if (clearMap) {
            for (const prop in propertyMap) {
                delete propertyMap[prop];
            }
        }
        for (const validationFailure of failures) {
            if (Is.array(propertyMap[validationFailure.property])) {
                propertyMap[validationFailure.property].push(validationFailure);
            }
            else {
                propertyMap[validationFailure.property] = [validationFailure];
            }
        }
    }
}

export { AlreadyExistsError, ArrayHelper, AsyncCache, Base32, Base58, Base64, Base64Url, BaseError, BitString, Coerce, CoerceType, ComponentFactory, Compression, CompressionType, ConflictError, Converter, EnvHelper, ErrorHelper, Factory, FilenameHelper, GeneralError, GuardError, Guards, HexHelper, I18n, Is, JsonHelper, NotFoundError, NotImplementedError, NotSupportedError, ObjectHelper, RandomHelper, SharedStore, StringHelper, Uint8ArrayHelper, UnauthorizedError, UnprocessableError, Url, Urn, Validation, ValidationError };
