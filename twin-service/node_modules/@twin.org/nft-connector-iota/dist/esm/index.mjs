import { Transaction } from '@iota/iota-sdk/transactions';
import { Urn, GeneralError, Guards, Is, Converter, BaseError, StringHelper } from '@twin.org/core';
import { Iota } from '@twin.org/dlt-iota';
import { LoggingConnectorFactory } from '@twin.org/logging-models';
import { VaultConnectorFactory } from '@twin.org/vault-models';
import { WalletConnectorFactory } from '@twin.org/wallet-models';

var nft = {
	packageId: "0x1bd7add2dc75ba6a840e21792a1ba51d807ce9c3b29c4fa2140f383e77988daa",
	"package": "oRzrCwYAAAAKAQAKAgoQAxovBEkEBU0yB3/SAQjRAmAKsQMXDMgDbA20BAQADQIOAhMCFQERAAAMAAEDBAADAgIABAEHAAALAAEAABYCAQAAEwMBAAAUBAEAAAQFAQABBQcBAAEMBgcAAhAIAQEMAhMIAQEICAUHBQcIAwgDBQgDCAMIAwcIAgACBwgACAMDCAAFCAMECAAFCAMIAwEIAAEHCAIBCAECCQAFA05GVAZTdHJpbmcJVHhDb250ZXh0A1VJRARidXJuBmRlbGV0ZQJpZBJpbW11dGFibGVfbWV0YWRhdGEGaXNzdWVyDmlzc3VlcklkZW50aXR5CG1ldGFkYXRhBG1pbnQDbmV3A25mdAZvYmplY3QNb3duZXJJZGVudGl0eQ9wdWJsaWNfdHJhbnNmZXIGc3RyaW5nA3RhZwh0cmFuc2ZlchZ0cmFuc2Zlcl93aXRoX21ldGFkYXRhCnR4X2NvbnRleHQPdXBkYXRlX21ldGFkYXRhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAIHBggBBwgDEggDCggDCAUJCAMPCAMAAQQAAQwLBhEGCwALAQsDCgILBAsFEgALAjgAAgEBBAABBQsBCwAPABUCAgEEAAEICwINAA8BFQsACwE4AQIDAQQAAQsLAg0ADwEVDQALAxEBCwALATgBAgQBBAABCgsAEwABAQEBAQERBQIAAwAGAA=="
};
var compiledModulesJson = {
	nft: nft
};

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Utility functions for the iota nfts.
 */
class IotaNftUtils {
    /**
     * Runtime name for the class.
     */
    static CLASS_NAME = "IotaNftUtils";
    /**
     * Convert an NFT id to an object id.
     * @param nftIdUrn The NFT id to convert in urn format.
     * @returns The object id.
     * @throws GeneralError if the NFT id is invalid.
     */
    static nftIdToObjectId(nftIdUrn) {
        // The nftId is made up from nft:iota:devnet:packageId:objectid
        const nftUrn = Urn.fromValidString(nftIdUrn);
        const parts = nftUrn.parts();
        if (parts.length !== 5) {
            throw new GeneralError(IotaNftUtils.CLASS_NAME, "invalidNftIdFormat", {
                id: nftIdUrn
            });
        }
        return parts[4];
    }
    /**
     * Convert an NFT id to a package id.
     * @param nftIdUrn The NFT id to convert in urn format.
     * @returns The package id.
     * @throws GeneralError if the NFT id is invalid.
     */
    static nftIdToPackageId(nftIdUrn) {
        // The nftId is made up from nft:iota:devnet:packageId:objectid
        const nftUrn = Urn.fromValidString(nftIdUrn);
        const parts = nftUrn.parts();
        if (parts.length !== 5) {
            throw new GeneralError(IotaNftUtils.CLASS_NAME, "invalidNftIdFormat", {
                id: nftIdUrn
            });
        }
        return parts[3];
    }
}

/**
 * Class for performing NFT operations on IOTA.
 */
class IotaNftConnector {
    /**
     * The namespace supported by the nft connector.
     */
    static NAMESPACE = "iota";
    /**
     * Runtime name for the class.
     */
    CLASS_NAME = "IotaNftConnector";
    /**
     * Gas budget for transactions.
     * @internal
     */
    _gasBudget;
    /**
     * Connector for vault operations.
     * @internal
     */
    _vaultConnector;
    /**
     * Connector for wallet operations.
     * @internal
     */
    _walletConnector;
    /**
     * The configuration for the connector.
     * @internal
     */
    _config;
    /**
     * The IOTA client.
     * @internal
     */
    _client;
    /**
     * The name of the contract to use.
     * @internal
     */
    _contractName;
    /**
     * The package ID of the deployed NFT Move module.
     * @internal
     */
    _deployedPackageId;
    /**
     * The logging connector.
     * @internal
     */
    _logging;
    /**
     * Create a new instance of IotaNftConnector.
     * @param options The options for the connector.
     */
    constructor(options) {
        Guards.object(this.CLASS_NAME, "options", options);
        Guards.object(this.CLASS_NAME, "options.config", options.config);
        Guards.object(this.CLASS_NAME, "options.config.clientOptions", options.config.clientOptions);
        this._vaultConnector = VaultConnectorFactory.get(options.vaultConnectorType ?? "vault");
        this._walletConnector = WalletConnectorFactory.get(options.walletConnectorType ?? "wallet");
        this._logging = LoggingConnectorFactory.getIfExists(options?.loggingConnectorType ?? "logging");
        this._config = options.config;
        this._contractName = this._config.contractName ?? "nft";
        Guards.stringValue(this.CLASS_NAME, "this._contractName", this._contractName);
        this._gasBudget = this._config.gasBudget ?? 1_000_000_000;
        Guards.number(this.CLASS_NAME, "this._gasBudget", this._gasBudget);
        if (this._gasBudget <= 0) {
            throw new GeneralError(this.CLASS_NAME, "invalidGasBudget", { gasBudget: this._gasBudget });
        }
        Iota.populateConfig(this._config);
        this._client = Iota.createClient(this._config);
    }
    /**
     * Bootstrap the NFT contract.
     * @param nodeIdentity The identity of the node.
     * @param nodeLoggingConnectorType The node logging connector type, defaults to "node-logging".
     * @param componentState The component state.
     * @param componentState.contractDeployments The contract deployments.
     * @returns void.
     */
    async start(nodeIdentity, nodeLoggingConnectorType, componentState) {
        const nodeLogging = LoggingConnectorFactory.getIfExists(nodeLoggingConnectorType ?? "node-logging");
        try {
            const contractData = compiledModulesJson[this._contractName];
            if (!contractData) {
                throw new GeneralError(this.CLASS_NAME, "contractDataNotFound", {
                    contractName: this._contractName
                });
            }
            // Convert base64 package(s) to bytes
            let compiledModules;
            if (Is.arrayValue(contractData.package)) {
                compiledModules = contractData.package.map((pkg) => Array.from(Converter.base64ToBytes(pkg)));
            }
            else {
                compiledModules = [Array.from(Converter.base64ToBytes(contractData.package))];
            }
            const contractDeployments = componentState?.contractDeployments ?? {};
            if (Is.stringValue(contractDeployments[contractData.packageId])) {
                this._deployedPackageId = contractDeployments[contractData.packageId];
                // Check if package exists on the network with a deployed package id
                const packageExists = await Iota.packageExistsOnNetwork(this._client, contractDeployments[contractData.packageId]);
                if (packageExists) {
                    await nodeLogging?.log({
                        level: "info",
                        source: this.CLASS_NAME,
                        ts: Date.now(),
                        message: "contractAlreadyDeployed",
                        data: {
                            network: this._config.network,
                            nodeIdentity,
                            contractId: contractData.packageId,
                            deployedPackageId: contractDeployments[contractData.packageId]
                        }
                    });
                    return;
                }
            }
            // Package does not exist, proceed to deploy
            await nodeLogging?.log({
                level: "info",
                source: this.CLASS_NAME,
                ts: Date.now(),
                message: "contractDeploymentStarted",
                data: { network: this._config.network, nodeIdentity, contractId: contractData.packageId }
            });
            const txb = new Transaction();
            txb.setGasBudget(this._gasBudget);
            // Publish the compiled modules
            const [upgradeCap] = txb.publish({ modules: compiledModules, dependencies: ["0x1", "0x2"] });
            const controllerAddress = await this.getPackageControllerAddress(nodeIdentity);
            // Transfer the upgrade capability to the controller
            txb.transferObjects([upgradeCap], txb.pure.address(controllerAddress));
            const result = await Iota.prepareAndPostTransaction(this._config, this._vaultConnector, nodeLogging, nodeIdentity, this._client, controllerAddress, txb, {
                dryRunLabel: this._config.enableCostLogging ? "deploy" : undefined
            });
            if (result.effects?.status?.status !== "success") {
                throw new GeneralError(this.CLASS_NAME, "deployTransactionFailed", {
                    error: result.effects?.status?.error
                });
            }
            // Find the package object (owner field will be Immutable)
            const packageObject = result.effects?.created?.find(obj => obj.owner === "Immutable");
            const deployedPackageId = packageObject?.reference?.objectId;
            if (!Is.stringValue(deployedPackageId)) {
                throw new GeneralError(this.CLASS_NAME, "packageIdNotFound", {
                    packageId: deployedPackageId
                });
            }
            this._deployedPackageId = deployedPackageId;
            if (componentState) {
                componentState.contractDeployments ??= {};
                componentState.contractDeployments[contractData.packageId] = deployedPackageId;
            }
            await nodeLogging?.log({
                level: "info",
                source: this.CLASS_NAME,
                ts: Date.now(),
                message: "contractDeploymentCompleted",
                data: {
                    contractId: contractData.packageId,
                    deployedPackageId: contractDeployments[contractData.packageId]
                }
            });
        }
        catch (error) {
            await nodeLogging?.log({
                level: "error",
                source: this.CLASS_NAME,
                ts: Date.now(),
                message: "startFailed",
                error: BaseError.fromError(error),
                data: { network: this._config.network, nodeIdentity }
            });
            throw error;
        }
    }
    /**
     * Mint an NFT.
     * @param controllerIdentity The identity of the user to access the vault keys.
     * @param tag The tag for the NFT.
     * @param immutableMetadata The immutable metadata for the NFT.
     * @param metadata The metadata for the NFT.
     * @returns The id of the created NFT in urn format.
     */
    async mint(controllerIdentity, tag, immutableMetadata, metadata) {
        this.ensureStarted();
        Guards.stringValue(this.CLASS_NAME, "controllerIdentity", controllerIdentity);
        Guards.stringValue(this.CLASS_NAME, "tag", tag);
        try {
            const txb = new Transaction();
            txb.setGasBudget(this._gasBudget);
            const walletAddressIndex = this._config.walletAddressIndex ?? 0;
            const addresses = await this._walletConnector.getAddresses(controllerIdentity, 0, walletAddressIndex, 1);
            const address = addresses[0];
            const metadataString = metadata ? JSON.stringify(metadata) : "";
            const immutableMetadataString = immutableMetadata ? JSON.stringify(immutableMetadata) : "";
            const packageId = this._deployedPackageId;
            const moduleName = this.getModuleName();
            // Call the mint function from our Move contract
            txb.moveCall({
                target: `${packageId}::${moduleName}::mint`,
                arguments: [
                    txb.pure.string(immutableMetadataString),
                    txb.pure.string(tag),
                    txb.pure.address(address),
                    txb.pure.string(metadataString),
                    txb.pure.string(controllerIdentity),
                    txb.pure.string(controllerIdentity)
                ]
            });
            const result = await Iota.prepareAndPostTransaction(this._config, this._vaultConnector, this._logging, controllerIdentity, this._client, address, txb, {
                dryRunLabel: this._config.enableCostLogging ? "mint" : undefined
            });
            const createdObjectId = result.effects?.created?.[0]?.reference?.objectId;
            if (!Is.stringValue(createdObjectId)) {
                throw new GeneralError(this.CLASS_NAME, "failedToGetNftId", undefined);
            }
            const urn = new Urn("nft", `${IotaNftConnector.NAMESPACE}:${this._config.network}:${this._deployedPackageId}:${createdObjectId}`);
            return urn.toString();
        }
        catch (error) {
            throw new GeneralError(this.CLASS_NAME, "mintingFailed", undefined, Iota.extractPayloadError(error));
        }
    }
    /**
     * Resolve an NFT to get its details.
     * @param nftId The id of the NFT to resolve.
     * @returns The NFT details.
     */
    async resolve(nftId) {
        Guards.stringValue(this.CLASS_NAME, "nftId", nftId);
        try {
            const objectId = IotaNftUtils.nftIdToObjectId(nftId);
            const object = await this._client.getObject({
                id: objectId,
                options: { showContent: true, showType: true, showOwner: true }
            });
            if (!object.data?.content) {
                throw new GeneralError(this.CLASS_NAME, "nftNotFound", { nftId });
            }
            // Because object.data.content is of type IotaParsedData
            const parsedData = object.data.content;
            const content = parsedData.fields;
            let immutableMetadata;
            if (content.immutable_metadata) {
                try {
                    immutableMetadata = JSON.parse(content.immutable_metadata);
                }
                catch (error) {
                    throw new GeneralError(this.CLASS_NAME, "invalidImmutableMetadata", { nftId }, error);
                }
            }
            // Parse mutable metadata if it's JSON
            let metadata;
            if (content.metadata) {
                try {
                    metadata = JSON.parse(content.metadata);
                }
                catch (error) {
                    throw new GeneralError(this.CLASS_NAME, "invalidMetadata", { nftId }, error);
                }
            }
            return {
                issuer: content.issuerIdentity?.toString(),
                owner: content.ownerIdentity?.toString(),
                tag: content.tag?.toString(),
                immutableMetadata,
                metadata
            };
        }
        catch (error) {
            throw new GeneralError(this.CLASS_NAME, "resolvingFailed", undefined, Iota.extractPayloadError(error));
        }
    }
    /**
     * Burn an NFT.
     * @param controllerIdentity The controller of the NFT who can make changes.
     * @param id The id of the NFT to burn in urn format.
     * @returns void.
     */
    async burn(controllerIdentity, id) {
        Guards.stringValue(this.CLASS_NAME, "controllerIdentity", controllerIdentity);
        Urn.guard(this.CLASS_NAME, "id", id);
        const urnParsed = Urn.fromValidString(id);
        if (urnParsed.namespaceMethod() !== IotaNftConnector.NAMESPACE) {
            throw new GeneralError(this.CLASS_NAME, "namespaceMismatch", {
                namespace: IotaNftConnector.NAMESPACE,
                id
            });
        }
        try {
            const txb = new Transaction();
            txb.setGasBudget(this._gasBudget);
            const objectId = IotaNftUtils.nftIdToObjectId(id);
            const packageId = IotaNftUtils.nftIdToPackageId(id);
            const moduleName = this.getModuleName();
            txb.moveCall({
                target: `${packageId}::${moduleName}::burn`,
                arguments: [txb.object(objectId)]
            });
            const object = await this._client.getObject({
                id: objectId,
                options: { showContent: true, showType: true, showOwner: true }
            });
            const ownerAddress = this.getOwnerAddress(id, object);
            const result = await Iota.prepareAndPostTransaction(this._config, this._vaultConnector, this._logging, controllerIdentity, this._client, ownerAddress, txb, {
                dryRunLabel: this._config.enableCostLogging ? "burn" : undefined
            });
            if (result.effects?.status?.status !== "success") {
                throw new GeneralError(this.CLASS_NAME, "burningFailed", {
                    error: result.effects?.status?.error
                });
            }
        }
        catch (error) {
            throw new GeneralError(this.CLASS_NAME, "burningFailed", undefined, Iota.extractPayloadError(error));
        }
    }
    /**
     * Transfer an NFT to a new owner.
     * @param controller The identity of the user to access the vault keys.
     * @param nftId The id of the NFT to transfer.
     * @param recipientIdentity The recipient identity for the NFT.
     * @param recipientAddress The recipient address for the NFT.
     * @param metadata Optional metadata to update during transfer.
     * @returns void.
     */
    async transfer(controller, nftId, recipientIdentity, recipientAddress, metadata) {
        Guards.stringValue(this.CLASS_NAME, "controller", controller);
        Guards.stringValue(this.CLASS_NAME, "nftId", nftId);
        Guards.stringValue(this.CLASS_NAME, "recipientIdentity", recipientIdentity);
        Guards.stringValue(this.CLASS_NAME, "recipientAddress", recipientAddress);
        if (!Is.undefined(metadata)) {
            Guards.object(this.CLASS_NAME, "metadata", metadata);
        }
        const urnParsed = Urn.fromValidString(nftId);
        if (urnParsed.namespaceMethod() !== IotaNftConnector.NAMESPACE) {
            throw new GeneralError(this.CLASS_NAME, "namespaceMismatch", {
                namespace: IotaNftConnector.NAMESPACE,
                id: nftId
            });
        }
        try {
            // Verify ownership before attempting transfer
            const currentNft = await this.resolve(nftId);
            if (currentNft.owner !== controller) {
                throw new GeneralError(this.CLASS_NAME, "transferFailed", {
                    currentOwner: currentNft.owner,
                    controller
                });
            }
            const txb = new Transaction();
            txb.setGasBudget(this._gasBudget);
            const objectId = IotaNftUtils.nftIdToObjectId(nftId);
            const packageId = IotaNftUtils.nftIdToPackageId(nftId);
            const moduleName = this.getModuleName();
            const object = await this._client.getObject({
                id: objectId,
                options: { showContent: true, showType: true, showOwner: true }
            });
            const ownerAddress = this.getOwnerAddress(nftId, object);
            if (!Is.undefined(metadata)) {
                // If metadata is provided, use transfer_with_metadata
                const metadataString = JSON.stringify(metadata);
                txb.moveCall({
                    target: `${packageId}::${moduleName}::transfer_with_metadata`,
                    arguments: [
                        txb.object(objectId),
                        txb.pure.address(recipientAddress),
                        txb.pure.string(recipientIdentity),
                        txb.pure.string(metadataString)
                    ]
                });
            }
            else {
                txb.moveCall({
                    target: `${packageId}::${moduleName}::transfer`,
                    arguments: [
                        txb.object(objectId),
                        txb.pure.address(recipientAddress),
                        txb.pure.string(recipientIdentity)
                    ]
                });
            }
            const result = await Iota.prepareAndPostTransaction(this._config, this._vaultConnector, this._logging, controller, this._client, ownerAddress, txb, {
                dryRunLabel: this._config.enableCostLogging ? "transfer" : undefined
            });
            if (result.effects?.status?.status !== "success") {
                throw new GeneralError(this.CLASS_NAME, "transferFailed", {
                    error: result.effects?.status?.error
                });
            }
        }
        catch (error) {
            throw new GeneralError(this.CLASS_NAME, "transferFailed", undefined, Iota.extractPayloadError(error));
        }
    }
    /**
     * Update the mutable data of an NFT.
     * @param controllerIdentity The controller of the NFT who can make changes.
     * @param id The id of the NFT to update in urn format.
     * @param metadata The new metadata for the NFT.
     * @returns void.
     */
    async update(controllerIdentity, id, metadata) {
        this.ensureStarted();
        Guards.stringValue(this.CLASS_NAME, "controllerIdentity", controllerIdentity);
        Urn.guard(this.CLASS_NAME, "id", id);
        Guards.object(this.CLASS_NAME, "metadata", metadata);
        const urnParsed = Urn.fromValidString(id);
        if (urnParsed.namespaceMethod() !== IotaNftConnector.NAMESPACE) {
            throw new GeneralError(this.CLASS_NAME, "namespaceMismatch", {
                namespace: IotaNftConnector.NAMESPACE,
                id
            });
        }
        try {
            const txb = new Transaction();
            txb.setGasBudget(this._gasBudget);
            const objectId = IotaNftUtils.nftIdToObjectId(id);
            // Convert metadata to string for storage
            const metadataString = JSON.stringify(metadata);
            const packageId = this._deployedPackageId;
            const moduleName = this.getModuleName();
            txb.moveCall({
                target: `${packageId}::${moduleName}::update_metadata`,
                arguments: [txb.object(objectId), txb.pure.string(metadataString)]
            });
            const object = await this._client.getObject({
                id: objectId,
                options: { showContent: true, showType: true, showOwner: true }
            });
            const ownerAddress = this.getOwnerAddress(id, object);
            const result = await Iota.prepareAndPostTransaction(this._config, this._vaultConnector, this._logging, controllerIdentity, this._client, ownerAddress, txb, {
                dryRunLabel: this._config.enableCostLogging ? "update" : undefined
            });
            if (result.effects?.status?.status !== "success") {
                throw new GeneralError(this.CLASS_NAME, "updateFailed", {
                    error: result.effects?.status?.error
                });
            }
        }
        catch (error) {
            throw new GeneralError(this.CLASS_NAME, "updateFailed", undefined, Iota.extractPayloadError(error));
        }
    }
    /**
     * Get the package controller's address.
     * @param identity The identity of the user to access the vault keys.
     * @returns The controller's address.
     * @internal
     */
    async getPackageControllerAddress(identity) {
        const addressIndex = this._config.packageControllerAddressIndex ?? 0;
        const addresses = await this._walletConnector.getAddresses(identity, 0, addressIndex, 1);
        return addresses[0];
    }
    /**
     * Ensure that the connector is bootstrapped.
     * @throws GeneralError if the connector is not started.
     * @internal
     */
    ensureStarted() {
        if (!this._deployedPackageId) {
            throw new GeneralError(this.CLASS_NAME, "connectorNotStarted", {
                packageId: this._deployedPackageId
            });
        }
    }
    /**
     * Get the module name based on the contract name.
     * @returns The module name in snake_case.
     * @internal
     */
    getModuleName() {
        return StringHelper.snakeCase(this._contractName);
    }
    /**
     * Get the owner address of an NFT.
     * @param nftId The id of the NFT.
     * @param object The object to get the owner from.
     * @returns The owner address.
     * @internal
     */
    getOwnerAddress(nftId, object) {
        const owner = object?.data?.owner;
        if (Is.object(owner)) {
            if ("AddressOwner" in owner) {
                return owner.AddressOwner;
            }
            else if ("ObjectOwner" in owner) {
                return owner.ObjectOwner;
            }
            // Shared ownership is handled as null
        }
        throw new GeneralError(this.CLASS_NAME, "nftOwnerNftFound", { nftId });
    }
}

export { IotaNftConnector, IotaNftUtils };
