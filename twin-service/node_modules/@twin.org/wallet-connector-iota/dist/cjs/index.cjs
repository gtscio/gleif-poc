'use strict';

var faucet = require('@iota/iota-sdk/faucet');
var core = require('@twin.org/core');
var dltIota = require('@twin.org/dlt-iota');
var crypto = require('@twin.org/crypto');
var vaultModels = require('@twin.org/vault-models');
var walletModels = require('@twin.org/wallet-models');

/**
 * Class for performing faucet operations on IOTA.
 */
class IotaFaucetConnector {
    /**
     * The namespace supported by the faucet connector.
     */
    static NAMESPACE = "iota";
    /**
     * Runtime name for the class.
     */
    CLASS_NAME = "IotaFaucetConnector";
    /**
     * The configuration to use for IOTA operations.
     * @internal
     */
    _config;
    /**
     * The IOTA client.
     * @internal
     */
    _client;
    /**
     * Create a new instance of IotaFaucetConnector.
     * @param options The options for the connector.
     */
    constructor(options) {
        core.Guards.object(this.CLASS_NAME, "options", options);
        core.Guards.object(this.CLASS_NAME, "options.config", options.config);
        core.Guards.object(this.CLASS_NAME, "options.config.clientOptions", options.config.clientOptions);
        core.Guards.string(this.CLASS_NAME, "options.config.endpoint", options.config.endpoint);
        this._config = options.config;
        dltIota.Iota.populateConfig(this._config);
        this._client = dltIota.Iota.createClient(this._config);
    }
    /**
     * Fund an address with IOTA from the faucet.
     * @param identity The identity of the user to access the vault keys.
     * @param address The address to fund.
     * @param timeoutInSeconds The timeout in seconds to wait for the funding to complete.
     * @returns The amount funded.
     */
    async fundAddress(identity, address, timeoutInSeconds = 60) {
        core.Guards.stringValue(this.CLASS_NAME, "identity", identity);
        core.Guards.stringValue(this.CLASS_NAME, "address", address);
        try {
            const initialBalance = await this._client.getBalance({
                owner: address
            });
            const response = await faucet.requestIotaFromFaucetV0({
                host: this._config.endpoint,
                recipient: address
            });
            if (response?.error) {
                throw new core.GeneralError(this.CLASS_NAME, "fundingFailed", undefined, response.error);
            }
            // Poll for balance change
            const numTries = Math.ceil(timeoutInSeconds / 5);
            for (let i = 0; i < numTries; i++) {
                const newBalance = await this._client.getBalance({
                    owner: address
                });
                if (BigInt(newBalance.totalBalance) > BigInt(initialBalance.totalBalance)) {
                    return BigInt(newBalance.totalBalance) - BigInt(initialBalance.totalBalance);
                }
                if (i < numTries - 1) {
                    await new Promise(resolve => setTimeout(resolve, 5000));
                }
            }
        }
        catch (error) {
            throw new core.GeneralError(this.CLASS_NAME, "fundingFailed", undefined, dltIota.Iota.extractPayloadError(error));
        }
        return 0n;
    }
}

/**
 * Class for performing wallet operations on IOTA.
 */
class IotaWalletConnector {
    /**
     * The namespace supported by the wallet connector.
     */
    static NAMESPACE = "iota";
    /**
     * Runtime name for the class.
     */
    CLASS_NAME = "IotaWalletConnector";
    /**
     * The configuration to use for IOTA operations.
     * @internal
     */
    _config;
    /**
     * The vault for the mnemonic or seed.
     * @internal
     */
    _vaultConnector;
    /**
     * The IOTA faucet.
     * @internal
     */
    _faucetConnector;
    /**
     * The IOTA client.
     * @internal
     */
    _client;
    /**
     * Create a new instance of IOTA Wallet Connector.
     * @param options The options for the wallet connector.
     */
    constructor(options) {
        core.Guards.object(this.CLASS_NAME, "options", options);
        core.Guards.object(this.CLASS_NAME, "options.config", options.config);
        this._vaultConnector = vaultModels.VaultConnectorFactory.get(options?.vaultConnectorType ?? "vault");
        this._faucetConnector = walletModels.FaucetConnectorFactory.getIfExists(options?.faucetConnectorType ?? "faucet");
        this._config = options.config;
        dltIota.Iota.populateConfig(this._config);
        this._client = dltIota.Iota.createClient(this._config);
    }
    /**
     * Create a new wallet.
     * @param identity The identity of the user to access the vault keys.
     * @returns Nothing.
     */
    async create(identity) {
        core.Guards.stringValue(this.CLASS_NAME, "identity", identity);
        const mnemonic = crypto.Bip39.randomMnemonic();
        await this._vaultConnector.setSecret(dltIota.Iota.buildMnemonicKey(identity, this._config.vaultMnemonicId), mnemonic);
        const seed = crypto.Bip39.mnemonicToSeed(mnemonic);
        await this._vaultConnector.setSecret(dltIota.Iota.buildSeedKey(identity, this._config.vaultSeedId), core.Converter.bytesToBase64(seed));
    }
    /**
     * Get the addresses for the identity.
     * @param identity The identity to get the addresses for.
     * @param accountIndex The account index to get the addresses for.
     * @param startAddressIndex The start index for the addresses.
     * @param count The number of addresses to generate.
     * @param isInternal Whether the addresses are internal.
     * @returns The addresses.
     */
    async getAddresses(identity, accountIndex, startAddressIndex, count, isInternal) {
        core.Guards.stringValue(this.CLASS_NAME, "identity", identity);
        const seed = await dltIota.Iota.getSeed(this._config, this._vaultConnector, identity);
        return dltIota.Iota.getAddresses(seed, this._config.coinType ?? dltIota.Iota.DEFAULT_COIN_TYPE, accountIndex, startAddressIndex, count, isInternal);
    }
    /**
     * Get the balance for the given address.
     * @param identity The identity of the user to access the vault keys.
     * @param address The address to get the balance for.
     * @returns The balance.
     */
    async getBalance(identity, address) {
        core.Guards.stringValue(this.CLASS_NAME, "identity", identity);
        core.Guards.stringValue(this.CLASS_NAME, "address", address);
        const balance = await this._client.getBalance({
            owner: address
        });
        return BigInt(balance.totalBalance);
    }
    /**
     * Ensure the balance for the given address is at least the given amount.
     * @param identity The identity of the user to access the vault keys.
     * @param address The address to ensure the balance for.
     * @param ensureBalance The minimum balance to ensure.
     * @param timeoutInSeconds Optional timeout in seconds, defaults to 10 seconds.
     * @returns True if the balance is at least the given amount, false otherwise.
     */
    async ensureBalance(identity, address, ensureBalance, timeoutInSeconds) {
        core.Guards.stringValue(this.CLASS_NAME, "identity", identity);
        core.Guards.stringValue(this.CLASS_NAME, "address", address);
        core.Guards.bigint(this.CLASS_NAME, "ensureBalance", ensureBalance);
        if (this._faucetConnector) {
            let retryCount = 10;
            let currentBalance = await this.getBalance(identity, address);
            while (currentBalance < ensureBalance && retryCount > 0) {
                const addedBalance = await this._faucetConnector.fundAddress(identity, address, timeoutInSeconds);
                if (addedBalance === 0n) {
                    return false;
                }
                currentBalance += addedBalance;
                if (currentBalance < ensureBalance) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    retryCount--;
                }
            }
            return currentBalance >= ensureBalance;
        }
        return false;
    }
    /**
     * Transfer an amount from one address to another.
     * @param identity The identity of the user to access the vault keys.
     * @param addressSource The source address to transfer from.
     * @param addressDest The destination address to transfer to.
     * @param amount The amount to transfer.
     * @returns The transaction digest.
     */
    async transfer(identity, addressSource, addressDest, amount) {
        core.Guards.stringValue(this.CLASS_NAME, "identity", identity);
        core.Guards.stringValue(this.CLASS_NAME, "addressSource", addressSource);
        core.Guards.stringValue(this.CLASS_NAME, "addressDest", addressDest);
        core.Guards.bigint(this.CLASS_NAME, "amount", amount);
        try {
            const result = await dltIota.Iota.prepareAndPostValueTransaction(this._config, this._vaultConnector, undefined, identity, this._client, addressSource, amount, addressDest);
            return result.digest;
        }
        catch (error) {
            throw new core.GeneralError(this.CLASS_NAME, "transferFailed", undefined, dltIota.Iota.extractPayloadError(error));
        }
    }
}

exports.IotaFaucetConnector = IotaFaucetConnector;
exports.IotaWalletConnector = IotaWalletConnector;
