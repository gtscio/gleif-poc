import { Factory, Guards, Is, StringHelper, I18n } from '@twin.org/core';

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Factory for creating logging connectors.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const LoggingConnectorFactory = Factory.createFactory("logging");

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class for performing logging operations on multiple connectors.
 */
class MultiLoggingConnector {
    /**
     * The namespace for the logging connector.
     */
    static NAMESPACE = "multi";
    /**
     * Runtime name for the class.
     */
    CLASS_NAME = "MultiLoggingConnector";
    /**
     * The connectors to send the log entries to.
     * @internal
     */
    _loggingConnectors;
    /**
     * The log levels to display, will default to all.
     * @internal
     */
    _levels;
    /**
     * Create a new instance of MultiLoggingConnector.
     * @param options The options for the connector.
     */
    constructor(options) {
        Guards.object(this.CLASS_NAME, "options", options);
        Guards.arrayValue(this.CLASS_NAME, "options.loggingConnectorTypes", options.loggingConnectorTypes);
        this._levels = options?.config?.levels ?? ["debug", "info", "warn", "error", "trace"];
        this._loggingConnectors = options.loggingConnectorTypes.map(t => LoggingConnectorFactory.get(t));
    }
    /**
     * Log an entry to the connector.
     * @param logEntry The entry to log.
     * @returns Nothing.
     */
    async log(logEntry) {
        Guards.object(this.CLASS_NAME, "logEntry", logEntry);
        if (this._levels.includes(logEntry.level)) {
            logEntry.ts ??= Date.now();
            await Promise.allSettled(this._loggingConnectors.map(async (loggingConnector) => loggingConnector.log(logEntry)));
        }
    }
    /**
     * Query the log entries.
     * @param conditions The conditions to match for the entities.
     * @param sortProperties The optional sort order.
     * @param properties The optional keys to return, defaults to all.
     * @param cursor The cursor to request the next page of entities.
     * @param pageSize The maximum number of entities in a page.
     * @returns All the entities for the storage matching the conditions,
     * and a cursor which can be used to request more entities.
     */
    async query(conditions, sortProperties, properties, cursor, pageSize) {
        // See if we can find a connector that supports querying.
        // If it throws anything other than not implemented, we should throw it.
        for (const loggingConnector of this._loggingConnectors) {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            if (Is.function(loggingConnector.query)) {
                return loggingConnector.query(conditions, sortProperties, properties, cursor, pageSize);
            }
        }
        return {
            entities: []
        };
    }
}

/**
 * Class for performing logging operations to nowhere.
 */
class SilentLoggingConnector {
    /**
     * The namespace for the logging connector.
     */
    static NAMESPACE = "silent";
    /**
     * Runtime name for the class.
     */
    CLASS_NAME = "SilentLoggingConnector";
    /**
     * Log an entry to the connector.
     * @param logEntry The entry to log.
     * @returns Nothing.
     */
    async log(logEntry) { }
    /**
     * Query the log entries.
     * @param conditions The conditions to match for the entities.
     * @param sortProperties The optional sort order.
     * @param properties The optional keys to return, defaults to all.
     * @param cursor The cursor to request the next page of entities.
     * @param pageSize The maximum number of entities in a page.
     * @returns All the entities for the storage matching the conditions,
     * and a cursor which can be used to request more entities.
     */
    async query(conditions, sortProperties, properties, cursor, pageSize) {
        return {
            entities: []
        };
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Helper class for log entry operations.
 */
class LogEntryHelper {
    /**
     * Translate the log entry.
     * @param logEntry The log entry.
     * @returns The translated log entry if a translation can be found.
     */
    static translate(logEntry) {
        if (Is.stringValue(logEntry.level) && Is.stringValue(logEntry.source)) {
            const sourceMessage = `${logEntry.level}.${StringHelper.camelCase(logEntry.source)}.${logEntry.message}`;
            if (I18n.hasMessage(sourceMessage)) {
                return I18n.formatMessage(sourceMessage, logEntry.data);
            }
        }
        if (Is.stringValue(logEntry.source)) {
            const sourceMessage = `${StringHelper.camelCase(logEntry.source)}.${logEntry.message}`;
            if (I18n.hasMessage(sourceMessage)) {
                return I18n.formatMessage(sourceMessage, logEntry.data);
            }
        }
        if (I18n.hasMessage(logEntry.message)) {
            return I18n.formatMessage(logEntry.message, logEntry.data);
        }
    }
}

export { LogEntryHelper, LoggingConnectorFactory, MultiLoggingConnector, SilentLoggingConnector };
