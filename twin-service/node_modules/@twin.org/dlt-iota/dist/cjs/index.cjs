'use strict';

var bcs = require('@iota/bcs');
var client = require('@iota/iota-sdk/client');
var ed25519 = require('@iota/iota-sdk/keypairs/ed25519');
var transactions = require('@iota/iota-sdk/transactions');
var core = require('@twin.org/core');
var crypto = require('@twin.org/crypto');
var web = require('@twin.org/web');

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class for performing operations on IOTA.
 */
class Iota {
    /**
     * Default name for the mnemonic secret.
     */
    static DEFAULT_MNEMONIC_SECRET_NAME = "mnemonic";
    /**
     * Default name for the seed secret.
     */
    static DEFAULT_SEED_SECRET_NAME = "seed";
    /**
     * Default coin type.
     */
    static DEFAULT_COIN_TYPE = 4218;
    /**
     * Default scan range.
     */
    static DEFAULT_SCAN_RANGE = 1000;
    /**
     * Default inclusion timeout.
     */
    static DEFAULT_INCLUSION_TIMEOUT = 60;
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "Iota";
    /**
     * Create a new IOTA client.
     * @param config The configuration.
     * @returns The client instance.
     */
    static createClient(config) {
        core.Guards.object(Iota._CLASS_NAME, "config", config);
        core.Guards.object(Iota._CLASS_NAME, "config.clientOptions", config.clientOptions);
        core.Guards.string(Iota._CLASS_NAME, "config.clientOptions.url", config.clientOptions.url);
        return new client.IotaClient(config.clientOptions);
    }
    /**
     * Create configuration using defaults where necessary.
     * @param config The configuration to populate.
     */
    static populateConfig(config) {
        core.Guards.object(Iota._CLASS_NAME, "config.clientOptions", config.clientOptions);
        config.vaultMnemonicId ??= Iota.DEFAULT_MNEMONIC_SECRET_NAME;
        config.vaultSeedId ??= Iota.DEFAULT_SEED_SECRET_NAME;
        config.coinType ??= Iota.DEFAULT_COIN_TYPE;
        config.inclusionTimeoutSeconds ??= Iota.DEFAULT_INCLUSION_TIMEOUT;
    }
    /**
     * Get addresses for the identity.
     * @param seed The seed to use for generating addresses.
     * @param coinType The coin type to use.
     * @param accountIndex The account index to get the addresses for.
     * @param startAddressIndex The start index for the addresses.
     * @param count The number of addresses to generate.
     * @param isInternal Whether the addresses are internal.
     * @returns The list of addresses.
     */
    static getAddresses(seed, coinType, accountIndex, startAddressIndex, count, isInternal) {
        core.Guards.integer(Iota._CLASS_NAME, "coinType", coinType);
        core.Guards.integer(Iota._CLASS_NAME, "accountIndex", accountIndex);
        core.Guards.integer(Iota._CLASS_NAME, "startAddressIndex", startAddressIndex);
        core.Guards.integer(Iota._CLASS_NAME, "count", count);
        const addresses = [];
        for (let i = startAddressIndex; i < startAddressIndex + count; i++) {
            // Derive the keypair using the seed
            const keyPair = crypto.Bip44.keyPair(seed, crypto.KeyType.Ed25519, coinType ?? Iota.DEFAULT_COIN_TYPE, accountIndex, isInternal ?? false, i);
            const keypair = ed25519.Ed25519Keypair.fromSecretKey(keyPair.privateKey);
            addresses.push(keypair.getPublicKey().toIotaAddress());
        }
        return addresses;
    }
    /**
     * Get a key pair for the specified index.
     * @param seed The seed to use for generating the key pair.
     * @param coinType The coin type to use.
     * @param accountIndex The account index to get the key pair for.
     * @param addressIndex The address index to get the key pair for.
     * @param isInternal Whether the address is internal.
     * @returns The key pair containing private key and public key.
     */
    static getKeyPair(seed, coinType, accountIndex, addressIndex, isInternal) {
        core.Guards.integer(Iota._CLASS_NAME, "coinType", coinType);
        core.Guards.integer(Iota._CLASS_NAME, "accountIndex", accountIndex);
        core.Guards.integer(Iota._CLASS_NAME, "addressIndex", addressIndex);
        const keyPair = crypto.Bip44.keyPair(seed, crypto.KeyType.Ed25519, coinType ?? Iota.DEFAULT_COIN_TYPE, accountIndex, isInternal ?? false, addressIndex);
        return keyPair;
    }
    /**
     * Prepare and post a transaction.
     * @param config The configuration.
     * @param vaultConnector The vault connector.
     * @param loggingConnector The logging connector.
     * @param identity The identity of the user to access the vault keys.
     * @param client The client instance.
     * @param source The source address.
     * @param amount The amount to transfer.
     * @param recipient The recipient address.
     * @param options The transaction options.
     * @returns The transaction result.
     */
    static async prepareAndPostValueTransaction(config, vaultConnector, loggingConnector, identity, client, source, amount, recipient, options) {
        try {
            const txb = new transactions.Transaction();
            const [coin] = txb.splitCoins(txb.gas, [txb.pure.u64(amount)]);
            txb.transferObjects([coin], txb.pure.address(recipient));
            // Check if gas station configuration is present
            if (core.Is.object(config.gasStation)) {
                return await this.prepareAndPostGasStationTransaction(config, vaultConnector, identity, client, source, txb);
            }
            const result = await this.prepareAndPostTransaction(config, vaultConnector, loggingConnector, identity, client, source, txb, options);
            return result;
        }
        catch (error) {
            throw new core.GeneralError(Iota._CLASS_NAME, "valueTransactionFailed", undefined, Iota.extractPayloadError(error));
        }
    }
    /**
     * Prepare and post a transaction.
     * @param config The configuration.
     * @param vaultConnector The vault connector.
     * @param loggingConnector The logging connector.
     * @param identity The identity of the user to access the vault keys.
     * @param client The client instance.
     * @param owner The owner of the address.
     * @param transaction The transaction to execute.
     * @param options The transaction options.
     * @returns The transaction response.
     */
    static async prepareAndPostTransaction(config, vaultConnector, loggingConnector, identity, client, owner, transaction, options) {
        // Check if gas station configuration is present
        if (core.Is.object(config.gasStation)) {
            return this.prepareAndPostGasStationTransaction(config, vaultConnector, identity, client, owner, transaction, options);
        }
        // Traditional transaction flow
        // Dry run the transaction if cost logging is enabled to get the gas and storage costs
        if (core.Is.stringValue(options?.dryRunLabel)) {
            await Iota.dryRunTransaction(client, loggingConnector, transaction, owner, options.dryRunLabel);
        }
        const seed = await this.getSeed(config, vaultConnector, identity);
        const addressKeyPair = Iota.findAddress(config.maxAddressScanRange ?? Iota.DEFAULT_SCAN_RANGE, config.coinType ?? Iota.DEFAULT_COIN_TYPE, seed, owner);
        const keypair = ed25519.Ed25519Keypair.fromSecretKey(addressKeyPair.privateKey);
        try {
            const response = await client.signAndExecuteTransaction({
                transaction,
                signer: keypair,
                requestType: "WaitForLocalExecution",
                options: {
                    showEffects: options?.showEffects ?? true,
                    showEvents: options?.showEvents ?? true,
                    showObjectChanges: options?.showObjectChanges ?? true
                }
            });
            if (options?.waitForConfirmation ?? true) {
                // Wait for transaction to be indexed and available over API
                const confirmedTransaction = await Iota.waitForTransactionConfirmation(client, response.digest, config, {
                    showEffects: options?.showEffects ?? true,
                    showEvents: options?.showEvents ?? true,
                    showObjectChanges: options?.showObjectChanges ?? true
                });
                return confirmedTransaction;
            }
            return response;
        }
        catch (error) {
            throw new core.GeneralError(Iota._CLASS_NAME, "transactionFailed", undefined, Iota.extractPayloadError(error));
        }
    }
    /**
     * Get the seed from the vault.
     * @param config The configuration to use.
     * @param vaultConnector The vault connector to use.
     * @param identity The identity of the user to access the vault keys.
     * @returns The seed.
     */
    static async getSeed(config, vaultConnector, identity) {
        try {
            const seedBase64 = await vaultConnector.getSecret(Iota.buildSeedKey(identity, config.vaultSeedId));
            return core.Converter.base64ToBytes(seedBase64);
        }
        catch { }
        const mnemonic = await vaultConnector.getSecret(Iota.buildMnemonicKey(identity, config.vaultMnemonicId));
        return crypto.Bip39.mnemonicToSeed(mnemonic);
    }
    /**
     * Find the address in the seed.
     * @param maxScanRange The maximum range to scan.
     * @param coinType The coin type to use.
     * @param seed The seed to use.
     * @param address The address to find.
     * @returns The address key pair.
     * @throws Error if the address is not found.
     */
    static findAddress(maxScanRange, coinType, seed, address) {
        for (let i = 0; i < maxScanRange; i++) {
            const addressKeyPair = crypto.Bip44.address(seed, crypto.KeyType.Ed25519, coinType, 0, false, i);
            if (addressKeyPair.address === address) {
                return addressKeyPair;
            }
        }
        throw new core.GeneralError(Iota._CLASS_NAME, "addressNotFound", { address });
    }
    /**
     * Extract error from SDK payload.
     * Errors from the IOTA SDK are usually not JSON strings but objects.
     * @param error The error to extract.
     * @returns The extracted error.
     */
    static extractPayloadError(error) {
        if (core.Is.object(error)) {
            if (!core.Is.empty(error.inner)) {
                error.inner = Iota.extractPayloadError(error.inner);
            }
            if (error.code === "InsufficientGas") {
                return new core.GeneralError(Iota._CLASS_NAME, "insufficientFunds");
            }
            else if (error.message?.startsWith("ErrorObject")) {
                const msg = /message: "(.*)"/.exec(error.message);
                if (msg && msg.length > 1) {
                    error = msg[1];
                }
            }
        }
        const baseError = core.BaseError.fromError(error);
        if (baseError.name === "Base" && !core.Is.stringValue(baseError.source)) {
            baseError.name = "IOTA";
            baseError.source = Iota._CLASS_NAME;
        }
        return baseError;
    }
    /**
     * Get the key for storing the mnemonic.
     * @param identity The identity to use.
     * @param vaultMnemonicId The mnemonic ID to use.
     * @returns The mnemonic key.
     */
    static buildMnemonicKey(identity, vaultMnemonicId) {
        return `${identity}/${vaultMnemonicId ?? Iota.DEFAULT_MNEMONIC_SECRET_NAME}`;
    }
    /**
     * Get the key for storing the seed.
     * @param identity The identity to use.
     * @param vaultSeedId The seed ID to use.
     * @returns The seed key.
     */
    static buildSeedKey(identity, vaultSeedId) {
        return `${identity}/${vaultSeedId ?? Iota.DEFAULT_SEED_SECRET_NAME}`;
    }
    /**
     * Check if the package exists on the network.
     * @param client The client to use.
     * @param packageId The package ID to check.
     * @returns True if the package exists, false otherwise.
     */
    static async packageExistsOnNetwork(client, packageId) {
        try {
            const packageObject = await client.getObject({
                id: packageId,
                options: {
                    showType: true
                }
            });
            if ("error" in packageObject) {
                if (packageObject?.error?.code === "notExists") {
                    return false;
                }
                throw new core.GeneralError(Iota._CLASS_NAME, "packageObjectError", {
                    packageId,
                    error: packageObject.error
                });
            }
            return true;
        }
        catch (error) {
            throw new core.GeneralError(Iota._CLASS_NAME, "packageNotFoundOnNetwork", {
                packageId,
                error: Iota.extractPayloadError(error)
            });
        }
    }
    /**
     * Dry run a transaction and log the results.
     * @param client The IOTA client.
     * @param logging The logging connector.
     * @param txb The transaction to dry run.
     * @param sender The sender address.
     * @param operation The operation to log.
     * @returns void.
     */
    static async dryRunTransaction(client, logging, txb, sender, operation) {
        try {
            txb.setSender(sender);
            const builtTx = await txb.build({
                client,
                onlyTransactionKind: false
            });
            const dryRunResult = await client.dryRunTransactionBlock({
                transactionBlock: builtTx
            });
            if (dryRunResult.effects.status?.status !== "success") {
                throw new core.GeneralError(this._CLASS_NAME, "dryRunFailed", {
                    error: dryRunResult.effects?.status?.error
                });
            }
            const result = {
                status: dryRunResult.effects.status.status,
                costs: {
                    computationCost: dryRunResult.effects.gasUsed.computationCost,
                    computationCostBurned: dryRunResult.effects.gasUsed.computationCostBurned,
                    storageCost: dryRunResult.effects.gasUsed.storageCost,
                    storageRebate: dryRunResult.effects.gasUsed.storageRebate,
                    nonRefundableStorageFee: dryRunResult.effects.gasUsed.nonRefundableStorageFee
                },
                events: dryRunResult.events ?? [],
                balanceChanges: dryRunResult.balanceChanges ?? [],
                objectChanges: dryRunResult.objectChanges ?? []
            };
            if (logging) {
                await logging.log({
                    level: "info",
                    source: Iota._CLASS_NAME,
                    ts: Date.now(),
                    message: "transactionCosts",
                    data: {
                        operation,
                        ...result
                    }
                });
            }
            return result;
        }
        catch (error) {
            if (error instanceof core.GeneralError) {
                throw error;
            }
            throw new core.GeneralError(Iota._CLASS_NAME, "dryRunFailed", undefined, Iota.extractPayloadError(error));
        }
    }
    /**
     * Wait for a transaction to be indexed and available over the API.
     * @param client The IOTA client instance.
     * @param digest The digest of the transaction to wait for.
     * @param config The IOTA configuration.
     * @param options Additional options for the transaction query.
     * @param options.showEffects Whether to show effects.
     * @param options.showEvents Whether to show events.
     * @param options.showObjectChanges Whether to show object changes.
     * @returns The confirmed transaction response.
     */
    static async waitForTransactionConfirmation(client, digest, config, options) {
        const timeoutMs = (config.inclusionTimeoutSeconds ?? Iota.DEFAULT_INCLUSION_TIMEOUT) * 1000;
        return client.waitForTransaction({
            digest,
            timeout: timeoutMs,
            options: {
                showEffects: options?.showEffects ?? true,
                showEvents: options?.showEvents ?? true,
                showObjectChanges: options?.showObjectChanges ?? true
            }
        });
    }
    /**
     * Check if the error is an abort error.
     * @param error The error to check.
     * @param code The error code to check for.
     * @returns True if the error is an abort error, false otherwise.
     */
    static isAbortError(error, code) {
        const err = core.BaseError.fromError(error);
        if (core.Is.stringValue(err.properties?.error) && err.properties.error.startsWith("MoveAbort")) {
            if (core.Is.number(code)) {
                return err.properties.error.includes(code.toString());
            }
            return true;
        }
        return false;
    }
    /**
     * Prepare and post a transaction using gas station sponsoring.
     * @param config The configuration.
     * @param vaultConnector The vault connector.
     * @param identity The identity of the user to access the vault keys.
     * @param client The client instance.
     * @param owner The owner of the address.
     * @param transaction The transaction to execute.
     * @param options Response options including confirmation behavior.
     * @returns The transaction response.
     */
    static async prepareAndPostGasStationTransaction(config, vaultConnector, identity, client, owner, transaction, options) {
        core.Guards.object(this._CLASS_NAME, "config.gasStation", config.gasStation);
        try {
            // Reserve gas from the gas station
            const gasBudget = config.gasBudget ?? 50000000;
            const gasReservation = await this.reserveGas(config, gasBudget);
            // Set transaction parameters for sponsoring
            transaction.setSender(owner);
            transaction.setGasOwner(gasReservation.sponsorAddress);
            transaction.setGasPayment(gasReservation.gasCoins);
            transaction.setGasBudget(gasBudget);
            // Build and sign transaction
            const unsignedTxBytes = await transaction.build({ client });
            // Sign the transaction with the user's private key
            const seed = await this.getSeed(config, vaultConnector, identity);
            const addressKeyPair = Iota.findAddress(config.maxAddressScanRange ?? Iota.DEFAULT_SCAN_RANGE, config.coinType ?? Iota.DEFAULT_COIN_TYPE, seed, owner);
            const keypair = ed25519.Ed25519Keypair.fromSecretKey(addressKeyPair.privateKey);
            const signature = await keypair.signTransaction(unsignedTxBytes);
            return await this.executeAndConfirmGasStationTransaction(config, client, gasReservation.reservationId, unsignedTxBytes, signature.signature, options);
        }
        catch (error) {
            throw new core.GeneralError(Iota._CLASS_NAME, "gasStationTransactionFailed", undefined, Iota.extractPayloadError(error));
        }
    }
    /**
     * Reserve gas from the gas station.
     * @param config The configuration containing gas station settings.
     * @param gasBudget The gas budget to reserve.
     * @returns The gas reservation result.
     */
    static async reserveGas(config, gasBudget) {
        core.Guards.object(this._CLASS_NAME, "config.gasStation", config.gasStation);
        const requestData = {
            // eslint-disable-next-line camelcase
            gas_budget: gasBudget,
            // eslint-disable-next-line camelcase
            reserve_duration_secs: 30
        };
        const baseUrl = core.StringHelper.trimTrailingSlashes(config.gasStation.gasStationUrl);
        const result = await web.FetchHelper.fetchJson(this._CLASS_NAME, `${baseUrl}/v1/reserve_gas`, web.HttpMethod.POST, requestData, {
            headers: {
                Authorization: `Bearer ${config.gasStation.gasStationAuthToken}`
            }
        });
        const apiResponse = result.result;
        return {
            sponsorAddress: apiResponse.sponsor_address,
            reservationId: apiResponse.reservation_id,
            gasCoins: apiResponse.gas_coins
        };
    }
    /**
     * Execute a sponsored transaction through the gas station.
     * @param config The configuration containing gas station settings.
     * @param reservationId The reservation ID from gas reservation.
     * @param transactionBytes The unsigned transaction bytes.
     * @param userSignature The user's signature.
     * @returns The transaction response.
     */
    static async executeGasStationTransaction(config, reservationId, transactionBytes, userSignature) {
        core.Guards.object(this._CLASS_NAME, "config.gasStation", config.gasStation);
        const requestData = {
            // eslint-disable-next-line camelcase
            reservation_id: reservationId,
            // eslint-disable-next-line camelcase
            tx_bytes: bcs.toB64(transactionBytes),
            // eslint-disable-next-line camelcase
            user_sig: userSignature
        };
        const baseUrl = core.StringHelper.trimTrailingSlashes(config.gasStation.gasStationUrl);
        const result = await web.FetchHelper.fetchJson(this._CLASS_NAME, `${baseUrl}/v1/execute_tx`, web.HttpMethod.POST, requestData, {
            headers: {
                Authorization: `Bearer ${config.gasStation.gasStationAuthToken}`
            }
        });
        const effectsData = result.effects;
        // Match IotaTransactionBlockResponse format
        return {
            digest: effectsData.transactionDigest,
            effects: effectsData,
            events: [],
            objectChanges: [],
            confirmedLocalExecution: true
        };
    }
    /**
     * Execute and confirm a gas station transaction.
     * @param config The configuration containing gas station settings.
     * @param client The IOTA client for confirmation.
     * @param reservationId The reservation ID from gas reservation.
     * @param transactionBytes The unsigned transaction bytes.
     * @param userSignature The user's signature.
     * @param options Response options including confirmation behavior.
     * @returns The transaction response (confirmed if waitForConfirmation is true).
     */
    static async executeAndConfirmGasStationTransaction(config, client, reservationId, transactionBytes, userSignature, options) {
        core.Guards.object(this._CLASS_NAME, "config.gasStation", config.gasStation);
        const response = await this.executeGasStationTransaction(config, reservationId, transactionBytes, userSignature);
        if (options?.waitForConfirmation ?? true) {
            const confirmedTransaction = await Iota.waitForTransactionConfirmation(client, response.digest, config, {
                showEffects: options?.showEffects ?? true,
                showEvents: options?.showEvents ?? true,
                showObjectChanges: options?.showObjectChanges ?? true
            });
            return confirmedTransaction;
        }
        return response;
    }
}

exports.Iota = Iota;
