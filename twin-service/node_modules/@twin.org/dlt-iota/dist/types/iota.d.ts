import { IotaClient, type IotaTransactionBlockResponse } from "@iota/iota-sdk/client";
import { Transaction } from "@iota/iota-sdk/transactions";
import { type IError } from "@twin.org/core";
import type { ILoggingConnector } from "@twin.org/logging-models";
import type { IVaultConnector } from "@twin.org/vault-models";
import type { IGasReservationResult } from "./models/IGasReservationResult";
import type { IIotaConfig } from "./models/IIotaConfig";
import type { IIotaDryRun } from "./models/IIotaDryRun";
import type { IIotaResponseOptions } from "./models/IIotaResponseOptions";
/**
 * Class for performing operations on IOTA.
 */
export declare class Iota {
    /**
     * Default name for the mnemonic secret.
     */
    static readonly DEFAULT_MNEMONIC_SECRET_NAME: string;
    /**
     * Default name for the seed secret.
     */
    static readonly DEFAULT_SEED_SECRET_NAME: string;
    /**
     * Default coin type.
     */
    static readonly DEFAULT_COIN_TYPE: number;
    /**
     * Default scan range.
     */
    static readonly DEFAULT_SCAN_RANGE: number;
    /**
     * Default inclusion timeout.
     */
    static readonly DEFAULT_INCLUSION_TIMEOUT: number;
    /**
     * Create a new IOTA client.
     * @param config The configuration.
     * @returns The client instance.
     */
    static createClient(config: IIotaConfig): IotaClient;
    /**
     * Create configuration using defaults where necessary.
     * @param config The configuration to populate.
     */
    static populateConfig(config: IIotaConfig): void;
    /**
     * Get addresses for the identity.
     * @param seed The seed to use for generating addresses.
     * @param coinType The coin type to use.
     * @param accountIndex The account index to get the addresses for.
     * @param startAddressIndex The start index for the addresses.
     * @param count The number of addresses to generate.
     * @param isInternal Whether the addresses are internal.
     * @returns The list of addresses.
     */
    static getAddresses(seed: Uint8Array, coinType: number, accountIndex: number, startAddressIndex: number, count: number, isInternal?: boolean): string[];
    /**
     * Get a key pair for the specified index.
     * @param seed The seed to use for generating the key pair.
     * @param coinType The coin type to use.
     * @param accountIndex The account index to get the key pair for.
     * @param addressIndex The address index to get the key pair for.
     * @param isInternal Whether the address is internal.
     * @returns The key pair containing private key and public key.
     */
    static getKeyPair(seed: Uint8Array, coinType: number, accountIndex: number, addressIndex: number, isInternal?: boolean): {
        privateKey: Uint8Array;
        publicKey: Uint8Array;
    };
    /**
     * Prepare and post a transaction.
     * @param config The configuration.
     * @param vaultConnector The vault connector.
     * @param loggingConnector The logging connector.
     * @param identity The identity of the user to access the vault keys.
     * @param client The client instance.
     * @param source The source address.
     * @param amount The amount to transfer.
     * @param recipient The recipient address.
     * @param options The transaction options.
     * @returns The transaction result.
     */
    static prepareAndPostValueTransaction(config: IIotaConfig, vaultConnector: IVaultConnector, loggingConnector: ILoggingConnector | undefined, identity: string, client: IotaClient, source: string, amount: bigint, recipient: string, options?: IIotaResponseOptions): Promise<IotaTransactionBlockResponse>;
    /**
     * Prepare and post a transaction.
     * @param config The configuration.
     * @param vaultConnector The vault connector.
     * @param loggingConnector The logging connector.
     * @param identity The identity of the user to access the vault keys.
     * @param client The client instance.
     * @param owner The owner of the address.
     * @param transaction The transaction to execute.
     * @param options The transaction options.
     * @returns The transaction response.
     */
    static prepareAndPostTransaction(config: IIotaConfig, vaultConnector: IVaultConnector, loggingConnector: ILoggingConnector | undefined, identity: string, client: IotaClient, owner: string, transaction: Transaction, options?: IIotaResponseOptions): Promise<IotaTransactionBlockResponse>;
    /**
     * Get the seed from the vault.
     * @param config The configuration to use.
     * @param vaultConnector The vault connector to use.
     * @param identity The identity of the user to access the vault keys.
     * @returns The seed.
     */
    static getSeed(config: IIotaConfig, vaultConnector: IVaultConnector, identity: string): Promise<Uint8Array>;
    /**
     * Find the address in the seed.
     * @param maxScanRange The maximum range to scan.
     * @param coinType The coin type to use.
     * @param seed The seed to use.
     * @param address The address to find.
     * @returns The address key pair.
     * @throws Error if the address is not found.
     */
    static findAddress(maxScanRange: number, coinType: number, seed: Uint8Array, address: string): {
        address: string;
        privateKey: Uint8Array;
        publicKey: Uint8Array;
    };
    /**
     * Extract error from SDK payload.
     * Errors from the IOTA SDK are usually not JSON strings but objects.
     * @param error The error to extract.
     * @returns The extracted error.
     */
    static extractPayloadError(error: unknown): IError;
    /**
     * Get the key for storing the mnemonic.
     * @param identity The identity to use.
     * @param vaultMnemonicId The mnemonic ID to use.
     * @returns The mnemonic key.
     */
    static buildMnemonicKey(identity: string, vaultMnemonicId?: string): string;
    /**
     * Get the key for storing the seed.
     * @param identity The identity to use.
     * @param vaultSeedId The seed ID to use.
     * @returns The seed key.
     */
    static buildSeedKey(identity: string, vaultSeedId?: string): string;
    /**
     * Check if the package exists on the network.
     * @param client The client to use.
     * @param packageId The package ID to check.
     * @returns True if the package exists, false otherwise.
     */
    static packageExistsOnNetwork(client: IotaClient, packageId: string): Promise<boolean>;
    /**
     * Dry run a transaction and log the results.
     * @param client The IOTA client.
     * @param logging The logging connector.
     * @param txb The transaction to dry run.
     * @param sender The sender address.
     * @param operation The operation to log.
     * @returns void.
     */
    static dryRunTransaction(client: IotaClient, logging: ILoggingConnector | undefined, txb: Transaction, sender: string, operation: string): Promise<IIotaDryRun>;
    /**
     * Wait for a transaction to be indexed and available over the API.
     * @param client The IOTA client instance.
     * @param digest The digest of the transaction to wait for.
     * @param config The IOTA configuration.
     * @param options Additional options for the transaction query.
     * @param options.showEffects Whether to show effects.
     * @param options.showEvents Whether to show events.
     * @param options.showObjectChanges Whether to show object changes.
     * @returns The confirmed transaction response.
     */
    static waitForTransactionConfirmation(client: IotaClient, digest: string, config: IIotaConfig, options?: {
        showEffects?: boolean;
        showEvents?: boolean;
        showObjectChanges?: boolean;
    }): Promise<IotaTransactionBlockResponse>;
    /**
     * Check if the error is an abort error.
     * @param error The error to check.
     * @param code The error code to check for.
     * @returns True if the error is an abort error, false otherwise.
     */
    static isAbortError(error: unknown, code?: number): boolean;
    /**
     * Prepare and post a transaction using gas station sponsoring.
     * @param config The configuration.
     * @param vaultConnector The vault connector.
     * @param identity The identity of the user to access the vault keys.
     * @param client The client instance.
     * @param owner The owner of the address.
     * @param transaction The transaction to execute.
     * @param options Response options including confirmation behavior.
     * @returns The transaction response.
     */
    static prepareAndPostGasStationTransaction(config: IIotaConfig, vaultConnector: IVaultConnector, identity: string, client: IotaClient, owner: string, transaction: Transaction, options?: IIotaResponseOptions): Promise<IotaTransactionBlockResponse>;
    /**
     * Reserve gas from the gas station.
     * @param config The configuration containing gas station settings.
     * @param gasBudget The gas budget to reserve.
     * @returns The gas reservation result.
     */
    static reserveGas(config: IIotaConfig, gasBudget: number): Promise<IGasReservationResult>;
    /**
     * Execute a sponsored transaction through the gas station.
     * @param config The configuration containing gas station settings.
     * @param reservationId The reservation ID from gas reservation.
     * @param transactionBytes The unsigned transaction bytes.
     * @param userSignature The user's signature.
     * @returns The transaction response.
     */
    static executeGasStationTransaction(config: IIotaConfig, reservationId: number, transactionBytes: Uint8Array, userSignature: string): Promise<IotaTransactionBlockResponse>;
    /**
     * Execute and confirm a gas station transaction.
     * @param config The configuration containing gas station settings.
     * @param client The IOTA client for confirmation.
     * @param reservationId The reservation ID from gas reservation.
     * @param transactionBytes The unsigned transaction bytes.
     * @param userSignature The user's signature.
     * @param options Response options including confirmation behavior.
     * @returns The transaction response (confirmed if waitForConfirmation is true).
     */
    static executeAndConfirmGasStationTransaction(config: IIotaConfig, client: IotaClient, reservationId: number, transactionBytes: Uint8Array, userSignature: string, options?: IIotaResponseOptions): Promise<IotaTransactionBlockResponse>;
}
