import { Factory, Guards, UnauthorizedError } from '@twin.org/core';
import { Jwt } from '@twin.org/web';

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Factory for creating vault connectors.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const VaultConnectorFactory = Factory.createFactory("vault");

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * The names of the vault encryption types.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const VaultEncryptionType = {
    /**
     * The ChaCha20Poly1305. (symmetric)
     */
    ChaCha20Poly1305: 0
};

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * The names of the vault key types.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const VaultKeyType = {
    /**
     * Ed25519. (asymmetric)
     */
    Ed25519: 0,
    /**
     * Secp256k1. (asymmetric)
     */
    Secp256k1: 1,
    /**
     * The ChaCha20Poly1305. (symmetric)
     */
    ChaCha20Poly1305: 2
};

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Helpers for vault connectors.
 */
class VaultConnectorHelper {
    /**
     * Runtime name for the class.
     * @internal
     */
    static _CLASS_NAME = "VaultConnectorHelper";
    /**
     * Sign a JWT using vault connector.
     * @param vaultConnector The vault connector to use.
     * @param keyName The name of the key to sign with.
     * @param header The header to sign.
     * @param payload The payload to sign.
     * @returns The token.
     */
    static async jwtSigner(vaultConnector, keyName, header, payload) {
        Guards.object(VaultConnectorHelper._CLASS_NAME, "vaultConnector", vaultConnector);
        Guards.stringValue(VaultConnectorHelper._CLASS_NAME, "keyName", keyName);
        Guards.object(VaultConnectorHelper._CLASS_NAME, "header", header);
        Guards.object(VaultConnectorHelper._CLASS_NAME, "payload", payload);
        const signingBytes = Jwt.toSigningBytes(header, payload);
        const signatureBytes = await vaultConnector.sign(keyName, signingBytes);
        return Jwt.tokenFromBytes(signingBytes, signatureBytes);
    }
    /**
     * Verify a JWT using a vault connector.
     * @param vaultConnector The vault connector to use.
     * @param keyName The name of the key to verify with.
     * @param token The token to verify.
     * @returns The header and payload if verification successful.
     */
    static async jwtVerifier(vaultConnector, keyName, token) {
        Guards.object(VaultConnectorHelper._CLASS_NAME, "vaultConnector", vaultConnector);
        Guards.stringValue(VaultConnectorHelper._CLASS_NAME, "keyName", keyName);
        Guards.stringValue(VaultConnectorHelper._CLASS_NAME, "token", token);
        const { signingBytes, signature } = Jwt.tokenToBytes(token);
        const verified = await vaultConnector.verify(keyName, signingBytes, signature);
        if (!verified) {
            throw new UnauthorizedError(this._CLASS_NAME, "invalidSignature");
        }
        return Jwt.fromSigningBytes(signingBytes);
    }
}

export { VaultConnectorFactory, VaultConnectorHelper, VaultEncryptionType, VaultKeyType };
