'use strict';

var core = require('@twin.org/core');
var crypto = require('@twin.org/crypto');
var loggingModels = require('@twin.org/logging-models');
var vaultModels = require('@twin.org/vault-models');
var web = require('@twin.org/web');

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Class for performing vault operations in entity storage.
 */
class HashicorpVaultConnector {
    /**
     * The namespace supported by the vault connector.
     */
    static NAMESPACE = "hashicorp";
    /**
     * The prefix to strip from keys and encrypted data.
     * @internal
     */
    static _DATA_PREFIX = "vault:v1:";
    /**
     * Runtime name for the class.
     */
    CLASS_NAME = "HashicorpVaultConnector";
    /**
     * The entity storage for the vault keys.
     * @internal
     */
    _config;
    /**
     * The KV mount path.
     * @internal
     */
    _kvMountPath;
    /**
     * The transit mount path.
     * @internal
     */
    _transitMountPath;
    /**
     * The base URL for the Vault API.
     * @internal
     */
    _baseUrl;
    /**
     * The headers for the requests.
     * @internal
     */
    _headers;
    /**
     * Create a new instance of HashicorpVaultConnector.
     * @param options The options for the vault connector.
     */
    constructor(options) {
        core.Guards.object(this.CLASS_NAME, "options", options);
        core.Guards.object(this.CLASS_NAME, "options.config", options.config);
        core.Guards.stringValue(this.CLASS_NAME, "options.config.endpoint", options.config.endpoint);
        core.Guards.stringValue(this.CLASS_NAME, "options.config.token", options.config.token);
        this._config = options.config;
        this._kvMountPath = this._config.kvMountPath ?? "secret";
        this._transitMountPath = this._config.transitMountPath ?? "transit";
        this._baseUrl = `${core.StringHelper.trimTrailingSlashes(this._config.endpoint)}/${this._config.apiVersion ?? "v1"}`;
        this._headers = {
            "X-Vault-Token": this._config.token
        };
    }
    /**
     * Bootstrap the vault connector and ensure connectivity.
     * @param nodeLoggingConnectorType The node logging connector type, defaults to "node-logging".
     * @returns True if the bootstrapping process was successful.
     */
    async bootstrap(nodeLoggingConnectorType) {
        const nodeLogging = loggingModels.LoggingConnectorFactory.getIfExists(nodeLoggingConnectorType ?? "node-logging");
        try {
            await web.FetchHelper.fetch(this.CLASS_NAME, `${this._baseUrl}/sys/health`, web.HttpMethod.GET, undefined, { headers: this._headers });
            await nodeLogging?.log({
                level: "info",
                source: this.CLASS_NAME,
                ts: Date.now(),
                message: "hashicorpVaultConnected",
                data: {
                    address: this._config.endpoint,
                    token: this._config.token
                }
            });
            return true;
        }
        catch (err) {
            await nodeLogging?.log({
                level: "error",
                source: this.CLASS_NAME,
                ts: Date.now(),
                message: "hashicorpVaultConnectionFailed",
                error: core.BaseError.fromError(err),
                data: {
                    address: this._config.endpoint,
                    token: this._config.token
                }
            });
            return false;
        }
    }
    /**
     * Store a secret in the vault.
     * @param name The name of the item in the vault to set.
     * @param data The item to add to the vault.
     * @returns Nothing.
     */
    async setSecret(name, data) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        core.Guards.defined(this.CLASS_NAME, "data", data);
        try {
            const path = this.getSecretPath(name);
            const url = `${this._baseUrl}/${path}`;
            const payload = {
                data: {
                    secret: data
                }
            };
            await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.POST, payload, {
                headers: this._headers
            });
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "setSecretFailed", { name }, err);
        }
    }
    /**
     * Get a secret from the vault.
     * @param name The name of the item in the vault to get.
     * @returns The item from the vault.
     * @throws Error if the item is not found.
     */
    async getSecret(name) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        try {
            await this.getSecretVersions(name);
        }
        catch (err) {
            throw new core.NotFoundError(this.CLASS_NAME, "secretNotFound", name, err);
        }
        try {
            const path = this.getSecretPath(name);
            const url = `${this._baseUrl}/${path}`;
            const response = await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.GET, undefined, { headers: this._headers });
            return response.data.data.secret;
        }
        catch (err) {
            if (err instanceof web.FetchError && err.properties?.httpStatus === 404) {
                throw new core.NotFoundError(this.CLASS_NAME, "secretNotFound", name, err);
            }
            throw new core.GeneralError(this.CLASS_NAME, "setSecretFailed", { name }, err);
        }
    }
    /**
     * Remove a secret from the vault.
     * @param name The name of the item in the vault to remove.
     * @returns Nothing.
     * @throws Error if the item is not found.
     */
    async removeSecret(name) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        try {
            await this.getSecretVersions(name);
        }
        catch (err) {
            throw new core.NotFoundError(this.CLASS_NAME, "secretNotFound", name, err);
        }
        try {
            const path = this.getSecretMetadataPath(name);
            const url = `${this._baseUrl}/${path}`;
            await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.DELETE, undefined, { headers: this._headers });
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "removeSecretFailed", { name }, err);
        }
    }
    /**
     * Generate a new key and store it in the vault.
     * @param name The name of the key to generate and store in the vault.
     * @param type The type of key to create.
     * @returns The public key for the key pair.
     */
    async createKey(name, type) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        core.Guards.arrayOneOf(this.CLASS_NAME, "type", type, Object.values(vaultModels.VaultKeyType));
        const path = this.getTransitKeyPath(name);
        const url = `${this._baseUrl}/${path}`;
        try {
            // Check if the key exists
            const existingVaultKey = await this.readKey(name);
            if (existingVaultKey) {
                throw new core.AlreadyExistsError(this.CLASS_NAME, "keyAlreadyExists", name);
            }
        }
        catch (err) {
            if (!(err instanceof web.FetchError && err.properties?.httpStatus === 404)) {
                throw err;
            }
        }
        try {
            const vaultKeyType = this.mapVaultKeyType(type);
            const payload = {
                type: vaultKeyType,
                exportable: true,
                allow_plaintext_backup: true // eslint-disable-line camelcase
            };
            await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.POST, payload, { headers: this._headers });
            // If the key is asymmetric, return the public key
            if (this.isAsymmetricKeyType(type)) {
                const publicKey = await this.exportKey(name, "public-key");
                return publicKey.key;
            }
            // If the key is symmetric, return the encryption key
            const symmetricKey = await this.exportKey(name, "encryption-key");
            return symmetricKey.key;
        }
        catch (err) {
            if (err instanceof core.AlreadyExistsError) {
                throw err;
            }
            throw new core.GeneralError(this.CLASS_NAME, "createdKeyFailed", { name, type }, err);
        }
    }
    /**
     * Add an existing key to the vault.
     * @param name The name of the key to add to the vault.
     * @param type The type of key to add.
     * @param privateKey The private key.
     * @param publicKey The public key, can be undefined if the key type is symmetric.
     * @returns Nothing.
     */
    async addKey(name, type, privateKey, publicKey) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        core.Guards.arrayOneOf(this.CLASS_NAME, "type", type, Object.values(vaultModels.VaultKeyType));
        core.Guards.uint8Array(this.CLASS_NAME, "privateKey", privateKey);
        try {
            // Check if the key exists
            const existingVaultKey = await this.readKey(name);
            if (existingVaultKey) {
                throw new core.AlreadyExistsError(this.CLASS_NAME, "keyAlreadyExists", name);
            }
        }
        catch (err) {
            if (!(err instanceof web.FetchError && err.properties?.httpStatus === 404)) {
                throw err;
            }
        }
        try {
            const combinedKey = new Uint8Array(privateKey.length + (publicKey?.length ?? 0));
            combinedKey.set(privateKey);
            if (publicKey) {
                combinedKey.set(publicKey, privateKey.length);
            }
            const internalType = this.mapVaultKeyTypeToIndex(type);
            const payload = {
                policy: {
                    name,
                    keys: {
                        "1": {
                            key: core.Converter.bytesToBase64(combinedKey),
                            hmac_key: core.Converter.bytesToBase64(core.RandomHelper.generate(32)), // eslint-disable-line camelcase
                            public_key: core.Is.undefined(publicKey) ? null : core.Converter.bytesToBase64(publicKey) // eslint-disable-line camelcase
                        }
                    },
                    exportable: true,
                    allow_plaintext_backup: true, // eslint-disable-line camelcase
                    min_decryption_version: 1, // eslint-disable-line camelcase
                    min_encryption_version: 0, // eslint-disable-line camelcase
                    latest_version: 1, // eslint-disable-line camelcase
                    type: internalType // eslint-disable-line camelcase
                }
            };
            const backup = core.Converter.bytesToBase64(core.ObjectHelper.toBytes(payload));
            await this.restoreKey(name, backup);
        }
        catch (err) {
            if (err instanceof core.AlreadyExistsError) {
                throw err;
            }
            throw new core.GeneralError(this.CLASS_NAME, "addKeyFailed", { name, type }, err);
        }
    }
    /**
     * Get a key from the vault.
     * @param name The name of the key to get.
     * @returns The key, publicKey can be undefined if key is symmetric.
     */
    async getKey(name) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        let keyDetails;
        try {
            keyDetails = await this.readKey(name);
        }
        catch (err) {
            throw new core.NotFoundError(this.CLASS_NAME, "keyNotFound", name, err);
        }
        try {
            let publicKey;
            let privateKey;
            const type = this.mapHashicorpKeyType(keyDetails.type);
            if (this.isAsymmetricKeyType(type)) {
                const privateKeyData = await this.exportKey(name, "signing-key");
                privateKey = privateKeyData.key;
                const publicKeyData = await this.exportKey(name, "public-key");
                publicKey = publicKeyData.key;
            }
            else {
                const privateKeyData = await this.exportKey(name, "encryption-key");
                privateKey = privateKeyData.key;
            }
            return {
                type,
                privateKey,
                publicKey
            };
        }
        catch (err) {
            if (err instanceof core.NotFoundError) {
                throw err;
            }
            throw new core.GeneralError(this.CLASS_NAME, "getKeyFailed", { name }, err);
        }
    }
    /**
     * Rename a key in the vault.
     * @param name The name of the key to rename.
     * @param newName The new name of the key.
     * @returns Nothing.
     */
    async renameKey(name, newName) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        core.Guards.stringValue(this.CLASS_NAME, "newName", newName);
        try {
            let existingVaultKey;
            try {
                existingVaultKey = await this.readKey(newName);
            }
            catch {
                // If we have an error we just continue as it means the key does not exist
            }
            if (existingVaultKey) {
                throw new core.AlreadyExistsError(this.CLASS_NAME, "keyAlreadyExists", newName);
            }
            const backup = await this.backupKey(name);
            await this.restoreKey(newName, backup);
            await this.removeKey(name);
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "renameKeyFailed", { name, newName }, err);
        }
    }
    /**
     * Remove a key from the vault.
     * @param name The name of the key to remove.
     * @returns Nothing.
     */
    async removeKey(name) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        try {
            await this.readKey(name);
        }
        catch (err) {
            throw new core.NotFoundError(this.CLASS_NAME, "keyNotFound", name, err);
        }
        try {
            const path = this.getTransitKeyPath(name);
            const url = `${this._baseUrl}/${path}`;
            await this.updateKeyConfig(name, true);
            await web.FetchHelper.fetch(this.CLASS_NAME, url, web.HttpMethod.DELETE, undefined, {
                headers: this._headers
            });
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "removeKeyFailed", { name }, err);
        }
    }
    /**
     * Sign data.
     * @param name The name of the key to use.
     * @param data The data to sign.
     * @returns The signature.
     */
    async sign(name, data) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        core.Guards.uint8Array(this.CLASS_NAME, "data", data);
        try {
            await this.readKey(name);
        }
        catch (err) {
            throw new core.NotFoundError(this.CLASS_NAME, "keyNotFound", name, err);
        }
        try {
            const path = this.getTransitSignPath(name);
            const url = `${this._baseUrl}/${path}`;
            const base64Data = core.Converter.bytesToBase64(data);
            const payload = {
                input: base64Data
            };
            const response = await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.POST, payload, { headers: this._headers });
            if (response?.data?.signature) {
                const signatureString = response.data.signature;
                const cleanedSignature = signatureString.startsWith(HashicorpVaultConnector._DATA_PREFIX)
                    ? signatureString.slice(HashicorpVaultConnector._DATA_PREFIX.length)
                    : signatureString;
                const signatureBytes = core.Converter.base64ToBytes(cleanedSignature);
                return signatureBytes;
            }
            throw new core.GeneralError(this.CLASS_NAME, "invalidSignResponse", { name });
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "signDataFailed", { name }, err);
        }
    }
    /**
     * Verify a signature.
     * @param name The name of the key to use.
     * @param data The data to verify.
     * @param signature The signature to verify.
     * @returns True if the signature is valid.
     */
    async verify(name, data, signature) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        core.Guards.uint8Array(this.CLASS_NAME, "data", data);
        core.Guards.uint8Array(this.CLASS_NAME, "signature", signature);
        try {
            await this.readKey(name);
        }
        catch (err) {
            throw new core.NotFoundError(this.CLASS_NAME, "keyNotFound", name, err);
        }
        try {
            const path = this.getTransitVerifyPath(name);
            const url = `${this._baseUrl}/${path}`;
            const base64Data = core.Converter.bytesToBase64(data);
            const signatureBase64 = core.Converter.bytesToBase64(signature);
            const prefixedSignature = `${HashicorpVaultConnector._DATA_PREFIX}${signatureBase64}`;
            const payload = {
                input: base64Data,
                signature: prefixedSignature
            };
            const response = await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.POST, payload, { headers: this._headers });
            if (response?.data?.valid) {
                return response.data.valid;
            }
            return false;
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "verifyDataFailed", { name }, err);
        }
    }
    /**
     * Encrypt data.
     * @param name The name of the key to use.
     * @param encryptionType The type of encryption to use.
     * @param data The data to encrypt.
     * @returns The encrypted data.
     */
    async encrypt(name, encryptionType, data) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        core.Guards.arrayOneOf(this.CLASS_NAME, "encryptionType", encryptionType, Object.values(vaultModels.VaultEncryptionType));
        core.Guards.uint8Array(this.CLASS_NAME, "data", data);
        let keyDetails;
        try {
            keyDetails = await this.readKey(name);
        }
        catch (err) {
            throw new core.NotFoundError(this.CLASS_NAME, "keyNotFound", name, err);
        }
        try {
            if (encryptionType === vaultModels.VaultEncryptionType.ChaCha20Poly1305 &&
                keyDetails.type !== this.mapVaultKeyType(vaultModels.VaultKeyType.ChaCha20Poly1305)) {
                throw new core.GeneralError(this.CLASS_NAME, "keyTypeMismatch", {
                    encryptionType,
                    keyType: keyDetails.type
                });
            }
        }
        catch (err) {
            throw new core.NotFoundError(this.CLASS_NAME, "keyNotFound", name, err);
        }
        try {
            const path = this.getTransitEncryptPath(name);
            const url = `${this._baseUrl}/${path}`;
            const payload = {
                plaintext: core.Converter.bytesToBase64(data)
            };
            const response = await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.POST, payload, { headers: this._headers });
            if (response?.data?.ciphertext) {
                const { ciphertext } = response.data;
                const cleanedCiphertext = ciphertext.startsWith(HashicorpVaultConnector._DATA_PREFIX)
                    ? ciphertext.slice(HashicorpVaultConnector._DATA_PREFIX.length)
                    : ciphertext;
                return core.Converter.base64ToBytes(cleanedCiphertext);
            }
            throw new core.GeneralError(this.CLASS_NAME, "invalidEncryptResponse", { name, encryptionType });
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "encryptDataFailed", { name, encryptionType }, err);
        }
    }
    /**
     * Decrypt data.
     * @param name The name of the key to use.
     * @param encryptionType The type of encryption to use.
     * @param encryptedData The encrypted data to decrypt.
     * @returns The decrypted data.
     */
    async decrypt(name, encryptionType, encryptedData) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        core.Guards.arrayOneOf(this.CLASS_NAME, "encryptionType", encryptionType, Object.values(vaultModels.VaultEncryptionType));
        core.Guards.uint8Array(this.CLASS_NAME, "encryptedData", encryptedData);
        try {
            await this.readKey(name);
        }
        catch (err) {
            throw new core.NotFoundError(this.CLASS_NAME, "keyNotFound", name, err);
        }
        try {
            const path = this.getTransitDecryptPath(name);
            const url = `${this._baseUrl}/${path}`;
            const ciphertext = core.Converter.bytesToBase64(encryptedData);
            const payload = {
                ciphertext: `${HashicorpVaultConnector._DATA_PREFIX}${ciphertext}`
            };
            const response = await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.POST, payload, { headers: this._headers });
            if (response?.data?.plaintext) {
                const { plaintext } = response.data;
                return core.Converter.base64ToBytes(plaintext);
            }
            throw new core.GeneralError(this.CLASS_NAME, "decryptDataFailed", { name, encryptionType });
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "decryptDataFailed", { name, encryptionType }, err);
        }
    }
    /**
     * Get the versions of a secret.
     * @param name The name of the secret.
     * @returns The versions of the secret.
     * @throws Error if the secret is not found.
     */
    async getSecretVersions(name) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        try {
            const versions = await this.fetchSecretVersions(name);
            return versions;
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "getSecretVersionsFailed", { name }, err);
        }
    }
    /**
     * Update the configuration of a key.
     * @param name The name of the key to update.
     * @param deletionAllowed Whether the key can be deleted.
     * @param exportable Whether the key can be exported.
     * @returns Nothing.
     */
    async updateKeyConfig(name, deletionAllowed, exportable) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        try {
            const path = this.getTransitKeyConfigPath(name);
            const url = `${this._baseUrl}/${path}`;
            const payload = {
                deletion_allowed: deletionAllowed, // eslint-disable-line camelcase
                exportable
            };
            await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.POST, payload, { headers: this._headers });
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "updateKeyConfigFailed", { name }, err);
        }
    }
    /**
     * Backup a key from the vault.
     * @param name The name of the key to backup.
     * @returns The private key as a Uint8Array.
     * @throws Error if the key cannot be exported or found.
     */
    async backupKey(name) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        const path = this.getTransitBackupKeyPath(name);
        const url = `${this._baseUrl}/${path}`;
        try {
            const response = await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.GET, undefined, { headers: this._headers });
            if (response?.data?.backup) {
                const backup = response.data.backup;
                return backup;
            }
            throw new core.NotFoundError(this.CLASS_NAME, "backupKeyNotFound", name);
        }
        catch (err) {
            if (err instanceof core.NotFoundError) {
                throw err;
            }
            throw new core.GeneralError(this.CLASS_NAME, "backupKeyFailed", { name }, err);
        }
    }
    /**
     * Restore a key to the vault.
     * @param name The name of the key to restore.
     * @param backup The backup of the key.
     * @returns Nothing.
     * @throws Error if the key cannot be restored.
     */
    async restoreKey(name, backup) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        core.Guards.stringValue(this.CLASS_NAME, "backup", backup);
        const path = this.getTransitRestoreKeyPath(name);
        const url = `${this._baseUrl}/${path}`;
        try {
            const payload = { backup };
            await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.POST, payload, { headers: this._headers });
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "restoreKeyFailed", { name }, err);
        }
    }
    /**
     * Export the key from the vault.
     * @param name The name of the key.
     * @param keyPath The path of the key. Defaults to "signing-key".
     * @param version The version of the key. If omitted, all versions of the key will be returned.
     * @returns The key details.
     * @throws Error if the key cannot be exported or found.
     */
    async exportKey(name, keyPath, version) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        const versionPath = version ? `${version}` : "latest";
        const path = this.getTransitExportKeyPath(name, keyPath);
        const url = `${this._baseUrl}/${path}/${versionPath}`;
        try {
            const response = await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.GET, undefined, { headers: this._headers });
            if (response?.data) {
                const { keys, type } = response.data;
                const keyVersion = Object.keys(keys)[0];
                let key;
                const keyType = this.mapHashicorpKeyType(type);
                if (keyType === vaultModels.VaultKeyType.Ed25519) {
                    key = core.Converter.base64ToBytes(keys[keyVersion]).slice(0, keyPath === "public-key" ? crypto.Ed25519.PUBLIC_KEY_SIZE : crypto.Ed25519.PRIVATE_KEY_SIZE);
                }
                else {
                    // VaultKeyType.ChaCha20Poly1305
                    key = core.Converter.base64ToBytes(keys[keyVersion]);
                }
                const keyData = {
                    type: keyType,
                    key,
                    name: response?.data?.name
                };
                return keyData;
            }
            throw new core.NotFoundError(this.CLASS_NAME, "exportKeyNotFound", name);
        }
        catch (err) {
            if (err instanceof core.NotFoundError) {
                throw err;
            }
            throw new core.GeneralError(this.CLASS_NAME, "exportKeyFailed", { name, keyPath }, err);
        }
    }
    /**
     * Get the key configuration.
     * @param name The name of the key to get the configuration for.
     * @returns True if the key can be deleted.
     */
    async getKeyDeleteConfiguration(name) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        const path = this.getTransitKeyPath(name);
        const url = `${this._baseUrl}/${path}`;
        try {
            const response = await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.GET, undefined, { headers: this._headers });
            return response.data.deletion_allowed;
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "getKeyDeleteConfigurationFailed", { name }, err);
        }
    }
    /**
     * Read key information from the vault.
     * @param name The name of the key.
     * @returns An object containing key information.
     * @internal
     */
    async readKey(name) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        const path = this.getTransitKeyPath(name);
        const url = `${this._baseUrl}/${path}`;
        try {
            const response = await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.GET, undefined, { headers: this._headers });
            if (response?.data?.name) {
                const keyName = response.data.name;
                return { name: keyName, type: response.data.type };
            }
            throw new core.NotFoundError(this.CLASS_NAME, "keyNotFound", name);
        }
        catch (err) {
            if (err instanceof web.FetchError && err.properties?.httpStatus === 404) {
                throw err;
            }
            else {
                throw new core.GeneralError(this.CLASS_NAME, "invalidReadKeyResponse", { name }, err);
            }
        }
    }
    /**
     * Map the vault key type to the hashicorp type.
     * @param type The vault key type.
     * @returns The hashicorp type as a string.
     * @throws Error if the key type is not supported.
     * @internal
     */
    mapVaultKeyType(type) {
        switch (type) {
            case vaultModels.VaultKeyType.Ed25519:
                return "ed25519";
            case vaultModels.VaultKeyType.ChaCha20Poly1305:
                return "chacha20-poly1305";
            default:
                throw new core.GeneralError(this.CLASS_NAME, "unsupportedKeyType", { type });
        }
    }
    /**
     * Map the vault key type to the hashicorp type index.
     * @param type The vault key type.
     * @returns The hashicorp type as a string.
     * @throws Error if the key type is not supported.
     * @internal
     */
    mapVaultKeyTypeToIndex(type) {
        // https://github.com/hashicorp/vault/blob/7d89f7104ed6c98e06ca2c75da20c9ef1b113831/sdk/helper/keysutil/policy.go#L58
        switch (type) {
            case vaultModels.VaultKeyType.Ed25519:
                return 2;
            case vaultModels.VaultKeyType.ChaCha20Poly1305:
                return 5;
            default:
                throw new core.GeneralError(this.CLASS_NAME, "unsupportedKeyType", { type });
        }
    }
    /**
     * Map the hashicorp key type to the vault type.
     * @param type The hashicorp key type.
     * @returns The vault key type.
     * @throws Error if the key type is not supported.
     * @internal
     */
    mapHashicorpKeyType(type) {
        switch (type) {
            case "ed25519":
                return vaultModels.VaultKeyType.Ed25519;
            case "chacha20-poly1305":
                return vaultModels.VaultKeyType.ChaCha20Poly1305;
            default:
                throw new core.GeneralError(this.CLASS_NAME, "unsupportedKeyType", { type });
        }
    }
    /**
     * Check if the key type is asymmetric.
     * @param type The key type.
     * @returns True if the key type is asymmetric.
     */
    isAsymmetricKeyType(type) {
        switch (type) {
            case vaultModels.VaultKeyType.Ed25519:
            case vaultModels.VaultKeyType.Secp256k1:
                return true;
            default:
                return false;
        }
    }
    /**
     * Fetch the versions of a secret.
     * @param name The name of the secret.
     * @returns The versions of the secret.
     * @throws Error if the secret is not found.
     * @internal
     */
    async fetchSecretVersions(name) {
        core.Guards.stringValue(this.CLASS_NAME, "name", name);
        try {
            const path = this.getSecretMetadataPath(name);
            const url = `${this._baseUrl}/${path}`;
            const response = await web.FetchHelper.fetchJson(this.CLASS_NAME, url, web.HttpMethod.GET, undefined, { headers: this._headers });
            if (response?.data?.versions) {
                const versions = Object.keys(response.data.versions).map(Number);
                return versions;
            }
            throw new core.NotFoundError(this.CLASS_NAME, "versionsNotFound", name);
        }
        catch (err) {
            throw new core.GeneralError(this.CLASS_NAME, "getSecretVersionsFailed", { name }, err);
        }
    }
    /**
     * Encode the name parameter.
     * @param name The name to encode.
     * @returns The encoded name.
     * @internal
     */
    getEncodedName(name) {
        return name.replace(/[^\dA-Za-z-]/g, "_").replace(/[_-]+$/, "");
    }
    /**
     * Get the path for a secret.
     * @param name The name of the secret.
     * @returns The path for the secret.
     * @internal
     */
    getSecretPath(name) {
        return `${this._kvMountPath}/data/${this.getEncodedName(name)}`;
    }
    /**
     * Get the path for the metadata of a secret.
     * @param name The name of the secret.
     * @returns The path for the metadata of the secret.
     * @internal
     */
    getSecretMetadataPath(name) {
        return `${this._kvMountPath}/metadata/${this.getEncodedName(name)}`;
    }
    /**
     * Get the path for a Transit key.
     * @param name The name of the key.
     * @returns The path for the key.
     * @internal
     */
    getTransitKeyPath(name) {
        return `${this._transitMountPath}/keys/${this.getEncodedName(name)}`;
    }
    /**
     * Get the path for exporting a Transit key.
     * @param name The name of the key.
     * @param keyType The type of the key.
     * @returns The path for exporting the key.
     * @internal
     */
    getTransitExportKeyPath(name, keyType) {
        return `${this._transitMountPath}/export/${keyType}/${this.getEncodedName(name)}`;
    }
    /**
     * Get the path for the Transit key config.
     * @param name The name of the key to update.
     * @returns The path for the key config.
     * @internal
     */
    getTransitKeyConfigPath(name) {
        return `${this._transitMountPath}/keys/${this.getEncodedName(name)}/config`;
    }
    /**
     * Get the path to backup a Transit key.
     * @param name The name of the key.
     * @returns The path for the backup key.
     * @internal
     */
    getTransitBackupKeyPath(name) {
        return `${this._transitMountPath}/backup/${this.getEncodedName(name)}`;
    }
    /**
     * Get the path for restoring a Transit key.
     * @param name The name of the key.
     * @returns The path for the restore key.
     * @internal
     */
    getTransitRestoreKeyPath(name) {
        return `${this._transitMountPath}/restore/${this.getEncodedName(name)}`;
    }
    /**
     * Get the path for signing data with a Transit key.
     * @param name The name of the key.
     * @returns The path for the sign.
     * @internal
     */
    getTransitSignPath(name) {
        return `${this._transitMountPath}/sign/${this.getEncodedName(name)}`;
    }
    /**
     * Get the path for verifying data with a Transit key.
     * @param name The name of the key.
     * @returns The path for the verify.
     * @internal
     */
    getTransitVerifyPath(name) {
        return `${this._transitMountPath}/verify/${this.getEncodedName(name)}`;
    }
    /**
     * Get the  path for encrypting data with a Transit key.
     * @param name The name of the key.
     * @returns The path for encryption.
     * @internal
     */
    getTransitEncryptPath(name) {
        return `${this._transitMountPath}/encrypt/${this.getEncodedName(name)}`;
    }
    /**
     * Get the  path for decrypting data with a Transit key.
     * @param name The name of the key.
     * @returns The path for decryption.
     * @internal
     */
    getTransitDecryptPath(name) {
        return `${this._transitMountPath}/decrypt/${this.getEncodedName(name)}`;
    }
}

exports.HashicorpVaultConnector = HashicorpVaultConnector;
