import { Factory, Is, GeneralError, Guards } from '@twin.org/core';
import { DidVerificationMethodType, ProofHelper } from '@twin.org/standards-w3c-did';
import { Jwt, Jwk } from '@twin.org/web';

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Factory for creating identity connectors.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const IdentityConnectorFactory = Factory.createFactory("identity-connector");

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Factory for creating identity profile connectors.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const IdentityProfileConnectorFactory = Factory.createFactory("identity-profile-connector");

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Factory for creating identity resolver connectors.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const IdentityResolverConnectorFactory = Factory.createFactory("identity-resolver-connector");

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Helper methods for documents.
 */
class DocumentHelper {
    /**
     * Runtime name for the class.
     */
    static CLASS_NAME = "DocumentHelper";
    /**
     * Parse the document id into its parts.
     * @param documentId The full document id.
     * @returns The parsed document id.
     */
    static parseId(documentId) {
        if (!Is.stringValue(documentId)) {
            return {
                id: "",
                fragment: ""
            };
        }
        const fragmentIndex = documentId.indexOf("#");
        return {
            id: fragmentIndex === -1 ? documentId : documentId.slice(0, fragmentIndex),
            fragment: fragmentIndex === -1 ? undefined : documentId.slice(fragmentIndex + 1)
        };
    }
    /**
     * Join the document id parts.
     * @param documentId The document id.
     * @param fragment The fragment part for the identifier.
     * @returns The full id.
     */
    static joinId(documentId, fragment) {
        if (!Is.stringValue(documentId)) {
            return "";
        }
        let fullId = documentId;
        if (Is.stringValue(fragment)) {
            if (fragment.startsWith(documentId)) {
                fragment = fragment.slice(documentId.length);
            }
            if (fragment.startsWith("#")) {
                fullId += fragment;
            }
            else {
                fullId += `#${fragment}`;
            }
        }
        return fullId;
    }
    /**
     * Get a verification method from a DID document.
     * @param didDocument The DID Document to get the method from.
     * @param methodName The name of the method to get the JWK from.
     * @param methodType The type of the method, defaults to verificationMethod.
     * @returns The verification method if found.
     * @throws Error if the method is not found.
     */
    static getVerificationMethod(didDocument, methodName, methodType) {
        const verificationMethod = didDocument[methodType ?? DidVerificationMethodType.VerificationMethod]?.find(vm => Is.object(vm) && vm.id === methodName);
        if (Is.object(verificationMethod)) {
            return verificationMethod;
        }
        throw new GeneralError(DocumentHelper.CLASS_NAME, "verificationMethodNotFound", {
            methodName,
            methodType
        });
    }
    /**
     * Gets a JWK from a DID document verification method.
     * @param didDocument The DID Document to get the method from.
     * @param methodName The name of the method to get the JWK from.
     * @param methodType The type of the method, defaults to verificationMethod.
     * @returns The JWK if found.
     * @throws Error if the method is not found.
     */
    static getJwk(didDocument, methodName, methodType) {
        const verificationMethod = DocumentHelper.getVerificationMethod(didDocument, methodName, methodType);
        if (Is.object(verificationMethod) && Is.object(verificationMethod.publicKeyJwk)) {
            return verificationMethod.publicKeyJwk;
        }
        throw new GeneralError(DocumentHelper.CLASS_NAME, "verificationMethodJwkNotFound", {
            methodName,
            methodType
        });
    }
}

// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
/**
 * Helper methods for verification.
 */
class VerificationHelper {
    /**
     * Runtime name for the class.
     */
    static CLASS_NAME = "VerificationHelper";
    /**
     * Verified the JWT.
     * @param resolver The resolver to use for finding the document.
     * @param jwt The token to verify.
     * @returns The decoded payload.
     */
    static async verifyJwt(resolver, jwt) {
        Guards.object(VerificationHelper.CLASS_NAME, "resolver", resolver);
        Guards.string(VerificationHelper.CLASS_NAME, "jwt", jwt);
        const jwtDecoded = await Jwt.decode(jwt);
        const jwtHeader = jwtDecoded.header;
        const jwtPayload = jwtDecoded.payload;
        const jwtSignature = jwtDecoded.signature;
        if (!Is.object(jwtHeader) || !Is.object(jwtPayload) || !Is.uint8Array(jwtSignature)) {
            throw new GeneralError(VerificationHelper.CLASS_NAME, "jwtDecodeFailed");
        }
        const iss = jwtHeader?.iss;
        const kid = jwtHeader?.kid;
        Guards.stringValue(VerificationHelper.CLASS_NAME, "iss", iss);
        Guards.stringValue(VerificationHelper.CLASS_NAME, "kid", kid);
        const didDocument = await resolver.identityResolve(iss);
        const jwk = DocumentHelper.getJwk(didDocument, kid);
        const publicKey = await Jwk.toCryptoKey(jwk);
        return Jwt.verify(jwt, publicKey);
    }
    /**
     * Verified the proof for the document e.g. verifiable credential.
     * @param resolver The resolver to use for finding the document.
     * @param secureDocument The secure document to verify.
     * @returns True if the verification is successful.
     */
    static async verifyProof(resolver, secureDocument) {
        Guards.object(VerificationHelper.CLASS_NAME, "resolver", resolver);
        Guards.object(VerificationHelper.CLASS_NAME, "secureDocument", secureDocument);
        Guards.object(VerificationHelper.CLASS_NAME, "secureDocument.proof", secureDocument.proof);
        const proofList = Is.array(secureDocument.proof)
            ? secureDocument.proof
            : [secureDocument.proof];
        const documentCache = {};
        for (const proof of proofList) {
            if (!Is.stringValue(proof?.verificationMethod)) {
                throw new GeneralError(VerificationHelper.CLASS_NAME, "proofMissingVerificationMethod");
            }
            const proofVerificationMethod = DocumentHelper.parseId(proof.verificationMethod);
            if (!Is.stringValue(proofVerificationMethod.fragment)) {
                throw new GeneralError(VerificationHelper.CLASS_NAME, "proofMissingVerificationMethod");
            }
            let document;
            if (documentCache[proofVerificationMethod.id]) {
                document = documentCache[proofVerificationMethod.id];
            }
            else {
                document = await resolver.identityResolve(proofVerificationMethod.id);
                documentCache[proofVerificationMethod.id] = document;
            }
            const verificationJwk = await DocumentHelper.getJwk(document, proofVerificationMethod.id);
            const verified = ProofHelper.verifyProof(secureDocument, proof, verificationJwk);
            if (!verified) {
                return false;
            }
        }
        return true;
    }
}

export { DocumentHelper, IdentityConnectorFactory, IdentityProfileConnectorFactory, IdentityResolverConnectorFactory, VerificationHelper };
